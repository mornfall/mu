// -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4 -*-

/*
 * Macros for run-time-configurable debug tracing.
 */

/*
 * (c) 2019 Petr Roƒçkai <code@fixp.eu>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#pragma once

#include <string_view>
#include <charconv>
#include <iomanip>
#include <tuple>
#include <variant>

#ifdef __divine__
#include <sys/cdefs.h>
#include <sys/trace.h>
#else
#include <vector>
#include <cstring>
#define __debugfn
#define __boring
#endif

#ifdef __unix__
#include <unistd.h>
#else
#include <cstdio>
#endif

/* The purpose of the TRACE macro is to allow tracing statements to be included
 * in production code, just like ASSERT macros allow for sanity checks and
 * pre/post-condition checking. If compiled with NDEBUG, it's a noop and in
 * debug builds, the output must be enabled by setting environment variables
 * BRICK_TRACE and optionally BRICK_NOTRACE, which accept either `all`, a file
 * name (without path) or a file name and a line number (formatted like
 * `file.cpp:15`). A runtime-disabled trace point compiles to a few lookups in
 * std::unordered_set.
 *
 * Normally, the formatted trace output is printed using std::cerr. The
 * formatting is done using a brq::string_builder (see below) to cut down on
 * overhead and to prevent exceptions being thrown. When built for DiOS, the
 * output is done unconditionally using the __dios_trace mechanism, and the
 * entire trace function is marked as __debugfn (i.e. it is not executed during
 * model checking, only for counter-example generation -- TRACE therefore only
 * causes very modest overhead in DIVINE). */

#define BRICK_LOCATION(stmt) ::brq::trace_location{ __LINE__, __FILE__, stmt }

#ifdef NDEBUG
#define TRACE(...) static_cast< decltype(__VA_ARGS__, void(0)) >(0)
#define NOISE(...) static_cast< decltype(__VA_ARGS__, void(0)) >(0)
#else
#define TRACE(...) ::brq::trace_fn( 2, BRICK_LOCATION( "" ), __VA_ARGS__ )
#define NOISE(...) ::brq::trace_fn( 3, BRICK_LOCATION( "" ), __VA_ARGS__ )
#endif
#define DEBUG(...) ::brq::trace_fn( 1, BRICK_LOCATION( "" ), __VA_ARGS__ )

namespace brq
{

    /* A simple string builder, similar to std::stringstream but much lighter.
     * Only works with 8-bit characters (i.e. no wchar_t or char32_t). Provides
     * a basic selection of formatting operators. To provide formatting
     * operators for custom types, the following idiom may be useful to use the
     * same definition for std::ostream and for string_builder (also works for
     * friend-style definitions):
     *
     * template< typename stream >
     * auto operator<<( stream &o, my_type t ) -> decltype( o << "" )
     * {
     *     // ...
     * }
     *
     * Besides accepting values to format, string_builder also understands
     * std::dec and std::hex IO manipulators. */

    struct string_builder
    {
        char *_buffer = nullptr;
        int32_t _capacity:30, _offset:30;
        bool _hex:1, _oom:1;

        string_builder( const string_builder & ) = delete;
        string_builder( string_builder &&o )
            : _buffer( o._buffer ), _capacity( o._capacity ), _offset( o._offset ),
              _hex( o._hex ), _oom( o._oom )
        {
            o._buffer = nullptr;
            o._capacity = 0;
            o._offset = 0;
        }

        string_builder() noexcept : _capacity( 0 ), _offset( 0 ), _hex( false ), _oom( false ) {}
        ~string_builder() noexcept { free( _buffer ); }

        char *pointer() noexcept { return _buffer + _offset; }
        char *buffer_end() noexcept { return _buffer + _capacity - 1; }
        const char *buffer() const noexcept { return _buffer ? _buffer : ""; }
        std::string_view data() const noexcept { return std::string_view( _buffer, _offset ); }
        int size() noexcept { return _offset; }
        bool truncated() { return _oom; }

        string_builder &hex( bool h = true ) { _hex = h; return *this; }
        string_builder &dec() { _hex = false; return *this; }

        void clear()
        {
            free( _buffer );
            _buffer = nullptr;
            _capacity = _offset = 0;
            _hex = _oom = false;
        }

        bool _make_space( int sz ) noexcept
        {
            if ( _oom )
                return false;
            if ( _offset + sz < _capacity )
                return true;

            int new_capacity = _capacity + std::max( _capacity / 2, sz + 1 );
            void *mem = realloc( _buffer, new_capacity );
            if ( mem )
            {
                _buffer = static_cast< char * >( mem );
                _capacity = new_capacity;
            }
            else
                _oom = true;

            return !_oom;
        }

        string_builder &operator<<( std::string_view str ) noexcept
        {
            if ( !_make_space( str.size() ) ) return *this;
            std::copy( str.begin(), str.end(), pointer() );
            _offset += str.size();
            _buffer[ _offset ] = 0;
            return *this;
        }

        string_builder &operator<<( std::u32string_view us ) noexcept
        {
            while ( !us.empty() )
            {
                if ( !_make_space( 4 ) ) return *this;

                uint32_t wc = us.front();

                if ( ( wc & 0xFFFFF800 ) == 0x00D800 || wc > 0x10FFFF )
                    continue; /* skip the character */

                if ( wc < 0x000080 )
                {
                    _buffer[ _offset++ ] = static_cast< uint8_t >( wc ); 
                }
                else if ( wc < 0x000800 )
                {
                    _buffer[ _offset++ ] = static_cast< uint8_t >( 0xC0 | ( wc >> 6 ) );
                    _buffer[ _offset++ ] = static_cast< uint8_t >( 0x80 | ( wc & 0x03F ) );
                }
                else if ( wc < 0x010000 )
                {
                    _buffer[ _offset++ ] = static_cast< uint8_t >( 0xE0 |   ( wc >> 12 ) );
                    _buffer[ _offset++ ] = static_cast< uint8_t >( 0x80 | ( ( wc & 0x0FC0 ) >> 6 ) );
                    _buffer[ _offset++ ] = static_cast< uint8_t >( 0x80 |   ( wc & 0x003F ) );
                }
                else // if (wc < 0x110000)
                {
                    _buffer[ _offset++ ] = static_cast< uint8_t >( 0xF0 |   ( wc >> 18 ) );
                    _buffer[ _offset++ ] = static_cast< uint8_t >( 0x80 | ( ( wc & 0x03F000 ) >> 12 ) );
                    _buffer[ _offset++ ] = static_cast< uint8_t >( 0x80 | ( ( wc & 0x000FC0 ) >> 6 ) );
                    _buffer[ _offset++ ] = static_cast< uint8_t >( 0x80 |   ( wc & 0x00003F ) );
                }

                us.remove_prefix( 1 );
            }

            return *this;
        }

        string_builder &operator<<( char c ) noexcept
        {
            *this << int( c );
            if ( std::isprint( c ) )
            {
                if ( !_make_space( 3 ) ) return *this;
                _buffer[ _offset++ ] = '\'';
                _buffer[ _offset++ ] = c;
                _buffer[ _offset++ ] = '\'';
                _buffer[ _offset ] = 0;
            }
            return *this;
        }

        string_builder &operator<<( const void *ptr ) noexcept
        {
            auto was_hex = _hex;
            _hex = true;
            (*this) << uintptr_t( ptr );
            _hex = was_hex;
            return *this;
        }

        string_builder &operator<<( const char *str ) noexcept
        {
            return (*this) << ( str ? std::string_view( str ) : "<nullptr>" );
        }

        template< typename C >
        auto operator<<( const C &c ) noexcept
            -> std::enable_if_t< !std::is_convertible_v< C, std::string_view > &&
                                 !std::is_convertible_v< C, std::u32string_view >,
                                 decltype( *this << *c ) >
        {
            if ( c.has_value() )
                return *this << "[ " << *c << " ]";
            else
                return *this << "<null>";
        }

        template< typename C >
        auto operator<<( const C &c ) noexcept
            -> std::enable_if_t< !std::is_convertible_v< C, std::string_view > &&
                                 !std::is_convertible_v< C, std::u32string_view >,
                                 decltype( *this << *c.begin() << *c.end() ) >
        {
            bool first = true;
            *this << "[";
            for ( const auto &e : c )
                *this << ( first ? first = false, " " : ", " ) << e;
            *this << ( first ? "]" : " ]" );
            return *this;
        }

        template< int i = 0, typename... T >
        auto &operator<<( const std::tuple< T... > &t ) noexcept
        {
            if ( i == 0 )
                *this << "[";
            if constexpr ( i < sizeof...( T ) )
            {
                *this << ( i > 0 ? ", " : " " ) << std::get< i >( t );
                return this->operator<<< i + 1 >( t );
            }
            else
                return *this << ( i == 0 ? "]" : " ]" );
        }

        template< typename... T >
        auto &operator<<( const std::variant< T... > &v ) noexcept
        {
            return std::visit( [&]( const auto &val ) -> auto & { return *this << val; }, v );
        }

        template< typename A, typename B >
        auto operator<<( const std::pair< A, B > &p ) noexcept
            -> decltype( *this << p.first << p.second )
        {
            return *this << "[ " << p.first << ", " << p.second << " ]";
        }

        string_builder &operator<<( decltype( std::hex ) manip ) noexcept
        {
            if ( manip == std::hex )
                _hex = true;
            if ( manip == std::dec )
                _hex = false;
            return *this;
        }

        template< typename F >
        auto operator<<( const F &f ) noexcept
            -> decltype( f( *this ), *this )
        {
            return f( *this ), *this;
        }

        template< typename V >
        auto operator<<( const V &val ) noexcept
            -> decltype( std::to_chars( _buffer, _buffer, val ), *this )
        {
            int cap = 16;
            std::to_chars_result result;
            do {
                if ( !_make_space( cap ) ) return *this;
                if constexpr ( std::is_integral< V >::value )
                    result = std::to_chars( pointer(), buffer_end(), val, _hex ? 16 : 10 );
                else
                    result = std::to_chars( pointer(), buffer_end(), val );
                cap *= 2;
            } while ( result.ec == std::errc::value_too_large );

            _offset = result.ptr - _buffer;
            _buffer[ _offset ] = 0;
            return *this;
        }
    };

    struct mark_t
    {
        string_builder *b = nullptr;
        int32_t mark;

        mark_t() = default;
        mark_t( string_builder &b ) : b( &b ), mark( b._offset ) {}
        template< typename T > mark_t operator<<( const T &v ) { *b << v; return *this; }
    };

    struct pad
    {
        mark_t mark;
        int width;
        char ch;
        pad( int w, char ch = ' ' ) : width( w ), ch( ch ) {}
        pad( string_builder &b, pad p ) : mark( b ), width( p.width ), ch( p.ch ) {}

        template< typename T > pad operator<<( const T &v ) { mark << v; return *this; }
        static string_builder &write( string_builder &b, int width, int from, char ch, bool left )
        {
            int output_width = b._offset - from;
            if ( int pad = width - output_width; pad > 0 && b._make_space( pad ) )
            {
                if ( left )
                    std::memmove( b._buffer + from + pad, b._buffer + from, output_width + 1 );
                else
                    b._buffer[ b._offset + pad ] = 0;
                std::memset( b._buffer + ( left ? from : b._offset ), ch, pad );
                b._offset += pad;
            }
            return b;
        }
    };

    static mark_t mark;

    static mark_t operator<<( string_builder &bld, mark_t ) { return mark_t( bld ); }
    static pad operator<<( string_builder &bld, pad p ) { return pad( bld, p ); }

    static string_builder &operator<<( mark_t m, pad p )
    {
        return pad::write( *m.b, p.width, m.mark, p.ch, false );
    }

    static string_builder &operator<<( pad p, mark_t )
    {
        return pad::write( *p.mark.b, p.width, p.mark.mark, p.ch, true );
    }

    /* Wrap __FILE__ and __LINE__, optionally together with a stringified
     * assertion statement. Needs to be cheap to construct and pass around,
     * since in debug builds this happens a lot. */

    struct trace_location
    {
        int line;
        const char *_file, *_statement;

        std::string_view filename() const
        {
            std::string_view r( _file );
            r = r.substr( r.find( '/' ) == r.npos ? 0 : r.rfind( '/' ) + 1 );
            return r;
        }

        std::string_view file() const
        {
            return _file;
        }

        const char *statement() const
        {
            return _statement;
        }
    };

    /* Format a bunch of values into a stream, separated by spaces. Values that
     * don't have a string_builder formatting operator are printed as
     * <unknown>, because TRACE statements can include values whose types
     * depend on template parameters and we don't want TRACE uses to cause
     * unexpected instantiation failures (especially for cases where the user
     * doesn't care about the trace output). */

    struct fallback
    {
        template< typename T >
        constexpr fallback( const T & ) {}
    };

    template< typename stream, typename T >
    auto format_nofail( stream &acc, const T &t ) noexcept
        -> decltype( acc << t, void(0) )
    {
        acc << t;
    }

    template< typename stream >
    void format_nofail( stream &acc, fallback ) noexcept
    {
        acc << "<unknown>";
    }

    template< typename stream >
    void format_args_nofail( stream & ) noexcept {}

    template< typename stream, typename A, typename... Args >
    void format_args_nofail( stream &acc, const A &a, const Args & ... as ) noexcept
    {
        format_nofail( acc, a );
        if constexpr ( !std::is_same< A, decltype( std::hex ) >::value )
            acc << " ";
        format_args_nofail( acc, as... );
    }

    using split_view = std::pair< std::string_view, std::string_view >;

    static inline split_view split( std::string_view p, char d, bool reverse = false )
    {
        auto s = reverse ? p.rfind( d ) : p.find( d );
        if ( s == p.npos )
            return reverse ? split_view{ "", p } : split_view{ p, "" };
        return { p.substr( 0, s ), p.substr( s + 1, p.npos ) };
    }

    /* In debug builds, decide which traces are active at run-time. This is to
     * prevent swamping the user with irrelevant traces from library code they
     * might be using. For short programs (e.g. unit tests), it might be okay
     * to just say `env BRICK_TRACE=all program`. */

    template< typename T >
    [[gnu::constructor]] T &singleton() noexcept
    {
        static char memory[ sizeof( T ) ];
        static T *value = nullptr;
        if ( !value )
            value = new ( memory ) T;
        return *value;
    }

    struct trace
    {
        struct rule_t
        {
            std::string_view suffix;
            int line, level;
        };

        using rules_t = std::vector< rule_t >;
        rules_t _rules;
        bool _print_tid = false, _print_location = false, _use_syslog = false;

        void use_syslog( bool s = true ) { _use_syslog = s; }

        trace()
        {
            if ( auto env = getenv( "TRACE" ) )
            {
                add_rules( env );
                _print_location = true;
            }
            else
                add_rule( "+", 0, 0 ); /* print info-level messages by default */
        }

        int level( std::string_view name )
        {
            if ( name == "off" ) return -1;
            if ( name == "info" ) return 0;
            if ( name == "debug" ) return 1;
            if ( name == "trace" ) return 2;
            if ( name == "noise" ) return 3;
            return 2; /* default to 'trace' */
        }

        void add_rule( std::string_view suffix, int level, int line = 0 )
        {
            _rules.push_back( rule_t{ suffix, line, level } );
        }

        void add_rules( std::string_view str )
        {
            while ( !str.empty() )
            {
                auto [ first, rest ] = split( str, ',' );
                auto [ spec, level_s ] = split( first, '/' );
                auto [ filename, line_s ] = split( spec, ':' );

                int line = 0, lvl = level( level_s );
                if ( line_s.size() )
                    line = strtol( line_s.begin(), nullptr, 10 );

                add_rule( filename, lvl, line );
                str = rest;
            }
        }

        bool enabled( int level, const trace_location &l )
        {
            bool print = false;

            auto f = l.file();
            for ( auto r : _rules )
            {
                auto s = r.suffix;
                if ( s == "+" || s == "*" || 
                     ( f.size() >= s.size() && /* f.ends_with( r.suffix ) */
                       f.compare( f.size() - r.suffix.size(), f.npos, r.suffix ) == 0 ) )
                {
                    if ( r.line && r.line != l.line )
                        continue; /* no match */
                    print = r.level >= level;
                }
            }

            return print;
        }

        bool prepare( string_builder &b, int level, trace_location location )
        {
            if ( !enabled( level, location ) )
                return false;

            if ( _print_location )
                b << location.filename() << ":" << location.line << ": ";
            if ( _print_tid )
                b << "[" << pthread_self() << "] ";

            return true;
        }

#ifdef __divine__
        void print( string_builder &b )
        {
            if ( b.truncated() )
                __vm_cancel();
            __dios_trace_internal( 0, "%s", b.buffer() );
        }
#else
        void print( string_builder &b )
        {
            b << "\n";
#ifdef __unix__
            ::write( 2, b.buffer(), b.size() );
#else
            std::fwrite( b.buffer(), 1, b.size(), stderr );
            std::fflush( stderr );
#endif
        }
#endif
    };

    static inline struct trace &trace() { return singleton< struct trace >(); }

    template< typename... Args >
    __debugfn void trace_fn( int level, trace_location location, const Args &... args ) noexcept
    {
        string_builder builder;
        if ( trace().prepare( builder, level, location ) )
        {
            format_args_nofail( builder, args... );
            trace().print( builder );
        }
    }
}

// vim: syntax=cpp tabstop=4 shiftwidth=4 expandtab
