// -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4 -*-

/*
 * (c) 2019 Petr Roƒçkai <code@fixp.eu>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#pragma once
#include "brick-assert"
#include <tuple>
#include <variant>
#include <functional>
#include <iomanip>
#include <vector>

namespace brq
{
    template< int i = 0, typename... T >
    auto &operator<<( string_builder &b, const std::tuple< T... > &t ) noexcept
    {
        if ( i == 0 )
            b << "[";
        if constexpr ( i < sizeof...( T ) )
        {
            b << ( i > 0 ? ", " : " " ) << std::get< i >( t );
            return operator<<< i + 1 >( b, t );
        }
        else
            return b << ( i == 0 ? "]" : " ]" );
    }

    template< typename... T >
    auto &operator<<( string_builder &b, const std::variant< T... > &v ) noexcept
    {
        return std::visit( [&]( const auto &val ) -> auto & { return b << val; }, v );
    }

    template< typename A, typename B >
    auto operator<<( string_builder &b, const std::pair< A, B > &p ) noexcept
        -> decltype( b << p.first << p.second )
    {
        return b << "[ " << p.first << ", " << p.second << " ]";
    }

    static string_builder &operator<<( string_builder &b, decltype( std::hex ) manip ) noexcept
    {
        if ( manip == std::hex )
            b._hex = true;
        if ( manip == std::dec )
            b._hex = false;
        return b;
    }

    struct mark_t
    {
        string_builder *b = nullptr;
        int32_t mark;

        mark_t() = default;
        mark_t( string_builder &b ) : b( &b ), mark( b._offset ) {}
        template< typename T > mark_t operator<<( const T &v ) { *b << v; return *this; }
    };

    struct pad
    {
        mark_t mark;
        int width;
        char ch;
        pad( int w, char ch = ' ' ) : width( w ), ch( ch ) {}
        pad( string_builder &b, pad p ) : mark( b ), width( p.width ), ch( p.ch ) {}

        template< typename T > pad operator<<( const T &v ) { mark << v; return *this; }
        static string_builder &write( string_builder &b, int width, int from, char ch, bool left )
        {
            int output_width = b._offset - from;
            if ( int pad = width - output_width; pad > 0 && b._make_space( pad ) )
            {
                if ( left )
                    std::memmove( b._buffer + from + pad, b._buffer + from, output_width + 1 );
                else
                    b._buffer[ b._offset + pad ] = 0;
                std::memset( b._buffer + ( left ? from : b._offset ), ch, pad );
                b._offset += pad;
            }
            return b;
        }
    };

    static mark_t mark;

    static mark_t operator<<( string_builder &bld, mark_t ) { return mark_t( bld ); }
    static pad operator<<( string_builder &bld, pad p ) { return pad( bld, p ); }

    static string_builder &operator<<( mark_t m, pad p )
    {
        return pad::write( *m.b, p.width, m.mark, p.ch, false );
    }

    static string_builder &operator<<( pad p, mark_t )
    {
        return pad::write( *p.mark.b, p.width, p.mark.mark, p.ch, true );
    }

    template< typename transform_t, typename stream_t >
    struct string_transform
    {
        using self_t = string_transform< transform_t, stream_t >;
        transform_t _transform;
        stream_t &_stream;
        int _mark;

        string_transform( transform_t t, stream_t &s )
            : _transform( t ), _stream( s ), _mark( _stream.size() )
        {}

        int size() { return _stream.size(); }

        template< typename T > auto process( const T &v, primary_t )
            -> decltype( _transform.process( *this, v ) )
        {
            return _transform.process( _stream, v );
        }

        template< typename T > auto process( const T &v, fallback )
        {
            int start = _stream.size();
            _stream << v;
            size_t count = _stream.size() - start;
            _stream.size() = start;
            char buf[ count ];
            std::memcpy( buf, _stream.buffer() + start, count );
            _transform.process( _stream, std::string_view( buf, count ) );
        }

        template< typename T > self_t &operator<<( const T &v )
        {
            if ( _mark != _stream.size() )
                _transform.reset();
            _mark = _stream.size();
            process( v, primary );
            return *this;
        }
    };

    struct string_window
    {
        const char *_start;
        int _split, _end;

        template< typename T >
        string_window( const T &sv )
            : _start( sv.data() ), _split( 0 ), _end( sv.end() - sv.begin() )
        {}

        std::string_view flush()
        {
            std::string_view rv( _start, _split );
            _start += _split; _end -= _split; _split = 0;
            return rv;
        }

        char shift()   { return _start[ _split++ ]; }
        char peek()    { return _start[ _split ]; }
        bool empty()   { return _split == _end; }
        bool pending() { return _split > 0; }
    };

    template< typename gen_t, typename state_t > struct generator
    {
        using value_type = std::tuple_element_t< 0, std::result_of_t< gen_t( state_t ) > >;
        gen_t _gen;
        state_t _initial;

        struct iterator
        {
            gen_t _gen;
            state_t _state;

            iterator( gen_t g, state_t s ) : _gen( g ), _state( s ) {}
            iterator &operator++() { _state = std::get< 1 >( _gen( _state ) ); return *this; }
            value_type operator*() { return std::get< 0 >( _gen( _state ) ); }
            bool operator==( const iterator &o ) const { return _state == o._state; }
            bool operator!=( const iterator &o ) const { return _state != o._state; }
        };

        auto begin() const { return iterator( _gen, _initial ); }
        auto end()   const { return iterator( _gen, state_t() ); }

        generator( gen_t gen, state_t init ) : _gen( gen ), _initial( init ) {}
    };

    static auto splitter( std::string_view s, char d, bool reverse = false )
    {
        return generator( [=]( auto s ) { return split( s, d, reverse ); }, s );
    }

    static std::string tabulate( std::string_view s )
    {
        std::vector< int > cols;
        std::string out;

        auto stop = [&]( int t, int c )
        {
            if ( t >= cols.size() )
                cols.push_back( c );
            else
                cols[ t ] = std::max( c, cols[ t ] );

            return cols[ t ];
        };

        for ( auto line : splitter( s, '\n' ) )
            for ( int i = 0, c = 0, t = 0; i < line.size(); ++ i, ++ c )
                if ( line[ i ] == '\t' )
                    c = stop( t ++, c + 1 );

        for ( auto line : splitter( s, '\n' ) )
        {
            for ( int i = 0, c = 0, t = 0; i < line.size(); ++ i, ++ c )
                if ( line[ i ] == '\t' )
                {
                    for ( ; c < cols[ t ]; ++ c )
                        out += ' ';
                    ++ t;
                }
                else
                    out += line[ i ];
            out += '\n';
        }

        return out;
    }

    struct quote
    {
        std::string _prefix;
        bool _delim = true;

        void reset() { _delim = true; }
        quote( std::string p ) : _prefix( p ) {}

        std::string delim( bool next )
        {
            auto rv = _delim ? _prefix : "";
            _delim = next;
            return rv;
        }

        template< typename stream >
        void process( stream &out, brq::string_window data )
        {
            while ( !data.empty() )
                if ( data.shift() == '\n' )
                    out << delim( true ) << data.flush();

            if ( data.pending() )
                out << delim( false ) << data.flush();
        }
    };
}

namespace t_brq
{
    struct tabulate
    {
        TEST( sanity )
        {
            std::string_view in = "hello\tworld\nsad\tworld\n";
            auto o = brq::tabulate( in );
            ASSERT_EQ( o, "hello world\n"
                          "sad   world\n" );
        }

        TEST( three )
        {
            std::string_view in = "hello\twar\tagain\nsad\tworld\tprevails\n";
            auto o = brq::tabulate( in );
            ASSERT_EQ( o, "hello war   again\n"
                          "sad   world prevails\n" );
        }
    };
}

// vim: syntax=cpp tabstop=4 shiftwidth=4 expandtab ft=cpp
