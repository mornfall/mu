// -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4 -*-

/*
 * Macros for run-time-configurable debug tracing.
 */

/*
 * (c) 2019 Petr Roƒçkai <code@fixp.eu>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef BRICK_TRACE_H
#define BRICK_TRACE_H

#include <string_view>
#include <string>
#include <charconv>
#include <iomanip>

#ifdef __divine__
#include <sys/cdefs.h>
#include <sys/trace.h>
#else
#include <unordered_set>
#include <cstring>
#include <iostream>
#define __debugfn
#define __boring
#endif

#ifdef NDEBUG

#define TRACE(...) static_cast< decltype(__VA_ARGS__, void(0)) >(0)

#else

#define TRACE(...) ::brq::trace_fn( BRICK_LOCATION( "" ), __VA_ARGS__ )

#endif

namespace brq
{
    struct string_builder
    {
        char *_buffer = nullptr;
        int _capacity = 0, _offset = 0;
        bool _hex:1;

        string_builder( const string_builder & ) = delete;
        string_builder( string_builder && ) = default;
        string_builder() : _hex( false ) {}
        ~string_builder() { free( _buffer ); }

        char *pointer() { return _buffer + _offset; }
        char *buffer_end() { return _buffer + _capacity; }
        char *buffer() { return _buffer; }
        const char *buffer() const { return _buffer; }

        void _make_space( int sz )
        {
            if ( _offset + sz < _capacity )
                return;

            int new_capacity = _capacity + std::max( _capacity / 2, sz + 1 );
            void *mem = realloc( _buffer, new_capacity );
            if ( mem )
            {
                _buffer = static_cast< char * >( mem );
                _capacity = new_capacity;
            }
            else
                throw std::bad_alloc();
        }

        string_builder &operator<<( std::string_view str )
        {
            _make_space( str.size() );
            std::copy( str.begin(), str.end(), pointer() );
            _offset += str.size();
            _buffer[ _offset ] = 0;
            return *this;
        }

        string_builder &operator<<( char c )
        {
            _make_space( 1 );
            _buffer[ _offset++ ] = c;
            _buffer[ _offset ] = 0;
            return *this;
        }

        string_builder &operator<<( void *ptr )
        {
            auto was_hex = _hex;
            _hex = true;
            (*this) << uintptr_t( ptr );
            _hex = was_hex;
            return *this;
        }

        string_builder &operator<<( const char *str )
        {
            return (*this) << std::string_view( str );
        }

        string_builder &operator<<( const std::string &str )
        {
            return (*this) << std::string_view( str );
        }

        string_builder &operator<<( decltype( std::hex ) manip )
        {
            if ( manip == std::hex )
                _hex = true;
            if ( manip == std::dec )
                _hex = false;
            return *this;
        }

        template< typename F >
        auto operator<<( const F &f )
            -> decltype( f( *this ), *this )
        {
            return f( *this ), *this;
        }

        template< typename V >
        auto operator<<( const V &val ) -> decltype( std::to_chars( _buffer, _buffer, val ), *this )
        {
            int cap = 16;
            std::to_chars_result result;
            do {
                _make_space( cap );
                if constexpr ( std::is_integral_v< V > )
                {
                    if ( _hex ) (*this) << "0x";
                    result = std::to_chars( pointer(), buffer_end(), val, _hex ? 16 : 10 );
                }
                else
                    result = std::to_chars( pointer(), buffer_end(), val );
                cap *= 2;
            } while ( result.ec == std::errc::value_too_large );

            _offset = result.ptr - _buffer;
            _buffer[ _offset ] = 0;
            return *this;
        }
    };

    struct trace_location
    {
        int line;
        const char *_file, *_statement;

        std::string short_info() const
        {
            string_builder str;
            str << filename() << ':' << line;
            return str.buffer();
        }

        std::string_view filename() const
        {
            std::string_view r( _file );
            r = r.substr( r.find( '/' ) == r.npos ? 0 : r.rfind( '/' ) + 1 );
            return r;
        }

        std::string file() const
        {
            std::string r( _file );
            int slashes = 0;
            for ( int i = 0; i < int( r.size() ); ++i )
                if ( r[i] == '/' )
                    ++ slashes;

            while ( slashes >= 3 )
            {
                r = r.substr( r.find( "/" ) + 1 );
                -- slashes;
            }

            if ( _file != r )
                r = ".../" + r;
            return r;
        }

        const char *statement() const
        {
            return _statement;
        }
    };

    struct fallback
    {
        template< typename T >
        fallback( const T & ) {}
    };

    template< typename stream, typename T >
    auto format( stream &acc, const T &t ) noexcept
        -> decltype( acc << t, void(0) )
    {
        acc << t;
    }

    template< typename stream >
    void format( stream &acc, fallback ) noexcept
    {
        acc << "<unknown>";
    }

    template< typename stream >
    void format_args( stream & ) noexcept {}

    template< typename stream, typename A, typename... Args >
    void format_args( stream &acc, const A &a, const Args & ... as ) noexcept
    {
        format( acc, a );
        if constexpr ( !std::is_same_v< A, decltype( std::hex ) > )
            acc << " ";
        format_args( acc, as... );
    }

#ifdef __divine__
    static bool enabled( const trace_location & ) { return true; }
#else
    using Set = std::unordered_set< std::string_view >;

    static inline Set init( const char *str_ )
    {
        if ( !str_ )
            return Set();

        std::string_view str( str_ );
        Set i;
        while ( !str.empty() )
        {
            auto s = str.find( ',' );
            i.insert( str.substr( 0, s ) );
            if ( s == str.npos )
                return i;
            str = str.substr( s + 1 );
        }
        return i;
    }

    static bool enabled( const trace_location &l )
    {
        static Set yes = init( getenv( "BRICK_TRACE" ) ), no = init( getenv( "BRICK_NOTRACE" ) );
        static bool all = getenv( "BRICK_TRACE" ) && !strcmp( getenv( "BRICK_TRACE" ), "all" );
        return ( all || yes.count( l.filename() ) || yes.count( l.short_info() ) ) &&
               !no.count( l.filename() ) && !no.count( l.short_info() );
    }
#endif

    template< typename... Args >
    __debugfn void trace_fn( trace_location l, const Args &... args ) noexcept
    {
        if ( !enabled( l ) )
            return;
        string_builder acc;
        acc << l.short_info() << ": ";
#ifndef __divine__
        acc << "[" << pthread_self() << "] ";
#endif
        format_args( acc, args... );

#ifdef __divine__
        __dios_trace_internal( 0, "%s", acc.buffer() );
#else
        acc << "\n";
        std::cerr << acc.buffer() << std::flush;
#endif
    }
}

#endif

// vim: syntax=cpp tabstop=4 shiftwidth=4 expandtab
