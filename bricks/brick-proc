// -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4 -*-

/*
 * (c) 2016 Vladimír Štill <xstill@fi.muni.cz>
 * (c) 2020 Adam Matoušek <xmatous3@fi.muni.cz>
 */

/* Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE. */

#pragma once

#include <brick-except>
#include <brick-fs>
#include <brick-string>

#include <string>
#include <vector>
#include <algorithm>
#include <iterator>
#include <sstream>
#include <iostream>
#include <future>
#include <memory>

#if defined( __unix__ ) || defined( __divine__ )
#include <termios.h>
#include <unistd.h>
#include <signal.h>
#include <spawn.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <poll.h>
#endif

extern char **environ;

namespace brick {
namespace proc {

struct ProcError : brq::error
{
    using brq::error::error;
};

enum SpawnOptsEnum : unsigned {
    None = 0,
    CaptureStdout = 0x1,
    CaptureStderr = 0x2,
    ShowCmd = 0x100
};

struct SpawnOpts {
    SpawnOpts( SpawnOptsEnum f ) : flags( f ) { }
    SpawnOpts( unsigned f ) : flags( SpawnOptsEnum( f ) ) { }
    explicit SpawnOpts( std::string in ) : hasStdin( true ), in( in ) { }

    bool hasFlag( SpawnOptsEnum f ) const { return (flags & f) == f; }

    bool hasStdin = false;
    std::string in;
    SpawnOptsEnum flags = None;
};

inline SpawnOpts StdinString( std::string in ) { return SpawnOpts( in ); }

inline SpawnOpts operator|( SpawnOpts a, SpawnOpts b ) {
    a.flags = SpawnOptsEnum( a.flags | b.flags );
    ASSERT( !(a.hasStdin && b.hasStdin) );
    if ( b.hasStdin ) {
        a.hasStdin = true;
        a.in = std::move( b.in );
    }
    return a;
}

struct SystemOutput {

    SystemOutput( int exitcode, int signal, std::string out, std::string err ) :
        _exitcode( exitcode ), _signal( signal ), _out( out ), _err( err )
    { }

    bool ok() const { return _exitcode == 0 && _signal == 0; }
    explicit operator bool() const { return ok(); }

    int exitcode() const { return _exitcode; }
    int signal() const { return _signal; }

    const std::string &out() const { return _out; }
    const std::string &err() const { return _err; }

  private:
    int _exitcode;
    int _signal;
    std::string _out;
    std::string _err;
};

inline namespace {

std::string to_string( const SystemOutput &o ) {
    std::stringstream ss;
    ss << "exitcode = " << o.exitcode() << ", signal = " << o.signal() << std::endl;
    for ( auto x : { std::make_pair( "stdout", &o.out() ), std::make_pair( "stderr", &o.err() ) } ) {
        if ( !x.second->empty() ) {
            ss << x.first << ":" << std::endl;
            std::stringstream data( *x.second );
            std::string line;
            while ( std::getline( data, line ) )
                ss << "    " << line << std::endl;
            ss << std::endl;
        }
    }
    return ss.str();
}

}

struct fd
{
    int _number = -1;
    int number() const { return _number; }

    template< typename... args_t >
    void open( args_t... args )
    {
        _number = ::open( args... );
        if ( _number < 0 )
            brq::raise< brq::system_error >() << "error opening file" << brq::format( args... );
    }

    void close()
    {
        if ( _number >= 0 )
            ::close( _number );
        _number = -1;
    }

    void acquire( int n )
    {
        close();
        _number = n;
    }

    template< typename... args_t >
    fd( args_t... args ) { open( args... ); }

    fd() = default;
    fd( const fd & ) = delete;
    fd &operator=( const fd &rhs ) = delete;

    fd( fd &&rhs ) : _number( rhs._number )
    {
        rhs._number = -1;
    }

    fd &operator=( fd &&rhs )
    {
        close();
        _number = rhs._number;
        rhs._number = -1;
        return *this;
    }

    ~fd() { close(); }
};

struct pipe
{
    fd _in, _out;

    pipe()
    {
        int fds[ 2 ];
        if ( ::pipe2( fds, O_CLOEXEC ) == -1 )
            brq::raise< brq::system_error >() << "could not create a pipe";
        _in.acquire( fds[ 0 ] );
        _out.acquire( fds[ 1 ] );
    }

    void close()
    {
        _in.close();
        _out.close();
    }

    void close_read()  { _in.close(); }
    void close_write() { _out.close(); }

    std::string drain()
    {
        std::string str;
        char data[ 1024 ];
        long n;
        do {
            n = ::read( read().number(), data, sizeof( data ) );
            if ( n > 0 )
                str += std::string( data, n );
        } while( n > 0 );
        return str;
    }

    void push( std::string s )
    {
        const char *ptr = s.data();
        const char *const end = ptr + s.size();
        int r = 0;
        while ( ptr < end && r >= 0 ) {
            r = ::write( write().number(), ptr, end - ptr );
            ptr += r;
        }
    }

    const fd &read()  const { return _in; }
    const fd &write() const { return _out; }

    void attach_stdout() { ::dup2( write().number(), STDOUT_FILENO ); }
    void attach_stderr() { ::dup2( write().number(), STDERR_FILENO ); }
    void attach_stdin()  { ::dup2( read().number(), STDIN_FILENO ); }
};

inline SystemOutput spawnAndWait( SpawnOpts opts, std::vector< std::string > args )
{
    if ( opts.hasFlag( ShowCmd ) ) {
        std::cerr << "+ ";
        std::copy( args.begin(), args.end(), std::ostream_iterator< std::string >( std::cerr, " " ) );
        std::cerr << std::endl;
    }
    std::vector< const char * > cargs;
    std::transform( args.begin(), args.end(), std::back_inserter( cargs ),
                    []( const std::string &s ) { return s.c_str(); } );
    cargs.push_back( nullptr );
    std::string out, err;

#ifdef __unix__
    std::future< void > inf;
    std::future< std::string > outf, errf;
    std::unique_ptr< pipe > inp, outp, errp;
    if ( opts.hasStdin )
        inp = std::make_unique< pipe >();
    if ( opts.hasFlag( CaptureStdout ) )
        outp = std::make_unique< pipe >();
    if ( opts.hasFlag( CaptureStderr ) )
        errp = std::make_unique< pipe >();

    pid_t pid;
    if ( (pid = ::fork()) == 0 ) {
        if ( inp ) {
            inp->attach_stdin();
            inp->close();
        }
        if ( outp ) {
            outp->attach_stdout();
            outp->close();
        }
        if ( errp ) {
            errp->attach_stderr();
            errp->close();
        }

        ::execvp( cargs[ 0 ], const_cast< char *const * >( cargs.data() ) );
        std::cerr << "exec failed: " << cargs[ 0 ] << std::endl;
        ::_exit( 1 );
    } else if ( pid > 0 ) {
        if ( inp ) {
            inp->close_read();
            inf = std::async( std::launch::async, [&] { inp->push( opts.in ); inp->close(); } );
        }
        if ( outp ) {
            outp->close_write();
            outf = std::async( std::launch::async, [&] { return outp->drain(); } );
        }
        if ( errp ) {
            errp->close_write();
            errf = std::async( std::launch::async, [&] { return errp->drain(); } );
        }
        int status;
        int r = ::waitpid( pid, &status, 0 );

        if ( inf.valid() )
            inf.get();
        out = outf.valid() ? outf.get() : "";
        err = errf.valid() ? errf.get() : "";

        if ( r < 0 )
            throw ProcError( "waitpid error" );
        return SystemOutput( WIFEXITED( status ) ? WEXITSTATUS( status ) : 0,
                             WIFSIGNALED( status ) ? WTERMSIG( status ) : 0,
                             out, err );
    } else
        throw ProcError( "fork failed" );
#else
#error implementation of brick::proc::spawnAndWait for this platform is missing
#endif
}

inline SystemOutput spawnAndWait( std::vector< std::string > args ) {
    return spawnAndWait( None, args );
}

template< typename... Args >
SystemOutput spawnAndWait( SpawnOpts opts, Args &&...args ) {
    return spawnAndWait( opts, std::vector< std::string >{ std::forward< Args >( args )... } );
}

template< typename... Args >
SystemOutput spawnAndWait( SpawnOptsEnum opts, Args &&...args ) {
    return spawnAndWait( SpawnOpts( opts ), std::forward< Args >( args )... );
}

template< typename... Args >
SystemOutput spawnAndWait( unsigned opts, Args &&...args ) { // note: result of | on SpawnOptsEnum in unsigned
    return spawnAndWait( SpawnOpts( SpawnOptsEnum( opts ) ), std::forward< Args >( args )... );
}

template< typename... Args >
SystemOutput spawnAndWait( Args &&...args ) {
    return spawnAndWait( None, std::forward< Args >( args )... );
}

inline SystemOutput shellSpawnAndWait( SpawnOpts opts, std::string shellcmd ) {
#ifdef __unix__
    return spawnAndWait( opts, "/bin/sh", "-c", shellcmd );
#else
#error shell spawn is not supported on this platform
#endif
}

inline SystemOutput shellSpawnAndWait( std::string shellcmd ) {
    return shellSpawnAndWait( None, shellcmd );
}

struct spawn_result
{
    pid_t pid;
    pipe to_child,
         from_chld;
};

template< typename Exec >
std::enable_if_t< std::is_invocable_v< Exec >, spawn_result >
spawn( Exec exec )
{
#ifdef __unix__
    pipe to_child,
         from_child;

    pid_t pid = ::fork();

    if ( pid == -1 )
        throw brq::system_error( "spawn: fork" );
    if ( pid == 0 )
    {
        /* CHILD */
        to_child.attach_stdin();
        from_child.attach_stdout();
        to_child.close();
        from_child.close();

        exec();
        throw brq::system_error( "spawn: exec didn't, in fact, exec" );
    }

    /* PARENT */
    to_child.close_read();
    from_child.close_write();

    return { pid, std::move( to_child ), std::move( from_child ) };
#else
#error implementation of brick::proc::spawn for this platform is missing
#endif
}

inline auto spawn( std::vector< std::string > args )
{
    std::vector< const char * > cargs;
    std::transform( args.begin(), args.end(), std::back_inserter( cargs ),
                    []( const std::string &s ) { return s.c_str(); } );
    cargs.push_back( nullptr );

    return spawn( [&](){ ::execvp( cargs[ 0 ], const_cast< char * const * >( cargs.data() ) ); } );
}

template< typename... Args >
auto spawn( Args &&... args )
{
    return spawn( std::vector< std::string >{ std::forward< Args >( args )... } );
}

/* • ‹write› is called when writing is possible; gets the file descriptor as
 *   its argument and returns whether to attempt for further writes; see the
 *   ‹feed› function for a pre-made implementation.
 * • ‹read› is called when reading is possible; gets the file descriptor as
 *   its argument and returns whether to continue. See ‹each_line›
 *   for a handy wrapper. */

template < typename write_t, typename read_t >
void communicate( fd fd_out, fd fd_in, write_t do_write, read_t do_read )
{
    ::fcntl( fd_out.number(), F_SETFL, O_NONBLOCK );
    ::fcntl( fd_in.number(),  F_SETFL, O_NONBLOCK );

    pollfd fdset[2] = { { fd_out.number(), POLLOUT, 0 },
                        { fd_in.number(),  POLLIN,  0 } };

    while ( true )
    {
        int res = poll( fdset, 2, 10 * 1000 );

        if ( res == -1 )
        {
            if ( errno == EINTR )
                continue;
            throw brq::system_error( "communicate: poll" );
        }

        if ( res == 0 )
            throw std::runtime_error( "pipethrough: poll timed out" );

        if ( ( fdset[0].revents & POLLERR ) ||
             ( fdset[0].revents & POLLOUT ) && !do_write( fd_out ) )
        {
            fd_out.close();
            fdset[0].fd = -1;
        }

        if ( ( fdset[1].revents & POLLERR ) ||
             ( fdset[1].revents & ( POLLIN | POLLHUP ) ) && !do_read( fd_in ) )
        {
            fd_in.close();
            break;
        }
    }
}

/* Pipethrough for filtering data through a subprocess.
 *
 * 'Exec' shall execve(2) eventually. See ‹communicate› above regarding ‹read›
 * and ‹write›. File descriptors are closed automatically, don't do it in the
 * callbacks.
 *
 * Returns the return code of the subprocess or a negative number of the signal
 * that terminated it. */

template < typename Write, typename Read, typename... Exec >
int pipethrough( Write do_write, Read do_read, Exec... exec )
{
#ifdef __unix__
    auto [ pid, to_child_p, from_child_p ] = spawn( exec... );

    communicate( to_child_p.write(), from_child_p.read(), do_write, do_read );

    int wst;
    if ( waitpid( pid, &wst, 0 ) < 0 )
        throw brq::system_error( "pipethrough: wait" );
    if ( WIFEXITED( wst ) )
        return WEXITSTATUS( wst );
    if ( WIFSIGNALED( wst ) )
        return - WTERMSIG( wst );
    UNREACHABLE( "wrong waitpid result type" );
    // pipes get closed here
#else
#error implementation of brick::proc::pipethrough for this platform is missing
#endif
}

template< typename Yield, unsigned BUFFER_SIZE = 512 >
struct each_line
{
    char _buffer[ BUFFER_SIZE ];
    std::string _line_buffer;
    Yield yield;

    each_line( Yield y ) : yield( y ) {}
    ~each_line()
    {
        // in case the last line doesn't end with LF
        if ( ! _line_buffer.empty() )
            yield( _line_buffer );
    }

    bool operator()( int fd )
    {
        int res = read( fd, _buffer, BUFFER_SIZE - 1 );
        if ( res == -1 )
        {
            if ( errno == EAGAIN || errno == EWOULDBLOCK )
                return true;
            throw brq::system_error( "each_line: read" );
        }

        _buffer[ res ] = '\0';
        _line_buffer.append( _buffer );
        for ( int lf; ( lf = _line_buffer.find( '\n' ) ) != std::string::npos; )
        {
            yield( _line_buffer.substr( 0, lf ) ); // don't include the newline
            _line_buffer.erase( 0, lf + 1 );
        }

        return res > 0;
    };
};

inline auto feed( std::string_view data )
{
    return [data] ( int fd ) mutable -> bool {
        int res = write( fd, data.data(), data.length() );
        if ( res == -1 )
        {
            if ( errno == EPIPE )
                return false;
            if ( errno == EAGAIN || errno == EWOULDBLOCK )
                return true;
            throw brq::system_error( "feed: write" );
        }
        data.remove_prefix( res );
        return !data.empty();
    };
}


struct XTerm
{
    struct
    {
        int pid = 0;
        int masterfd, slavefd;

        std::unique_ptr< std::iostream > stream;
        std::unique_ptr< brq::posix_buf > buf;
    } _d;

    struct SBuf : brq::posix_buf
    {
        using brq::posix_buf::posix_buf;

        int sync()
        {
            char tmp[ _buf_size * 2 ];
            int i = 0;
            for ( auto p = pbase(); p < pptr(); ++p )
            {
                if ( *p == '\n' )
                    tmp[ i++ ] = '\r';
                tmp[ i++ ] = *p;
            }
            do_sync( tmp, i );
            return 0;
        }
    };

    void open()
    {
        _d.masterfd = posix_openpt( O_RDWR );
        if ( grantpt( _d.masterfd ) )
            throw std::system_error( errno, std::system_category(),
                                     "Could not grantpt()." );
        if ( unlockpt( _d.masterfd ) )
            throw std::system_error( errno, std::system_category(),
                                     "Could not unlockpt()." );

        const char *slavepts = ptsname( _d.masterfd );
        if ( !slavepts )
            throw std::system_error( errno, std::system_category(),
                                     "Could not ptsname()." );
        _d.slavefd = ::open( slavepts, O_RDWR );
        if ( _d.slavefd < 0 )
            throw std::system_error( errno, std::system_category(),
                                     "Could not open slave PTS." );

        std::string slave = std::string( "-S" ) +
                            slavepts + "/" + std::to_string( _d.slavefd );
        const char *argv[] = { "xterm", slave.c_str(), nullptr };

        posix_spawnattr_t sp;
        posix_spawnattr_init( &sp );
        posix_spawnattr_setflags( &sp, POSIX_SPAWN_SETPGROUP );
        posix_spawnattr_setpgroup( &sp, 0 );
        posix_spawnp( &_d.pid, "xterm", nullptr, &sp,
                      const_cast< char ** >( argv ), environ );

        char buf[8];
        ::read( _d.masterfd, buf, 8 ); /* handshake */

        struct termios tio;
        tcgetattr( _d.slavefd, &tio );
        tio.c_lflag = 0; /* no ECHO means we don't read things back */
        tio.c_iflag = 0;
        tio.c_oflag = 0;
        tcsetattr( _d.slavefd, TCSANOW, &tio );

        _d.buf.reset( new SBuf( _d.masterfd ) );
        _d.stream.reset( new std::iostream( _d.buf.get() ) );
    }

    std::iostream &stream() { return *_d.stream; }

    XTerm() = default;
    XTerm( const XTerm & ) = delete;
    XTerm( XTerm &&o )
    {
        _d = std::move( o._d );
        o._d.pid = 0;
    }

    ~XTerm()
    {
        if ( _d.pid )
        {
            kill( _d.pid, SIGTERM );
            close( _d.masterfd );
            close( _d.slavefd );
            waitpid( _d.pid, nullptr, 0 );
        }
        _d.pid = 0;
    }
};

}

namespace t_proc {

struct TestSpawn {
    TEST( basic_true ) {
        auto r = proc::spawnAndWait( "true" );
        ASSERT_EQ( r.exitcode(), 0 );
        ASSERT_EQ( r.signal(), 0 );
        ASSERT( r );
    }

    TEST( basic_false ) {
        auto r = proc::spawnAndWait( "false" );
        ASSERT_LT( 0, r.exitcode() );
        ASSERT_EQ( r.signal(), 0 );
        ASSERT( !r );
    }

    TEST( echo1 ) {
        auto r = proc::spawnAndWait( proc::CaptureStdout, "printf", "a" );
        ASSERT( r );
        ASSERT_EQ( r.out(), "a" );
        ASSERT_EQ( r.err(), "" );
    }

    TEST( echo2 ) {
        auto r = proc::spawnAndWait( proc::CaptureStdout | proc::CaptureStderr, "printf", "a" );
        ASSERT( r );
        ASSERT_EQ( r.out(), "a" );
        ASSERT_EQ( r.err(), "" );
    }

    TEST( echoSpec ) {
        auto r = proc::spawnAndWait( proc::CaptureStdout, "printf", "a\nb" );
        ASSERT( r );
        ASSERT_EQ( r.out(), "a\nb" );
        ASSERT_EQ( r.err(), "" );
    }

    TEST( shellEchoStdout ) {
        auto r = proc::shellSpawnAndWait( proc::CaptureStdout, "printf a" );
        ASSERT( r );
        ASSERT_EQ( r.out(), "a" );
        ASSERT_EQ( r.err(), "" );
    }

    TEST( shellEchoStderr ) {
        auto r = proc::shellSpawnAndWait( proc::CaptureStdout | proc::CaptureStderr, "printf a >&2" );
        ASSERT( r );
        ASSERT_EQ( r.out(), "" );
        ASSERT_EQ( r.err(), "a" );
    }

    TEST( in_basic ) {
        auto r = proc::spawnAndWait( proc::StdinString( "abcbd" ) | proc::CaptureStdout | proc::CaptureStderr,
                                     "sed", "s/b/x/g" );
        ASSERT( r );
        ASSERT_EQ( r.out(), "axcxd" );
        ASSERT_EQ( r.err(), "" );
    }
    TEST( in_lined ) {
        auto r = proc::spawnAndWait( proc::StdinString( "abcbd\nebfg\n" ) | proc::CaptureStdout | proc::CaptureStderr,
                                     "sed", "s/b/x/g" );
        ASSERT( r );
        ASSERT_EQ( r.out(), "axcxd\nexfg\n" );
        ASSERT_EQ( r.err(), "" );
    }
};

struct TestPipethrough {
    using strs = std::vector< std::string >;
    TEST( lines ) {
        strs out;
        proc::pipethrough( proc::feed( "foo\nbar\nbaz" ),
                           proc::each_line( [&]( auto l ){ out.emplace_back( l ); }),
                           "cat" );
        ASSERT_EQ( out, strs{ "foo", "bar", "baz" } );
    }
    TEST( noread ) {
        std::string out;
        proc::pipethrough( []( int ){ return false; },
                           proc::each_line( [&]( auto l ){ out = l; }),
                           "echo", "-e", "lorem ipsum\\nhello world" );
        ASSERT_EQ( out, "hello world" );
    }
    TEST( empty ) {
        int n = 0;
        proc::pipethrough( proc::feed( "this\ngets\ndiscarded" ),
                           proc::each_line( [&]( auto ){ ++n; }),
                           "sh", "-c", "> /dev/null" );
        ASSERT_EQ( n, 0 );
    }
    TEST( retval ) {
        int n = 0;
        int ret = proc::pipethrough( []( int ){ return false; },
                                     proc::each_line( [&]( auto ){ ++n; }),
                                     "true" );
        ASSERT_EQ( ret, 0 );
        ASSERT_EQ( n, 0 );
        ret = proc::pipethrough( []( int ){ return false; },
                                 proc::each_line( [&]( auto ){ ++n; }),
                                 "false" );
        ASSERT_LT( 0, ret );
        ASSERT_EQ( n, 0 );

        try {
            ret = proc::pipethrough( []( int ){ return false; },
                                     proc::each_line( [&]( auto ){ ++n; }),
                                     "/dev/null" );
        } catch ( ... ) {
            // this only happens in the child
            abort();
        }
        ASSERT_LT( ret, 0 );
        ASSERT_EQ( n, 0 );
    }
};

};

}

// vim: syntax=cpp tabstop=4 shiftwidth=4 expandtab ft=cpp
