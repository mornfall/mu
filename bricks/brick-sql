// -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4 -*-

/*
 * Copyright (C) 2019 Petr Rockai <code@fixp.eu>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#pragma once
#include "brick-assert"
#include "brick-sqldata"
#include "brick-sqlexec"

namespace brq::sql
{
    struct txn;

    template< bool sub = false, typename stream, typename V >
    static stream &print( stream &s, const V &v, int &id )
    {
        if constexpr ( is_set< V >::value )
        {
            int i = 0;
            if ( v.empty() )
                s << "( select null::" << sql_type< typename V::value_type >() << " where false";
            for ( const auto &e : v )
                s << ( i ++ ? ", " : "( " ), print( s, e, id );
            s << " )";
        }
        else if constexpr ( is_value< V > )
        {
            if ( id >= 0 )
                s << "$" << id++ << "::" << sql_type< V >();
            else if constexpr ( std::is_same_v< V, std::nullopt_t > )
                s << "null";
            else
                s << "'" << v << "'::" << sql_type< V >();
        }
        else if constexpr ( std::is_same_v< V, std::nullopt_t > )
            s << "null";
        else if constexpr ( is_optional< V >::value )
        {
            if constexpr ( !std::is_same_v< V, std::nullopt_t > )
                if ( v.has_value() )
                    return print( s, *v, id );

            s << "null::" << sql_type< V >();
        }
        else if constexpr ( std::is_same_v< V, where_operator > )
            s << v.sql;
        else if constexpr ( brq::is_list_v< V > )
        {
            bool first = true;
            auto item = [&]( const auto &i )
            {
                s << ( first ? "" : ", " );
                print< sub >( s, i, id );
                first = false;
            };
            v.each( item );
            s << " ";
        }
        else if constexpr ( V::is_function )
            s << v.get_name( v ), v.print( s, id );
        else if constexpr ( V::is_column )
            s << v.get_name( v ) << "::" << sql_type< typename V::type >();
        else if constexpr ( V::is_query )
        {
            if ( sub ) s << "( ";
            v.print( s, id ), v.print_tail( s, id );
            if ( sub ) s << " )";
        }
        else if constexpr ( V::is_expr )
            v.print( s, id );
        else
            v.give_me_a_build_error();

        return s;
    }

    template< typename stmt, typename V >
    static auto bind( stmt &s, const V &v )
    {
        if constexpr ( is_set< V >::value )
            for ( const auto &e : v )
                bind( s, e );
        else if constexpr ( is_value< V > ) s.bind( v ) ;
        else if constexpr ( is_optional< V >::value )
        {
            if constexpr ( !std::is_same_v< V, std::nullopt_t > )
                if ( v.has_value() )
                    bind( s, *v );
        }
        else if constexpr ( std::is_same_v< V, where_operator > ) /* nothing */ ;
        else if constexpr ( is_list_v< V > ) /* nothing */ ;
        else if constexpr ( V::is_function ) v.bind( s ) ;
        else if constexpr ( V::is_column ) /* nothing */ ;
        else
            v.bind( s );
    }

    struct opaque_base
    {
        virtual void print( brq::string_builder &b, int &id ) const = 0;
        virtual void bind( stmt_base &b ) const = 0;
        virtual ~opaque_base() = default;
    };

    using opaque_ptr = std::shared_ptr< opaque_base >;

    template< typename query_t >
    struct opaque : opaque_base
    {
        query_t _query;
        opaque( query_t q ) : _query( std::move( q ) ) {}

        void print( brq::string_builder &b, int &id ) const override { _query.print( b, id ); }
        void bind( stmt_base &b ) const override { _query.bind( b ); }
    };

    struct opaque_vec : category_flags
    {
        static const constexpr bool is_query = true;
        static const constexpr bool is_expr  = true;

        std::vector< opaque_ptr > _vec;
        opaque_vec( std::vector< opaque_ptr > &&vec ) : _vec( std::move( vec ) ) {}
        opaque_vec() = default;

        void append( opaque_ptr p )
        {
            _vec.push_back( std::move( p ) );
        }

        template< typename query_t > void append( query_t q )
        {
            _vec.emplace_back( new opaque( q ) );
        }

        void print_tail( string_builder &, int & ) const {}

        void print( string_builder &b, int &id, const char *join, const char *empty ) const
        {
            int i = 0;

            for ( const auto &o : _vec )
            {
                if ( i++ ) b << " " << join << " ";
                o->print( b, id );
            }

            if ( _vec.empty() )
                b << empty;
        }

        template< typename stmt > void bind( stmt &s ) const
        {
            for ( const auto &o : _vec )
                o->bind( s );
        }
    };

    struct row_number : constant< void, true > {};

    template< typename tab, typename col >
    struct in_table : col
    {
        using bare = col;
        using qualifier = tab;
        static constexpr bool is_qualified = true;

        template< typename CT >
        static std::string_view get_name( const CT & )
        {
            static auto name = "\""  + std::string( tab::get_name( tab() ) ) +
                               "\"." + std::string( col::get_name( col() ) );
            return name;
        }
    };

    template< typename from, typename to >
    struct rename : to
    {
        static_assert( std::is_same_v< typename from::columns, typename to::columns > );

        template< typename self_t >
        static std::string_view declare( const self_t & )
        {
            static std::string name( format( "\"", from::get_name( from() ), "\" as \"",
                                             to::get_name( to() ), "\"" ).data() );
            return name;
        }
    };

    template< typename... cols >
    struct tuple
    {
        static constexpr bool is_column = false;
        static constexpr bool is_enum = false;
        static constexpr bool is_query = false;
        static constexpr bool is_function = false;
        static constexpr bool is_expr = true;
        static constexpr bool is_asc = true;

        brq::cons_list_t< cols... > _cols;
        tuple( cols... c ) : _cols( c... ) {}

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            s << "( "; sql::print( s, _cols, id ); s << " )";
        }

        template< typename stmt > void bind( stmt &s ) const
        {
            _cols.each( [&]( const auto &c ) { sql::bind( s, c ); } );
        }
    };

    template< typename col >
    struct excluded : col
    {
        template< typename CT >
        static std::string_view get_name( const CT & )
        {
            static auto name = "excluded." + std::string( col::get_name( col() ) );
            return name;
        }
    };

    template< typename type, typename... args >
    struct function : constant< type >
    {
        static constexpr bool is_qualified = true;
        static constexpr bool is_function  = true;

        using args_t = brq::cons_list_t< args... >;
        using bare = typename args_t::car_t;
        args_t _args;
        bool _print_type = true;

        function( args... ts ) : _args( ts... ) {}
        function() = default;

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            s << "( ";
            sql::print< true >( s, _args, id );
            s << " )";
            if ( _print_type )
                if constexpr ( !std::is_same_v< type, void > )
                    s << "::" << sql_type< type >();
        }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            _args.each( [&]( auto &v ) { sql::bind( s, v ); } );
        }
    };

    template< typename... cols >
    using endomorphism = function< typename cons_list_t< cols... >::car_t::type, cols... >;

    template< typename col > struct count : function< int32_t, col >
    {
        explicit count( const col &c = col() ) : function< int32_t, col >( c ) {}
    };

    template< typename col > struct convert_from : function< std::u32string, col >
    {
        explicit convert_from( const col &c = col() ) : function< std::u32string, col >( c ) {}
        template< typename stream > void print( stream &s, int &id ) const
        {
            s << "( ";
            sql::print( s, this->_args, id );
            s << ", 'utf8' )";
        }
    };

    template< typename col > struct length : function< int32_t, col >
    {
        explicit length( const col &c = col() ) : function< int32_t, col >( c ) {}
    };

#define BRICK_SQL_ENDO(n) \
    template< typename... cols > struct n : endomorphism< cols... > \
    { explicit n( cols... cs ) : endomorphism< cols... >( cs... ) {} n() = default; }

    BRICK_SQL_ENDO( bool_and );
    BRICK_SQL_ENDO( bool_or );
    BRICK_SQL_ENDO( min );
    BRICK_SQL_ENDO( max );
    BRICK_SQL_ENDO( sum );
    BRICK_SQL_ENDO( avg );
    BRICK_SQL_ENDO( greatest );
    BRICK_SQL_ENDO( least );
    BRICK_SQL_ENDO( distinct );
    BRICK_SQL_ENDO( every );

#undef BRICK_SQL_ENDO

    template< typename col, typename type > struct cast_to : function< type, col >
    {
        static constexpr const bool is_query = true;
        static constexpr const bool is_column = false;
        static constexpr const bool is_function = false;
        using function< type, col >::function;

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            s << "(";
            sql::print( s, this->_args, id );
            s << ")::" << sql_type< type >();
        }

        void print_tail( string_builder &, int & ) const {}
    };

    template< typename col > struct cast
    {
        col _col;
        cast( const col &c ) : _col( c ) {}

        template< typename T >
        cast_to< col, T > to() { return { _col }; }
    };

    template< typename... cols >
    struct coalesce : endomorphism< cols... >
    {
        coalesce( const cols & ... v ) : endomorphism< cols... >( v... ) {}
    };

    template< typename col >
    struct substring : endomorphism< col >
    {
        std::string _pat;

        substring( const col &c, std::string_view p ) : endomorphism< col >( c ), _pat( p ) {}

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            s << "( ";
            sql::print( s, this->_args, id );
            s << " from '" << _pat << "' )::" << sql_type< typename col::type >();
        }
    };

    template< typename col >
    struct percentile_disc : endomorphism< col >
    {
        int _frac;
        percentile_disc( const col &c, double p ) : endomorphism< col >( c ), _frac( p ) {}

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            s << "( " << _frac << " / 100.0 ) within group ( order by ";
            sql::print( s, this->_args, id );
            s << " )::" << sql_type< typename col::type >();
        }
    };

    struct txn;

    template< typename... args >
    struct where_expr : column_flags
    {
        static constexpr bool is_expr = true;
        static constexpr bool is_asc  = true;

        using type = void; /* we don't know :( */

        cons_list_t< args... > _args;
        bool _parens = false;

        where_expr( args... as ) : _args( as... ) {}
        where_expr() = default;

        template< typename T >
        cast_to< where_expr, T > as() const { return { *this }; }

        template< typename stream >
        stream &print( stream &s, int &id ) const
        {
            s << ( _parens ? "( " : "" );
            _args.each( [&]( auto v ) { sql::print< true >( s, v, id ); s << " "; } );
            return s << ( _parens ? ")" : "" );
        }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            _args.each( [&]( auto &v ) { sql::bind( s, v ); } );
        }
    };

    template< typename T >
    auto set_nested( T &t, brq::primary_t ) -> decltype( t._parens )
    {
        return t._parens = true;
    }

    template< typename T >
    auto set_nested( T &t, brq::primary_t ) -> decltype( t._print_type )
    {
        return t._print_type = false;
    }

    template< typename T >
    void set_nested( T &, brq::fallback ) {}

    template< typename... args_t >
    struct where_expr_nested : where_expr< args_t... >
    {
        where_expr_nested( args_t... args ) : where_expr< args_t... >( args... )
        {
            this->_args.each( [&]( auto &v ) { set_nested( v, primary ); } );
        }
    };

    template< template< typename... > class expr_t, typename... args_t >
    using op_t_ = std::enable_if_t< ( is_expr_v< std::decay_t< args_t > > || ... ),
                                    expr_t< std::decay_t< args_t > ... > >;

    template< typename... args_t > using op_t   = op_t_< where_expr, args_t... >;
    template< typename... args_t > using nest_t = op_t_< where_expr_nested, args_t... >;

    using w_op = where_operator;


#define BRICK_SQL_OP_(op, sql) \
    template< typename A, typename B > nest_t< A, w_op, B > op( A &&a, B &&b ) { return { a, sql, b }; }
#define BRICK_SQL_OP(op) BRICK_SQL_OP_(operator op, #op)

BRICK_SQL_OP_( operator ==, "=" )
BRICK_SQL_OP_( like, "like" )
BRICK_SQL_OP_( re, "~" )
BRICK_SQL_OP_( re_i, "~*" )
BRICK_SQL_OP_( similar, "similar to" )
BRICK_SQL_OP_( operator &&, "and" )
BRICK_SQL_OP_( operator ||, "or" )
BRICK_SQL_OP_( operator ^, "#" )
BRICK_SQL_OP_( pow, "^" )
BRICK_SQL_OP_( in, "in" )
BRICK_SQL_OP_( cat, "||" )

BRICK_SQL_OP( < )
BRICK_SQL_OP( > )
BRICK_SQL_OP( <= )
BRICK_SQL_OP( >= )
BRICK_SQL_OP( != )
BRICK_SQL_OP( + )
BRICK_SQL_OP( - )
BRICK_SQL_OP( * )
BRICK_SQL_OP( / )
BRICK_SQL_OP( % )
BRICK_SQL_OP( & )
BRICK_SQL_OP( | )

#undef BRICK_SQL_OP

    template< typename P, typename O >
    auto window( P partition, O order )
    {
        if constexpr ( std::is_same_v< O, brq::unit > )
            return where_expr{ where_operator( "partition by" ), partition };
        else
            return where_expr{ where_operator( "partition by" ), partition,
                               where_operator( "order by" ), order };
    }

    template< typename F, typename P, typename O = brq::unit >
    auto over( F function, P partition, O order = O() )
    {
        auto w = window( partition, order );
        set_nested( function, primary );
        set_nested( w, primary );
        return where_expr{ function, where_operator( "over" ), w };
    }

    template< typename A > op_t< A, w_op > is_null( A &&a )   { return { a, "is null" }; }
    template< typename A > op_t< A, w_op > is_true( A &&a )   { return { a, "is true" }; }
    template< typename A > op_t< A, w_op > desc( A &&a )      { return { a, "desc" }; }
    template< typename A > op_t< A, w_op > asc( A &&a )       { return { a, "asc" }; }
    template< typename A > op_t< w_op, A > operator!( A &&a ) { return { "not", a }; }

    template< typename C, typename T, typename E >
    op_t< w_op, C, w_op, T, w_op, E, w_op > when( C c, T t, E e )
    {
        return { "case", c, "when true then", t, "else", e, "end" };
    }

    struct all_of : opaque_vec
    {
        using type = bool;
        using opaque_vec::opaque_vec;
        void print( string_builder &b, int &id ) const
        {
            opaque_vec::print( b, id, "and", "true" );
        }
    };

    struct any_of : opaque_vec
    {
        using type = bool;
        using opaque_vec::opaque_vec;
        void print( string_builder &b, int &id ) const
        {
            opaque_vec::print( b, id, "or", "false" );
        }
    };

    struct query_base
    {
        static constexpr bool is_column = false;
        static constexpr bool is_query = true;
        static constexpr bool is_expr = true;
        static constexpr bool is_enum = false;
        static constexpr bool is_function = false;
        using type = void; /* we don't know :( */

        template< typename stmt, typename T >
        stmt _exec( T *t )
        {
            stmt s( t->conn(), *t );
            t->bind( s );
            s.exec();
            return s;
        }

        void print_tail( string_builder &, int & ) const {}
    };

    template< typename q, typename col >
    constexpr bool has_column = q::stmt::columns::template has< col >;

    template< typename > struct raw_sql;

    template< typename query >
    struct extend : query_base
    {
        using stmt      = typename query::stmt;
        using columns_t = typename query::columns_t;

        query _query;
        sql::conn &conn() { return _query.conn(); }
        sql::txn &txn() { return _query.txn(); }
        extend( query q ) : _query( q ) {}

        void set_skip_select() { _query.set_skip_select(); }
        auto order_columns() const { return _query.order_columns(); }
        template< typename T > stmt _exec( T *t ) { return query_base::_exec< stmt >( t ); }

        template< typename stmt >
        void bind( stmt &s ) const { _query.bind( s ); }

        void print( string_builder &s, int &id ) const
        {
            _query.print( s, id );
        }

        void print_tail( string_builder &s, int &id ) const
        {
            _query.print_tail( s, id );
        }
    };

    template< typename query >
    struct limit_clause : extend< query >
    {
        int64_t _limit;

        limit_clause( query &q, int64_t l ) : extend< query >( q ), _limit( l ) {}

        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " limit $" << id++;
        }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            this->_query.bind( s );
            sql::bind( s, _limit );
        }

        sql::raw_sql< limit_clause > raw_sql( std::string_view sv ) { return { *this, sv }; }
    };

    template< typename select, typename... cols >
    struct group_by;

    template< typename query, typename... cols >
    struct order_clause : extend< query >
    {
        brq::cons_list_t< cols... > _cols;
        using extend< query >::extend;
        order_clause( query &q, cols... cs ) : extend< query >( q ), _cols( cs... ) {}

        template< typename cols_t >
        order_clause( query &q, cols_t cs ) : extend< query >( q ), _cols( cs ) {}

        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " order by ";
            auto l = this->order_columns().cat( _cols );
            int count = 0;
            auto print_one = [&]( auto &c )
            {
                s << ( count++ ? ", " : "" );
                sql::print( s, c, id );
                if ( !c.is_asc )
                    s << " desc ";
            };
            l.each( print_one );
        }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            this->_query.bind( s );
            _cols.each( [&]( const auto &c ) { sql::bind( s, c ); } );
        }

        sql::raw_sql< order_clause > raw_sql( std::string_view sv ) { return { *this, sv }; }

        template< typename... ct, typename... et > [[nodiscard]]
        order_clause< query, cols..., ct..., et... > order_by( et... ex )
        {
            return { this->_query, _cols.cat( brq::cons_list( ex... ) ) };
        }

        limit_clause< order_clause > limit( int l ) { return { *this, l }; }
    };

    template< typename query, typename expr >
    struct where_clause : extend< query >
    {
        expr _expr;
        const char *_clause;
        where_clause( query q, const expr &e, const char *c = "where" )
            : extend< query >( q ), _expr( e ), _clause( c )
        {}

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " " << _clause << " ";
            sql::print( s, _expr, id );
        }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            this->_query.bind( s );
            sql::bind( s, _expr );
        }

        template< typename... group_cols > [[nodiscard]]
        group_by< where_clause, group_cols... > group_by() { return { *this }; }

        template< typename... ct, typename... et > [[nodiscard]]
        order_clause< where_clause, ct..., et... > order_by( et... ex ) { return { *this, ex... }; }

        template< typename we_t > [[nodiscard]]
        auto where( we_t we ) { return sql::where_clause( this->_query, _expr && we ); }

        limit_clause< where_clause > limit( int l ) { return { *this, l }; }

        sql::raw_sql< where_clause > raw_sql( std::string_view sv ) { return { *this, sv }; }

        auto exec() { return this->_exec( this ); }
    };

    template< typename select, typename... cols >
    struct group_by : extend< select >
    {
        using extend< select >::extend;
        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " group by ";
            print_columns( s, cons_list( cols()... ) );
        }

        template< typename we_t > [[nodiscard]]
        where_clause< group_by, we_t > having( const we_t &we ) { return { *this, we, "having" }; }

        template< typename... ct, typename... et > [[nodiscard]]
        order_clause< group_by, ct..., et... > order_by( et... ex ) { return { *this, ex... }; }
    };

    enum class join_type { inner, left, right };

    template< typename T >
    using underlying = std::conditional_t< T::is_view && T::columns::car_t::is_qualified &&
                                           T::columns::car_t::is_primary,
                                           typename T::columns::car_t::qualifier, T >;

    template< typename select, typename tab, typename on_t = brq::nil >
    struct select_join : extend< select >
    {
        join_type _type;
        on_t _join_on;

        using tables = brq::cons< tab, typename select::tables >;
        select_join( const select &s, join_type t = join_type::inner, on_t on = on_t() )
            : extend< select >( s ), _type( t ), _join_on( on )
        {}

        auto exec() { return this->_exec( this ); }

        template< typename stream, typename tabs_left = typename select::tables >
        void print( stream &s, int &id ) const
        {
            using tab_left = typename tabs_left::car_t;
            using tab_right = tab;

            using tab_left_u  = underlying< tab_left >;
            using tab_right_u = underlying< tab_right >;

            std::vector< std::string > foreign_column;
            std::vector< std::string > primary_column;

            auto find_foreign_left = [&]( auto t )
            {
                using col = unqualify< decltype( t ) >;
                if constexpr ( t.is_foreign )
                    if constexpr ( std::is_same_v< typename col::table, tab_left_u > )
                        foreign_column.emplace_back( col::get_name( col() ) );
            };

            auto find_foreign_right = [&]( auto t )
            {
                using col = unqualify< decltype( t ) >;
                if constexpr ( t.is_foreign )
                    if constexpr ( std::is_same_v< typename col::table, tab_right_u > )
                        foreign_column.emplace_back( col::get_name( col() ) );
            };

            auto find_primary = [&]( auto t )
            {
                if constexpr ( t.is_primary )
                {
                    if constexpr ( t.is_qualified )
                    {
                        using bare = typename decltype( t )::bare;
                        primary_column.emplace_back( bare::get_name( bare() ) );
                    }
                    else
                        primary_column.emplace_back( t.get_name( t ) );
                }
            };

            brq::string_builder cond;

            auto tab_r = tab_right::get_name( tab_right() ),
                 tab_l = tab_left::get_name( tab_left() );

            auto emit_join = [&]( auto tab_p, auto tab_f )
            {
                ASSERT_EQ( primary_column.size(), foreign_column.size(),
                           primary_column, foreign_column );

                for ( int i = 0; i < primary_column.size(); ++ i )
                    cond <<    "\"" << tab_f << "\"." << foreign_column[ i ]
                         << " = \"" << tab_p << "\"." << primary_column[ i ]
                         << ( i < primary_column.size() - 1 ? " and " : "" );
            };

            if constexpr ( std::is_same_v< on_t, brq::nil > )
            {
                typename tab_right::columns().each( find_foreign_left );
                typename tab_left::columns().each( find_primary );

                if ( !foreign_column.empty() && !primary_column.empty() )
                    emit_join( tab_l, tab_r );
                else
                {
                    primary_column.clear();
                    foreign_column.clear();
                    typename tab_right::columns().each( find_primary );
                    typename tab_left::columns().each( find_foreign_right );

                    if ( !foreign_column.empty() && !primary_column.empty() )
                        emit_join( tab_r, tab_l );
                    else if constexpr ( !tabs_left::cdr_t::empty )
                        return print< stream, typename tabs_left::cdr_t >( s, id );
                    else
                        brq::raise< error >() << "could not find join key on "
                                              << tab_l << " x " << tab_r;
                }
            }

            this->_query.print( s, id );

            switch ( _type )
            {
                case join_type::inner: s << " inner"; break;
                case join_type::left: s << " left"; break;
                case join_type::right: s << " right"; break;
            }

            s << " join " << tab_right::declare( tab_right() ) << " on ";
            if constexpr ( std::is_same_v< on_t, brq::nil > )
                s << cond.buffer();
            else
                sql::print( s, _join_on, id );
        }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            this->_query.bind( s );
            sql::bind( s, _join_on );
        }

        template< typename expr_t > [[nodiscard]]
        select_join< select, tab, expr_t > on( expr_t e ) { return { this->_query, _type, e }; }

        template< typename we_t > [[nodiscard]]
        where_clause< select_join, we_t > where( const we_t &we ) { return { *this, we }; }

        template< typename table > [[nodiscard]]
        select_join< select_join, table > join() const { return { *this }; }

        template< typename table > [[nodiscard]]
        select_join< select_join, table > left_join() const { return { *this, join_type::left }; }

        template< typename table > [[nodiscard]]
        select_join< select_join, table > right_join() const { return { *this, join_type::right }; }

        template< typename... group_cols > [[nodiscard]]
        group_by< select_join, group_cols... > group_by() { return { *this }; }

        template< typename... ct, typename... et > [[nodiscard]]
        order_clause< select_join, ct..., et... > order_by( et... ex ) { return { *this, ex... }; }

        sql::raw_sql< select_join > raw_sql( std::string_view sv ) { return { *this, sv }; }
    };

    template< typename query >
    struct raw_sql : extend< query >
    {
        raw_sql( const query &q, std::string_view sv ) : extend< query >( q ), _sql( sv ) {}
        std::string _sql;
        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " " << _sql;
        }

        template< typename table > [[nodiscard]]
        select_join< raw_sql, table > join() const { return { *this }; }

        template< typename table > [[nodiscard]]
        select_join< raw_sql, table > left_join() const { return { *this, join_type::left }; }

        template< typename table > [[nodiscard]]
        select_join< raw_sql, table > right_join() const { return { *this, join_type::right }; }

        template< typename... group_cols > [[nodiscard]]
        group_by< raw_sql, group_cols... > group_by() { return { *this }; }

        template< typename we_t > [[nodiscard]]
        where_clause< raw_sql, we_t > where( const we_t &we ) { return { *this, we }; }

        template< typename... ct, typename... et > [[nodiscard]]
        order_clause< raw_sql, ct..., et... > order_by( et... ex ) { return { *this, ex... }; }
    };

    template< typename head > auto sql_join( const head &q ) { return q; }

    template< typename join, typename... joins, typename head >
    auto sql_join( const head &q )
    {
        return sql_join< joins... >( q.template join< join >() );
    }

    template< typename select, typename tab >
    struct select_tab : extend< select >
    {
        using tables = brq::cons_list_t< tab >;
        using extend< select >::extend;
        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " from \"" << get_name( tab() ) << "\"";
        }

        template< typename table, typename... joins > [[nodiscard]]
        auto join() const { return sql_join< joins... >( select_join< select_tab, table >( *this ) ); }

        template< typename table > [[nodiscard]]
        select_join< select_tab, table > left_join() const { return { *this, join_type::left }; }

        template< typename table > [[nodiscard]]
        select_join< select_tab, table > right_join() const { return { *this, join_type::right }; }

        template< typename... group_cols > [[nodiscard]]
        sql::group_by< select_tab, group_cols... > group_by() { return { *this }; }

        template< typename we_t > [[nodiscard]]
        where_clause< select_tab, we_t > where( const we_t &we ) { return { *this, we }; }

        template< typename... ct, typename... et > [[nodiscard]]
        order_clause< select_tab, ct..., et... > order_by( et... ex ) { return { *this, ex... }; }

        [[nodiscard]] sql::raw_sql< select_tab > raw_sql( std::string_view sv ) { return { *this, sv }; }
    };

    template< typename... > struct select;

    template< typename select, typename... views >
    struct select_with : extend< select >
    {
        brq::cons_list_t< views... > _views;
        using extend< select >::extend;
        select_with( const select &q, const views &... vs ) : extend< select >( q ), _views( vs... ) {}
        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            int i = 0;
            auto fmt = [&]( auto v )
            {
                using view = decltype( v );
                s << ( i++ ? ", " : "with recursive " );
                s << v.declare( v ) << " ";
                print_columns( s, typename view::columns::template map_t< unqualify >(), "( ", " )" );
                s << " as ";
                sql::print< true >( s, v.construct(), id );
            };
            _views.each( fmt );
            this->_query.print( s, id );
        }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            _views.each( [&]( const auto &v ) { sql::bind( s, v.construct() ); } );
            this->_query.bind( s );
        }

        template< typename table, typename... joins > [[nodiscard]]
        auto from() { return sql_join< joins... >( select_tab< select_with, table >( *this ) ); }
    };

    template< typename... views, typename query > auto with( query q )
    {
        return select_with< query, views... >( q );
    };

    template< typename select, typename... cols >
    struct select_distinct : extend< select >
    {
        brq::cons_list_t< cols... > _cols;
        auto order_columns() const { return _cols; }
        using extend< select >::extend;
        auto exec() { return this->_exec( this ); }

        template< typename... et >
        select_distinct( const select &q, et... e ) : extend< select >( q ), _cols( e... ) {}

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            s << "select distinct ";
            if constexpr ( sizeof...( cols ) > 0 )
                s << " on ( ", sql::print( s, _cols, id ), s << " ) ";
            this->_query.print( s, id );
        }

        template< typename table, typename... joins > [[nodiscard]]
        auto from() { return sql_join< joins... >( select_tab< select_distinct, table >( *this ) ); }

        template< typename... ct, typename... et > [[nodiscard]]
        select_with< select_distinct, ct..., et... > with( et... e ) { return { *this, e... }; }
    };

    template< typename... cols >
    struct query_head : query_base, with_columns< cols... >
    {
        using stmt = sql::stmt< cols... >;
        sql::txn *_txn;
        sql::txn &txn() { return *_txn; }
        sql::conn &conn();

        query_head( sql::txn &t ) : _txn( &t ) {}
        query_head() : _txn( nullptr ) {}

        brq::nil order_columns() const { return {}; }

        template< typename stmt >
        void bind( stmt & ) const {}
    };

    template< typename... cols >
    struct select : query_head< cols... >
    {
        typename query_head< cols...>::columns _cols;
        bool _skip_select = false;

        using query_head< cols... >::query_head;
        select( sql::txn &t, cols... e ) : query_head< cols... >( t ), _cols( e... ) {}
        select( cols... e ) : _cols( e... ) {}
        template < typename list >
        select( sql::txn &t, list cs ) : query_head< cols... >( t ), _cols( cs ) {}
        select( brq::cons_list_t< cols... > cs ) : _cols( cs ) {}

        template< typename... ct, typename... et >
        select< cols..., ct..., et... > columns( et... e )
        {
            return { *this->_txn, _cols.cat( brq::cons_list( e... ) ) };
        }

        template< typename table, typename... joins > [[nodiscard]]
        auto from() { return sql_join< joins... >( select_tab< select, table >( *this ) ); }

        template< typename we_t > [[nodiscard]]
        where_clause< select, we_t > where( const we_t &we ) { return { *this, we }; }

        template< typename... ct, typename... et > [[nodiscard]]
        select_distinct< select, ct..., et... > distinct( et... e )
        {
            auto s = *this;
            s._skip_select = true;
            return { s, e... };
        }

        template< typename... ct, typename... et > [[nodiscard]]
        select_with< select, ct..., et... > with( et... e )
        {
            return { *this, e... };
        }

        void set_skip_select() { _skip_select = true; }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            if ( !_skip_select )
                s << "select ";
            sql::print< true >( s, _cols, id );
        }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            _cols.each( [&]( const auto &c ) { sql::bind( s, c ); } );
        }

        using typename query_head< cols... >::stmt;
        stmt exec() { return query_base::_exec< stmt >( this ); }
        sql::raw_sql< select > raw_sql( std::string_view sv ) { return { *this, sv }; }
    };

    template< typename T > constexpr bool is_str_v = std::is_same_v< T, const std::string & >;
    template< typename T > constexpr bool is_u32s_v = std::is_same_v< T, const std::u32string & >;
    template< bool C, typename A, typename B > using cond_t = std::conditional_t< C, A, B >;
    template< typename T > using to_u32v = cond_t< is_u32s_v< T >, std::u32string_view, T >;
    template< typename T > using to_view = cond_t< is_str_v< T >, std::string_view, to_u32v< T > >;

    template< typename query_t, typename cols_t, typename args_t >
    struct update_set : extend< query_t >
    {
        args_t _args;

        auto exec() { return this->_exec( this ); }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            this->_query.bind( s );
            _args.each( [&]( auto &v ) { sql::bind( s, v ); } );
        }

        update_set( query_t q, args_t args )
            : extend< query_t >( q ), _args( args )
        {}

        template< typename stream >
        bool print( stream &s, int &id ) const
        {
            bool first = this->_query.print( s, id );

            s << ( first ? " set " : ", " );

            auto fmt_update = [&]( auto col, auto arg ) -> std::string
            {
                string_builder b;
                b << col.get_name( col ) << " = ";
                sql::print( b, arg, id );
                return b.buffer();
            };

            print_list( s, brq::zip( fmt_update, cols_t(), _args ) );
            return false;
        }

        template< typename... cols, typename... et > [[nodiscard]]
        update_set< update_set, cons_list_t< cols... >, cons_list_t< et... > > set( et... e )
        {
            return { *this, cons_list_t( e... ) };
        }

        /* FIXME? this does not make sense after 'on conflict update' */
        template< typename we_t > [[nodiscard]]
        where_clause< update_set, we_t > where( const we_t &we ) { return { *this, we }; }
    };

    template< typename insert >
    struct insert_update : extend< insert >
    {
        using extend< insert >::extend;

        template< typename stream >
        bool print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << "update ";
            return true;
        }

        template< typename... cols, typename... et > [[nodiscard]]
        update_set< insert_update, cons_list_t< cols... >, cons_list_t< et... > > set( et... e )
        {
            return { *this, cons_list_t( e... ) };
        }
    };

    template< typename insert, typename... cols >
    struct conflict_clause : extend< insert >
    {
        using extend< insert >::extend;

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " on conflict ( ";
            print_columns( s, cons_list( cols()... ) );
            s << " ) do ";
        }

        insert_update< conflict_clause > update() { return { *this }; }
    };

    template< typename insert, typename... vals_t >
    struct insert_values : extend< insert >
    {
        cons_list_t< vals_t... > _vals;

        insert_values( insert i, to_view< const vals_t & >... v )
            : extend< insert >( i ), _vals( vals_t( v )... )
        {}

        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " values";

            int i = 0;
            _vals.each( [&]( const auto & ) { s << ( i++ ? ", " : " ( " ) << "$" << id; id ++; } );
            s << " )";
        }

        template< typename... ccols > [[nodiscard]]
        conflict_clause< insert_values, ccols... > on_conflict() { return { *this }; }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            this->_query.bind( s );
            s.bind_list( _vals );
        }
    };

    template< typename insert, typename query_t >
    struct insert_query : extend< insert >
    {
        query_t _subquery;

        insert_query( insert i, query_t q )
            : extend< insert >( i ), _subquery( std::move( q ) )
        {}

        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );

            s << " ( ";
            _subquery.print( s, id );
            s << " )";
        }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            this->_query.bind( s );
            _subquery.bind( s );
        }

        template< typename... cols >
        conflict_clause< insert_query, cols... > on_conflict() { return { *this }; }
    };

    template< typename insert, typename... cols_t >
    struct insert_columns : extend< insert >
    {
        using extend< insert >::extend;

        void print( string_builder &s, int &id ) const
        {
            this->_query.print( s, id );
            sql::print_columns( s, cons_list_t< cols_t... >(), "( ", " )" );
        }

        template< typename... cols > [[nodiscard]]
        auto values( to_view< const typename cols_t::type & >... v ) const
        {
            return insert_values< insert_columns, typename cols_t::type... >( *this, v... );
        }

        template< typename query_t > [[nodiscard]]
        auto query( query_t q ) const
        {
            return insert_query< insert_columns, query_t >( *this, q );
        }
    };

    template< typename tbl >
    struct insert : query_head<>
    {
        sql::conn *_conn = nullptr;
        mutable bool _quiet = false;

        using table = tbl;
        using primary_l = typename table::columns::template filter_t< is_primary >;
        using stmt = std::conditional_t< std::is_same_v< primary_l, brq::nil >, sql::stmt<>,
                                         sql::stmt< typename get_key< primary_l >::type > >;
        using order_columns = brq::nil;

        insert() = default;
        explicit insert( sql::conn &c ) : _conn( &c ) {}

        insert on_conflict_do_nothing() const
        {
            auto i = *this;
            i._quiet = true;
            return i;
        }

        void print( string_builder &s, int & ) const
        {
            typename insert::table tab;
            s << "insert into " << tab.declare( tab );
        }

        void print_tail( string_builder &s, int & ) const
        {
            if ( _quiet )
                s << " on conflict do nothing";

            if constexpr ( !std::is_same_v< typename insert::primary_l, brq::nil > )
            {
                using primary = unqualify< typename insert::primary_l::car_t >;
                s << " returning " << primary::get_name( primary() );
            }
        }

        sql::conn &conn() { return *_conn; }

        template< typename... cols >
        auto columns() const
        {
            return insert_columns< insert, cols... >( *this );
        }

        template< typename... cols > [[nodiscard]]
        auto values( to_view< const typename cols::type & >... v ) const
        {
            return columns< cols... >().values( v... );
        }

        template< typename query_t > [[nodiscard]]
        auto query( query_t q ) const
        {
            return insert_query< insert, query_t >( *this, q );
        }
    };

    template< typename table >
    struct update : query_head<>
    {
        using query_head<>::query_head;

        template< typename stream >
        bool print( stream &s, int & ) const
        {
            s << "update " << table::declare( table() );
            return true;
        }

        template< typename... cols_t, typename... args_t > [[nodiscard]]
        auto set( const args_t &... v ) ->
            update_set< update, cons_list_t< cols_t... >, cons_list_t< args_t... > >
        {
            return { *this, cons_list_t( v... ) };
        }

        sql::raw_sql< update > raw_sql( std::string_view sv ) { return { *this, sv }; }
    };

    template< typename table >
    struct delete_from : query_head<>
    {
        using query_head<>::query_head;
        stmt exec() { return std::move( stmt( this->conn(), *this ).exec() ); }

        template< typename stream >
        void print( stream &s, int & ) const
        {
            s << "delete from " << table::declare( table() );
        }

        template< typename we_t > [[nodiscard]]
        where_clause< delete_from, we_t > where( const we_t &we ) { return { *this, we }; }
    };

    template< typename q_t, typename... qs_t >
    struct select_union : query_head<>
    {
        cons_list_t< q_t, qs_t... > qs;
        bool all = false;

        select_union( q_t q, qs_t... qs ) : query_head( q.txn() ), qs( q, qs... ) {}
        select_union( bool a, q_t q, qs_t... qs ) : select_union( q, qs... ) { all = a; }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            bool first = true;
            auto one = [&]( const auto &q )
            {
                if ( !first ) s << " union " << ( all ? "all " : "" ) << "( ";
                q.print( s, id );
                if ( !first ) s << " )";
                first = false;
            };
            qs.each( one );
        }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            qs.each( [&]( auto &v ) { sql::bind( s, v ); } );
        }

    };

    template< typename stream, typename query >
    inline auto operator<<( stream &s, const query &st )
        -> std::enable_if_t< query::is_query, decltype( s << std::string() ) >
    {
        int id = 1;
        return sql::print( s, st, id );
    }

    struct txn : txn_base
    {
        using txn_base::txn_base;

        template< typename... ct, typename... et > [[nodiscard]]
        sql::select< ct..., et... > select( et... e ) { open(); return { *this, ct()..., e... }; }

        template< typename... args > [[nodiscard]]
        sql::select< args... > select_list( cons_list_t< args... > ) { open(); return { *this }; }

        template< typename table > [[nodiscard]]
        insert< table > insert_into() { open(); return insert< table >{ conn() }; }

        template< typename table > [[nodiscard]]
        update< table > update() { open(); return { *this }; }

        template< typename table > [[nodiscard]]
        delete_from< table > delete_from() { open(); return { *this }; }
    };

    template< typename... Ts >
    inline conn &query_head< Ts... >::conn() { return _txn->conn(); }
}
