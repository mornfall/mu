// -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4 -*-

/*
 * (c) 2019 Petr Roƒçkai <code@fixp.eu>
 * (c) 2019 Henrich Lauko <xlauko@mail.muni.cz>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#pragma once

#include <brick-assert>
#include <brick-string>
#include <brick-data>

#include <map>
#include <set>
#include <memory>
#include <variant>
#include <iomanip>
#include <optional>
#include <functional>
#include <unordered_map>
#include <unordered_set>
#include <string_view>

namespace brick::smt
{
    enum class Op : int8_t
    {
        Invalid,

        // declare a variable of type
        VarBool, FirstVar = VarBool,
        VarI8,
        VarI16,
        VarI32,
        VarI64,
        VarFloat,
        VarDouble, LastVar = VarDouble,

        Not, FirstUnary = Not,
        BvNot,
        BvNegate, LastUnary = BvNegate,

        SExt, FirstCast = SExt, // sign extend
        ZExt,     // zero extend
        Trunc,    // truncate
        ZFit,
        FPExt,    // floating point extend
        FPTrunc,
        FPToSInt,
        FPToUInt,
        SIntToFP,
        UIntToFP, LastCast = UIntToFP,

        And, FirstBinary = And,
        FirstBvBinary = FirstBinary, // TODO why is And the first *bitvector*? (BvAnd?)
        Or,
        Xor,
        Implies,

        Concat,

        BvAnd,
        BvOr,
        BvXor,
        BvAdd,
        BvSub,
        BvMul,
        BvUDiv,
        BvSDiv,
        BvURem,
        BvSRem,
        BvShl,     // bitvector shift left
        BvLShr,    // bitvector logical shift right -- prepend zeroes
        BvAShr,    // bitvector arithmetical shift right -- copy highest bit

        // Icmp
        Eq, FirstICMP = Eq,
        NE,
        BvULE,
        BvULT,
        BvUGE,
        BvUGT,
        BvSLE,
        BvSLT,
        BvSGE,
        BvSGT, LastICMP = BvSGT,
        LastBvBinary = LastICMP,

        FpAdd, FirstFpBinary = FpAdd,
        FpSub,
        FpMul,
        FpDiv,
        FpRem,

        // Fcmp
        /* Floating point compare, either of the operands can be NaN,
         * in which case the unordered versions are used. */
        FpFalse, FirstFCMP = FpFalse, // no comparison, always returns false
        FpOEQ,   // ordered and equal
        FpOGT,   // ordered and greater than
        FpOGE,   // ordered and greater than or equal
        FpOLT,   // ordered and less than
        FpOLE,   // ordered and less than or equal
        FpONE,   // ordered and not equal
        FpORD,   // ordered (no nans)
        FpUEQ,   // unordered or equal
        FpUGT,   // unordered or greater than
        FpUGE,   // unordered or greater than or equal
        FpULT,   // unordered or less than
        FpULE,   // unordered or less than or equal
        FpUNE,   // unordered or not equal
        FpUNO,   // unordered (either nans)
        FpTrue, LastFCMP = FpTrue,  // no comparison, always returns true
        LastFpBinary = LastFCMP,

        Constraint, LastBinary = Constraint,

        Extract,

        // Evaluate a freestanding RPN as one of the operands
        Call
    };

    enum class Type
    {
        Bool,
        Int,
        Float
    };

    using Bitwidth = int8_t;

    template< Op... Ops >
    static constexpr bool is_one_of( Op op )
    {
        return ( (Ops == op) || ... );
    }

    static inline constexpr bool is_variable( Op op ) noexcept
    {
        return Op::FirstVar <= op && op <= Op::LastVar;
    }

    static inline constexpr bool is_constant( Op op ) noexcept
    {
        return static_cast< Bitwidth >( op ) < 0; // bitwidths are in negative range
    }

    static inline constexpr bool is_unary( Op op ) noexcept
    {
        return Op::FirstUnary <= op && op <= Op::LastUnary;
    }

    static inline constexpr bool is_cast( Op op ) noexcept
    {
        return Op::FirstCast <= op && op <= Op::LastCast;
    }

    static inline constexpr bool is_extract( Op op ) noexcept
    {
        return op == Op::Extract;
    }

    static inline constexpr bool is_binary( Op op ) noexcept
    {
        return Op::FirstBinary <= op && op <= Op::LastBinary;
    }

    static inline constexpr bool is_integer_bin( Op op ) noexcept
    {
        return Op::FirstBvBinary <= op && op <= Op::LastBvBinary;
    }

    static inline constexpr bool is_float_bin( Op op ) noexcept
    {
        return Op::FirstFpBinary <= op && op <= Op::LastFpBinary;
    }

    static inline constexpr bool is_icmp( Op op ) noexcept
    {
        return Op::FirstICMP <= op && op <= Op::LastICMP;
    }

    static inline constexpr bool is_fcmp( Op op ) noexcept
    {
        return Op::FirstFCMP <= op && op <= Op::LastFCMP;
    }

    static inline constexpr bool is_cmp( Op op ) noexcept
    {
        return is_icmp( op ) || is_fcmp( op );
    }

    static inline constexpr bool is_call( Op op ) noexcept
    {
        return op == Op::Call;
    }

    static inline constexpr bool is_concat( Op op ) noexcept
    {
        return op == Op::Concat;
    }

    /* SMT-LIB names for the operations, for generating the string
     * to input to SMT-LIB. */
    inline std::string_view name( Op op )
    {
        switch ( op )
        {
            case Op::Invalid: return "invalid";

            case Op::VarBool: return "bool";
            case Op::VarI8: return "i8";
            case Op::VarI16: return "i16";
            case Op::VarI32: return "i32";
            case Op::VarI64: return "i64";
            case Op::VarFloat: return "float";
            case Op::VarDouble: return "double";

            case Op::Not: return "not";
            case Op::BvNot: return "bvnot";
            case Op::BvNegate: return "bvneg";

            case Op::Eq: return "=";
            case Op::NE: return "!=";
            case Op::And: return "and";
            case Op::Or: return "or";
            case Op::Xor: return "xor";
            case Op::Implies: return "=>";

            case Op::Concat: return "concat";

            case Op::SExt: return "sext";
            case Op::ZExt: return "zext";
            case Op::ZFit: return "zfit";
            case Op::Trunc: return "trunc";
            case Op::FPExt: return "fpext";
            case Op::FPTrunc: return "fptrunc";
            case Op::FPToSInt: return "fptosint";
            case Op::FPToUInt: return "fptouint";
            case Op::SIntToFP: return "sinttofp";
            case Op::UIntToFP: return "uinttofp";

            case Op::BvAnd: return "bvand";
            case Op::BvOr: return "bvor";
            case Op::BvXor: return "bvxor";
            case Op::BvAdd: return "bvadd";
            case Op::BvSub: return "bvsub";
            case Op::BvMul: return "bvmul";
            case Op::BvUDiv: return "bvudiv";
            case Op::BvSDiv: return "bvsdiv";
            case Op::BvURem: return "bvurem";
            case Op::BvSRem: return "bvsrem";
            case Op::BvShl: return "bvshl";
            case Op::BvAShr: return "bvashr";
            case Op::BvLShr: return "bvlshr";

            case Op::Constraint: return "constraint";

            case Op::FpAdd:  return "fp.add";
            case Op::FpSub:  return "fp.sub";
            case Op::FpMul:  return "fp.mul";
            case Op::FpDiv:  return "fp.div";
            case Op::FpRem:  return "fp.rem";

            case Op::BvULE: return "bvule";
            case Op::BvULT: return "bvult";
            case Op::BvUGE: return "bvuge";
            case Op::BvUGT: return "bvugt";
            case Op::BvSLE: return "bvsle";
            case Op::BvSLT: return "bvslt";
            case Op::BvSGE: return "bvsge";
            case Op::BvSGT: return "bvsgt";

            case Op::FpFalse: return "fp.false";
            case Op::FpTrue: return "fp.true";
            case Op::FpOEQ: return "fp.eq";
            case Op::FpOGT: return "fp.gt";
            case Op::FpOGE: return "fp.geq";
            case Op::FpOLT: return "fp.lt";
            case Op::FpOLE: return "fp.leq";
            case Op::FpONE: return "distinct"; // TODO neq
            case Op::FpORD: return "fp.ord";
            case Op::FpUEQ: return "fp.eq";
            case Op::FpUGT: return "fp.gt";
            case Op::FpUGE: return "fp.geq";
            case Op::FpULT: return "fp.lt";
            case Op::FpULE: return "fp.leq";
            case Op::FpUNE: return "distinct"; // TODO neq
            case Op::FpUNO: return "fp.uno";

            case Op::Extract: return "extract";
            case Op::Call: return "call";

            default: UNREACHABLE( "missing case in name( Op )", int( op ) );
        }
    }

    template< typename S >
    auto operator<<( S &stream, Op op ) -> decltype( stream << name( op ) )
    {
        return stream << name( op );
    }

    template< typename T >
    inline uint8_t * bytes_begin( const T & v ) noexcept
    {
        return reinterpret_cast< uint8_t * >( const_cast< std::remove_cv_t< T * > >( &v ) );
    }

    template< typename T >
    inline uint8_t * bytes_end( const T & v ) noexcept
    {
        return reinterpret_cast< uint8_t * >( const_cast< std::remove_cv_t< T * > >( &v ) ) + sizeof( T );
    }

    namespace token
    {
        using VarID = uint16_t;

        struct Operation
        {
            Op op;

            template< typename stream >
            friend auto operator<<( stream &os, const Operation &operation ) -> decltype( os << "" )
            {
                return os << name( operation.op );
            }
        };

        struct UnaryOp : Operation {};
        struct BinaryOp : Operation {};

        struct Unary : UnaryOp
        {
            Bitwidth bw;
            Bitwidth from = 0;
            Bitwidth to = 0;
        };

        struct Binary : BinaryOp { Bitwidth bw; };
    }

    /* Holds bytecode (a sequence of bytes) in the underlying container
     * to encode operations and their operands in Reverse Polish Notation.
     * The bytecode is parsed by RPNView, RPN only builds/holds it.
     * RPN represents one term.

        Example:
           term a + 7
           RPN a 7 +
           container._data:
            |    bytes for var a     |   bytes for const 7   |  bytes for op +   |
            | 2 bytes op | 1 byte id |   bitwidth  |  value  | op  |   bitwidth  |
        When this is decoded, a helper stack is used and the bytecode is taken
        left-to-right to evaluate operands before they are used in an operation
         - decode and push a, decode and push 7, (+) pop 2 operands for
     */
    template< typename Container >
    struct RPN : Container
    {
        using Container::Container;
        using VarID = token::VarID;

        using size_type = typename Container::size_type;
        using value_type = typename Container::value_type;
        using reference = typename Container::reference;
        using const_reference = typename Container::const_reference;
        using iterator = typename Container::iterator;
        using const_iterator = typename Container::const_iterator;
        using difference_type = typename Container::difference_type;

        template< Op o = Op::Invalid >
        struct Token
        {
            Op op = o;

            template< typename stream >
            friend auto operator<<( stream &os, const Token &operation ) -> decltype( os << "" )
            {
                return os << name( operation.op );
            }

        } __attribute__(( packed, alinged(1) ));

        template< typename T >
        struct Constant : Token<>
        {
            T value;

            Type type() const { return Type::Int; }
            Bitwidth bitwidth() const { return -Bitwidth( this->op ); }

            template< typename stream >
            friend auto operator<<( stream &os, const Constant &con ) -> decltype( os << "" )
            {
                return os << "[const " << con.value
                          << " : "     << to_string( con.type() )
                          << " "       << int( con.bitwidth() ) << "]";
            }

        } __attribute__(( packed, aligned(1) ));

        static_assert( sizeof( Constant< bool > ) == 2 );
        static_assert( sizeof( Constant< uint8_t > ) == 2 );
        static_assert( sizeof( Constant< uint32_t > ) == 5 );

        struct Variable : Token<>
        {
            VarID id;

            Bitwidth bitwidth() const { return RPN::bitwidth( this->op ); }
            Type type() const { return RPN::type( this->op ); }

            template< typename stream >
            friend auto operator<<( stream &os, const Variable &var ) -> decltype( os << "" )
            {
                return os << "[var " << var.id
                          << " : "   << to_string( var.type() )
                          << " "     << int( var.bitwidth() ) << "]";
            }

            friend bool operator==( const Variable& v1, const Variable& v2 )
            {
                return v1.op == v2.op && v1.id == v2.id;
            }

        } __attribute__(( packed, aligned(1) ));

        static_assert( sizeof( Variable ) == 3 );

        struct CastOp : Token<>
        {
            Bitwidth bitwidth;

            template< typename stream >
            friend auto operator<<( stream &os, const CastOp &cast ) -> decltype( os << "" )
            {
                return os << "cast " << name( cast.op ) << " to " << std::to_string( cast.bitwidth ) ;
            }

        } __attribute__(( packed, aligned(1) ));

        static_assert( sizeof( CastOp ) == 2 );

        struct ExtractOp : Token<>
        {
            Bitwidth highest;
            Bitwidth lowest;

            template< typename stream >
            friend auto operator<<( stream &os, const ExtractOp &extract ) -> decltype( os << "" )
            {
                return os << "extract from " << std::to_string( extract.lowest )
                          << " to " << std::to_string( extract.highest );
            }

        } __attribute__(( packed, aligned(1) ));

        static_assert( sizeof( ExtractOp ) == 3 );

        struct Call : Token< Op::Call >
        {
            uint32_t objid;

            constexpr Call( uint32_t obj ) : objid( obj ) {}

            template< typename stream >
            friend auto operator<<( stream &os, const Call &c ) -> decltype( os << "" )
            {
                return os << name( c.op ) << " " << c.objid;
            }

        } __attribute__(( packed, aligned(1) ));

        static_assert( sizeof( Call ) == 5 );

        template< typename T >
        static inline constexpr Op ivar() noexcept
        {
            if constexpr ( std::is_same_v< T, bool > )
                return Op::VarBool;
            if constexpr ( sizeof( T ) == 1 )
                return Op::VarI8;
            if constexpr ( sizeof( T ) == 2 )
                return Op::VarI16;
            if constexpr ( sizeof( T ) == 4 )
                return Op::VarI32;
            if constexpr ( sizeof( T ) == 8 )
                return Op::VarI64;
        }

        template< typename T >
        static inline constexpr Op fpvar() noexcept
        {
            if constexpr ( sizeof( T ) == 4 )
                return Op::VarFloat;
            if constexpr ( sizeof( T ) == 8 )
                return Op::VarDouble;
        }

        template< typename T >
        static inline constexpr Op var() noexcept
        {
            if constexpr ( std::is_integral_v< T > )
                return ivar< T >();
            if constexpr ( std::is_floating_point_v< T > )
                return fpvar< T >();
        }

        // TODO operation instead of operand?
        static inline constexpr Op operand( const_iterator it ) noexcept
        {
            return static_cast< Op >( *it );
        }

        static inline constexpr Bitwidth bitwidth( Op op ) noexcept
        {
            if ( is_constant( op ) ) {
                return -static_cast< Bitwidth >( op );
            } else if ( is_variable( op ) ) {
                switch( op ) {
                    case Op::VarBool: return 1;
                    case Op::VarI8: return 8;
                    case Op::VarI16: return 16;
                    case Op::VarI32: return 32;
                    case Op::VarI64: return 64;
                    case Op::VarFloat: return 32;
                    case Op::VarDouble: return 64;
                    default:;
                }
            }

            UNREACHABLE( op, "is neither constant nor variable" );
        }

        static inline constexpr Type type( Op op ) noexcept
        {
            ASSERT( is_variable( op ) );
            switch( op ) {
                case Op::VarBool:
                    return Type::Bool;
                case Op::VarI8:
                case Op::VarI16:
                case Op::VarI32:
                case Op::VarI64:
                    return Type::Int;
                case Op::VarFloat:
                case Op::VarDouble:
                    return Type::Float;
                default:
                    UNREACHABLE( "unknown variable type", op );
            }
        }

        template< typename T >
        constexpr T extract( size_t from = 0 ) const noexcept
        {
            auto it = std::next( this->begin(), from );
            return *reinterpret_cast< const T * >( it );
        }

        constexpr VarID id() const noexcept
        {
            ASSERT( is_variable( operand() ) );
            constexpr auto offset = 1;
            return extract< VarID >( offset );
        }

        template< typename T >
        constexpr T extract_constant() const noexcept
        {
            assert( is_constant( operand() ) );
            constexpr auto offset = 1;
            return extract< T >( offset );
        }

        /* apply == append an operation to the underlying container */
        template< Op op >
        constexpr void apply() noexcept
        {
            this->push_back( static_cast< std::underlying_type_t< Op > >( op ) );
        }

        /* extend == append a container to the underlying container */
        template< typename Bytes >
        constexpr void extend( const Bytes& bytes ) noexcept
        {
            this->append( sizeof( bytes ), bytes_begin( bytes ), bytes_end( bytes ) );
        }

        constexpr void extend( const RPN& other ) noexcept
        {
            /* FIXME exclude the domain identification byte */
            this->append( other.size() - 1, std::next( other.begin() ), other.end() );
        }
    };

    /* Decoder of RPN bytecode, produces the SMT-LIB-specific textual
     * representation of the RPN . */
    template< typename RPN >
    struct RPNView
    {
        using Variable  = typename RPN::Variable;
        using Constant  = typename RPN::template Constant< uint64_t >;
        using CastOp    = typename RPN::CastOp;
        using CallOp    = typename RPN::Call;
        using ExtractOp = typename RPN::ExtractOp;
        using UnaryOp   = token::UnaryOp;
        using BinaryOp  = token::BinaryOp;

        RPNView( const RPN & rpn ) : _rpn( rpn ) {}

        using Token = std::variant< Variable, Constant, ExtractOp, CastOp, UnaryOp, BinaryOp, CallOp >;

        struct Iterator : brick::types::Eq
        {
            // TODO usings
            using rpn_iterator = typename RPN::const_iterator;

            Iterator( rpn_iterator it ) : _it( it ) {}
            Iterator() = default;

            auto operand() const noexcept { return RPN::operand( _it ); }

            auto bitwidth() const noexcept
            {
                auto o = operand();
                if ( is_constant( o ) || is_variable( o ) )
                    return RPN::bitwidth( operand() );
                UNREACHABLE( "unknown bitwidth" );
            }

            template< typename T >
            Constant extract_constant() const noexcept
            {
                ASSERT( is_constant( operand() ) );
                auto pos = &*_it;
                auto val = *reinterpret_cast< const T * >( pos + 1 );
                return Constant{ Op( *pos ), val };
            }

            Iterator& operator++() noexcept
            {
                if ( is_constant( operand() ) )
                {
                    auto byte = static_cast< Bitwidth >( 8 );
                    auto bw = std::max( byte, RPN::bitwidth( operand() ) );
                    std::advance( _it, 1 + bw / 8 );
                }
                else if ( is_variable( operand() ) )
                    std::advance( _it, sizeof( Variable ) );
                else if ( is_cast( operand() ) )
                    std::advance( _it, sizeof( CastOp ) );
                else if ( is_extract( operand() ) )
                    std::advance( _it, sizeof( ExtractOp ) );
                else if ( is_call( operand() ) )
                    std::advance( _it, sizeof( CallOp ) );
                else
                    std::advance( _it, sizeof( Op ) );

                return *this;
            }

            template< typename T >
            const T* reinterpret() const noexcept { return reinterpret_cast< const T * >( &(*_it) ); }

            Token operator*() const noexcept
            {
                auto op = operand();
                if ( is_constant( op ) )
                {
                    auto bw = bitwidth();
                    switch ( bw )
                    {
                        case  1: return extract_constant< bool >();
                        case  8: return extract_constant< uint8_t >();
                        case 16: return extract_constant< uint16_t >();
                        case 32: return extract_constant< uint32_t >();
                        case 64: return extract_constant< uint64_t >();
                        default:
                            UNREACHABLE( "unsupported constant bitwidth", bw );
                    }
                }

                if ( is_variable( op ) )
                {
                    auto ptr = reinterpret< Variable >();
                    return Variable{ op, ptr->id };
                }

                if ( is_cast( op ) )
                {
                    auto ptr = reinterpret< CastOp >();
                    return CastOp{ ptr->op, ptr->bitwidth };
                }

                if ( is_extract( op ) )
                {
                    auto ptr = reinterpret< ExtractOp >();
                    return ExtractOp{ ptr->op, ptr->highest, ptr->lowest };
                }

                if ( is_unary( op ) )
                    return UnaryOp{ { op } };

                if ( is_binary( op ) )
                    return BinaryOp{ { op } };

                if ( is_call( op ) )
                {
                    auto pos = &*_it;
                    auto val = *reinterpret_cast< const uint32_t * >( pos + 1 );
                    return CallOp{ val };
                }

                UNREACHABLE( "unknown RPN token", op );
            }

            bool operator==( const Iterator& other ) const noexcept
            {
                return _it == other._it;
            }

            rpn_iterator _it;
        };

        // skipping the first byte that identifies the abstract domain type
        Iterator begin() const noexcept { return Iterator{ std::next( _rpn.begin() ) }; }
        Iterator end() const noexcept { return Iterator{ _rpn.end() }; }

        friend brq::string_builder& operator<<( brq::string_builder& os, const RPNView& view )
        {
            for ( const auto & term : view ) {
                std::visit( [&]( const auto& val ) { os << val << " "; }, term );
            }

            return os;
        }

        const RPN & _rpn;
    };

    // TODO keeps getting copied about
    template<class... Ts> struct overload : Ts... { using Ts::operator()...; };
    template<class... Ts> overload(Ts...) -> overload<Ts...>;

    template < typename Container >
    struct union_find
    {
        using T = typename Container::key_type;
        static_assert( std::is_same_v< T, typename Container::mapped_type > );
        using MaybeT = std::optional< T >;

        Container grouping;
        bool updated = false; // was anything glued together at last union?
        void clear() { grouping.clear(); }

        T make_set( T x )
        {
            auto it = grouping.find( x );
            if ( it != grouping.end() )
                return it->second;
            grouping.insert( { x, x } );
            return x;
        }

        MaybeT find( T x )
        {
            auto it = grouping.find( x );
            if ( it != grouping.end() )
            {
                if ( it->second != x )
                    it->second = *find( it->second );
                return it->second;
            }
            return std::nullopt;
        }

        MaybeT union_( MaybeT x, MaybeT y )
        {
            updated = false;
            if ( !x ) return y;
            if ( !y ) return x;

            auto x_root = find( *x );
            auto y_root = find( *y );

            ASSERT( x_root && y_root );

            if ( x_root == y_root )
                return y_root;

            grouping.find( *x_root )->second = *y_root;
            updated = true;
            return y_root;
        }

        std::set< std::set< T > > get_partitions()
        {
            std::map< T, std::set< T > > parts;
            for( auto var : grouping )
            {
                auto it = parts.find( *find( var.second ) );
                if ( it != parts.end() )
                    it->second.insert( var.first );
                else
                    parts.insert( { *find( var.second ),
                                    std::set< T >( { var.first } ) } );
            }

            std::set< std::set< T > > partitions;
            for( auto part : parts )
                partitions.insert( part.second );
            return partitions;
        }
    };

    // decompose the input RPN into smaller RPNs
    // which have dependent variables, for later caching
    // returns the VarID of the last representant after union
    // TODO: output iterator
    template< template< typename > class stack_t, typename RPN, typename M,
              typename F = std::function< void ( smt::token::VarID ) > >
    std::optional< token::VarID > decompose( const RPN &rpn, union_find< M >& uf,
                                             F f = []( token::VarID ){} )
    {
        using RPNView = brick::smt::RPNView< RPN >;
        using VarID = token::VarID;
        using namespace token;

        using Constant = typename RPNView::Constant;
        using Variable = typename RPNView::Variable;

        stack_t< std::optional< VarID > > stack;
        std::optional< VarID > repr = std::nullopt;

        auto pop = [&]()
        {
            auto v = stack.back();
            stack.pop_back();
            return v;
        };

        auto handle_binary = [&] ( BinaryOp bin )
        {
            if ( bin.op == Op::Constraint )
                UNREACHABLE( "Op::Constraint in decompose()" );
            else
            {
                auto n1 = pop();
                auto n2 = pop();

                auto var1 = n1 ? uf.find( *n1 ) : std::nullopt;
                auto var2 = n2 ? uf.find( *n2 ) : std::nullopt;

                repr = uf.union_( n1, n2 );
                if ( uf.updated )
                {
                    if ( var1 ) f( *var1 );
                    if ( var2 ) f( *var2 );
                }
                stack.emplace_back( repr );
            }
        };

        for( auto term : RPNView( rpn ) )
        {
            if ( std::get_if< Constant >( &term ) )
                stack.emplace_back( std::nullopt );
            else if ( auto var = std::get_if< Variable >( &term ) )
                stack.emplace_back( uf.make_set( var->id ) );
            else if ( auto binop = std::get_if< BinaryOp >( &term ) )
                handle_binary( *binop );
        }

        return repr;
    }

    template< typename T >
    brq::string_builder& operator<<( brq::string_builder& os, const RPN< T >& rpn )
    {
        os << RPNView{ rpn } << "\n";
        return os;
    }
}

namespace brick::t_smt
{
    using namespace brick::smt;

    struct UnionFind
    {
        TEST( integer )
        {
            using namespace brick::smt;

            union_find< std::map< int, int > > uf;
            int even = uf.make_set( 0 ), odd = uf.make_set( 1 );
            for( int i : { 2, 4, 5, 7, 9, 6, 1, 0, -2, -9 } )
            {
                if ( i % 2 == 0 )
                {
                    uf.union_( even, uf.make_set( i ) );
                    ASSERT_EQ( *uf.find( uf.grouping.find( i )->second ) % 2, 0 );
                }
                else
                {
                    uf.union_( odd, uf.make_set( i ) );
                    ASSERT_EQ( abs( *uf.find( uf.grouping.find( i )->second ) % 2 ), 1 );
                }
            }
            auto parts = uf.get_partitions();
            assert( parts.size() == 2 );

            for( auto& part : parts )
                if( part.find( 0 ) != part.end() )
                    assert( part == std::set< int >( { 2, 4, 6, 0, -2 } ) );
                else
                    assert( part == std::set< int >( { 5, 7, 9, 1, -9 } ) );
        }
    };
}

// vim: syntax=cpp tabstop=4 shiftwidth=4 expandtab ft=cpp
