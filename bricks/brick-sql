// -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4 -*-

/*
 * Copyright (C) 2019 Petr Rockai <code@fixp.eu>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#pragma once
#include "brick-assert"
#include "brick-sqldata"
#include "brick-sqlexec"

namespace brq::sql
{
    struct txn;

    template< bool bind = true, typename stream, typename V >
    static void print( stream &s, const V &v, int &id )
    {
        if constexpr ( is_set< V >::value )
        {
            int i = 0;
            if ( v.empty() )
                s << "( select null::" << sql_type< typename V::value_type >() << " where false";
            for ( const auto &e : v )
                s << ( i ++ ? ", " : "( " ), print( s, e, id );
            s << " )";
        }
        else if constexpr ( is_value< V > )
        {
            if ( id >= 0 )
                s << "$" << id++ << "::" << sql_type< V >();
            else
                s << "'" << v << "'::" << sql_type< V >();
        }
        else if constexpr ( std::is_same_v< V, std::nullopt_t > )
            s << "null";
        else if constexpr ( is_optional< V >::value )
        {
            if ( v.has_value() )
                return print( s, *v, id );
            else
                s << "null::" << sql_type< V >();
        }
        else if constexpr ( std::is_same_v< V, where_operator > )
            s << v.sql;
        else if constexpr ( brq::is_list_v< V > )
        {
            bool first = true;
            auto item = [&]( const auto &i )
            {
                s << ( first ? "" : ", " );
                print( s, i, id );
                first = false;
            };
            v.each( item );
            s << " ";
        }
        else if constexpr ( V::is_function )
            s << get_name( v ), v.print( s, id );
        else if constexpr ( V::is_column )
            s << v.column_name( v ) << "::" << sql_type< typename V::type >();
        else if constexpr ( V::is_query )
            s << "( ", v.print( s, id ), s << " )";
        else if constexpr ( V::is_enum )
            s << "'" << get_name( v ) << "'";
        else
            v.print( s, id );
    }

    template< typename stmt, typename V >
    static auto bind( stmt &s, const V &v )
    {
        if constexpr ( is_set< V >::value )
            for ( const auto &e : v )
                bind( s, e );
        else if constexpr ( is_value< V > ) s.bind( v ) ;
        else if constexpr ( is_optional< V >::value )
        {
            if ( v.has_value() )
                bind( s, *v );
        }
        else if constexpr ( std::is_same_v< V, where_operator > ) /* nothing */ ;
        else if constexpr ( is_list_v< V > ) /* nothing */ ;
        else if constexpr ( V::is_function ) v.bind( s ) ;
        else if constexpr ( V::is_column || V::is_enum ) /* nothing */ ;
        else
            v.bind( s );
    }

    struct row_number : constant< void, true > {};

    template< typename tab, typename col >
    struct in_table : col
    {
        using bare = col;
        using qualifier = tab;
        static constexpr bool is_qualified = true;

        template< typename CT >
        static std::string_view column_name( const CT & )
        {
            static auto name = "\"" + std::string( get_name( tab() ) ) +
                               "\"." + std::string( col().column_name( col() ) );
            return name;
        }
    };

    template< typename... cols >
    struct tuple
    {
        static constexpr bool is_column = false;
        static constexpr bool is_enum = false;
        static constexpr bool is_query = false;
        static constexpr bool is_function = false;
        static constexpr bool is_expr = true;
        static constexpr bool is_asc = true;

        brq::cons_list_t< cols... > _cols;
        tuple( cols... c ) : _cols( c... ) {}

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            s << "( "; sql::print( s, _cols, id ); s << " )";
        }

        template< typename stmt > void bind( stmt &s ) const
        {
            _cols.each( [&]( const auto &c ) { sql::bind( s, c ); } );
        }
    };

    template< typename col >
    struct excluded : col
    {
        template< typename CT >
        static std::string_view column_name( const CT & )
        {
            static auto name = "excluded." + std::string( col().column_name( col() ) );
            return name;
        }
    };

    template< typename type, typename... args >
    struct function : column< type >
    {
        static constexpr bool is_qualified = true;
        static constexpr bool is_function  = true;

        using args_t = brq::cons_list_t< args... >;
        using bare = typename args_t::car_t;
        args_t _args;

        function( args... ts ) : _args( ts... ) {}
        function() = default;

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            s << "( ";
            sql::print( s, _args, id );
            s << " )";
            if constexpr ( !std::is_same_v< type, void > )
                s << "::" << sql_type< type >();
        }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            _args.each( [&]( auto &v ) { sql::bind( s, v ); } );
        }
    };

    template< typename... cols >
    using endomorphism = function< typename cons_list_t< cols... >::car_t::type, cols... >;

    template< typename col > struct count : function< int32_t, col >
    {
        explicit count( const col &c = col() ) : function< int32_t, col >( c ) {}
    };

#define BRICK_SQL_ENDO(n) \
    template< typename... cols > struct n : endomorphism< cols... > \
    { explicit n( cols... cs ) : endomorphism< cols... >( cs... ) {} n() = default; }

    BRICK_SQL_ENDO( min );
    BRICK_SQL_ENDO( max );
    BRICK_SQL_ENDO( sum );
    BRICK_SQL_ENDO( greatest );
    BRICK_SQL_ENDO( least );
    BRICK_SQL_ENDO( distinct );
    BRICK_SQL_ENDO( every );

#undef BRICK_SQL_ENDO

    template< typename col, typename type > struct cast_to : function< type, col >
    {
        static constexpr const bool is_query = true;
        static constexpr const bool is_column = false;
        static constexpr const bool is_function = false;
        using function< type, col >::function;

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            s << "(";
            sql::print( s, this->_args, id );
            s << ")::" << sql_type< type >();
        }
    };

    template< typename col > struct cast
    {
        col _col;
        cast( const col &c ) : _col( c ) {}

        template< typename T >
        cast_to< col, T > to() { return { _col }; }
    };

    template< typename... cols >
    struct coalesce : endomorphism< cols... >
    {
        coalesce( const cols & ... v ) : endomorphism< cols... >( v... ) {}
    };

    template< typename col >
    struct substring : endomorphism< col >
    {
        std::string _pat;

        substring( const col &c, std::string_view p ) : endomorphism< col >( c ), _pat( p ) {}

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            s << "( ";
            sql::print( s, this->_args, id );
            s << " from '" << _pat << "' )::" << sql_type< typename col::type >();
        }
    };

    struct txn;

    template< typename... args >
    struct where_expr : column_flags
    {
        static constexpr bool is_expr = true;
        static constexpr bool is_asc  = true;

        using type = void; /* we don't know :( */

        cons_list_t< args... > _args;
        bool _parens = false;

        where_expr( args... as ) : _args( as... ) {}
        where_expr() = default;

        template< typename stream >
        stream &print( stream &s, int &id ) const
        {
            s << ( _parens ? "( " : "" );
            _args.each( [&]( auto v ) { sql::print( s, v, id ); s << " "; } );
            return s << ( _parens ? ")" : "" );
        }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            _args.each( [&]( auto &v ) { sql::bind( s, v ); } );
        }
    };

    template< typename T >
    auto set_nested( T &t, brq::primary_t ) -> decltype( t._parens )
    {
        return t._parens = true;
    }

    template< typename T >
    void set_nested( T &, brq::fallback ) {}

#define BRICK_SQL_OP_(op, sql)                                                                    \
    template< typename A, typename B >                                                            \
    auto op( A &&a, B &&b )                                                                       \
        -> std::enable_if_t< is_expr_v< std::decay_t< A > > || is_expr_v< std::decay_t< B > >,    \
                             where_expr< std::decay_t< A >, where_operator, std::decay_t< B > > > \
    {                                                                                             \
        set_nested( a, primary ); set_nested( b, primary );                                       \
        return { a, where_operator{ sql }, b };                                                   \
    }

#define BRICK_SQL_OP(op) BRICK_SQL_OP_(operator op, #op)

BRICK_SQL_OP_( operator ==, "=" )
BRICK_SQL_OP_( operator %=, "like" )
BRICK_SQL_OP_( operator &&, "and" )
BRICK_SQL_OP_( operator ||, "or" )
BRICK_SQL_OP_( operator ^, "#" )
BRICK_SQL_OP_( pow, "^" )
BRICK_SQL_OP_( in, "in" )

BRICK_SQL_OP( < )
BRICK_SQL_OP( > )
BRICK_SQL_OP( <= )
BRICK_SQL_OP( >= )
BRICK_SQL_OP( != )
BRICK_SQL_OP( + )
BRICK_SQL_OP( - )
BRICK_SQL_OP( * )
BRICK_SQL_OP( / )
BRICK_SQL_OP( % )
BRICK_SQL_OP( & )
BRICK_SQL_OP( | )

    template< typename F, typename P, typename O >
    auto over( F function, P partition, O order )
    {
        where_expr window{ where_operator( "partition by" ), partition,
                           where_operator( "order by" ), order };
        set_nested( window, primary );
        return where_expr{ function, where_operator( "over" ), window };
    }

#undef BRICK_SQL_OP

    template< typename A >
    auto is_null( A &&a ) -> std::enable_if_t< is_expr_v< std::decay_t< A > >,
                                               where_expr< std::decay_t< A >, where_operator > >
    {
        return { a, where_operator{ "is null" } };
    }

    template< typename A >
    auto desc( A &&a ) -> std::enable_if_t< is_expr_v< std::decay_t< A > >,
                                            where_expr< std::decay_t< A >, where_operator > >
    {
        return { a, where_operator{ "desc" } };
    }

    template< typename A >
    auto operator!( A &&a ) -> std::enable_if_t< is_expr_v< std::decay_t< A > >,
                                                 where_expr< where_operator, std::decay_t< A > > >
    {
        return { where_operator{ "not" }, a };
    }

    template< typename C, typename T, typename E >
    where_expr< where_operator, C, where_operator, T, where_operator, E, where_operator >
    when( C c, T t, E e )
    {
        return { "case", c, "when true then", t, "else", e, "end" };
    }

    struct query_base
    {
        static constexpr bool is_column = false;
        static constexpr bool is_query = true;
        static constexpr bool is_expr = true;
        static constexpr bool is_enum = false;
        static constexpr bool is_function = false;
        using type = void; /* we don't know :( */

        template< typename stmt, typename T >
        stmt _exec( T *t )
        {
            stmt s( t->conn(), *t );
            t->bind( s );
            s.exec();
            return s;
        }
    };

    template< typename q, typename col >
    constexpr bool has_column = q::stmt::columns::template has< col >;

    template< typename > struct raw_sql;

    template< typename query >
    struct extend : query_base
    {
        using stmt = typename query::stmt;
        query _query;
        sql::conn &conn() { return _query.conn(); }
        sql::txn &txn() { return _query.txn(); }
        extend( query q ) : _query( q ) {}

        void set_skip_select() { _query.set_skip_select(); }
        auto order_columns() const { return _query.order_columns(); }
        template< typename T > stmt _exec( T *t ) { return query_base::_exec< stmt >( t ); }

        template< typename stmt >
        void bind( stmt &s ) const { _query.bind( s ); }
    };

    template< typename select, typename... cols >
    struct group_by;

    template< typename query, typename... cols >
    struct order_clause : extend< query >
    {
        brq::cons_list_t< cols... > _cols;
        using extend< query >::extend;
        order_clause( query &q, cols... cs ) : extend< query >( q ), _cols( cs... ) {}

        template< typename cols_t >
        order_clause( query &q, cols_t cs ) : extend< query >( q ), _cols( cs ) {}

        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " order by ";
            auto l = this->order_columns().cat( _cols );
            int count = 0;
            auto print_one = [&]( auto &c )
            {
                s << ( count++ ? ", " : "" );
                sql::print( s, c, id );
                if ( !c.is_asc )
                    s << " desc ";
            };
            l.each( print_one );
        }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            this->_query.bind( s );
            _cols.each( [&]( const auto &c ) { sql::bind( s, c ); } );
        }

        sql::raw_sql< order_clause > raw_sql( std::string_view sv ) { return { *this, sv }; }

        template< typename... ct, typename... et >
        order_clause< query, cols..., ct..., et... > order_by( et... ex )
        {
            return { this->_query, _cols.cat( brq::cons_list( ex... ) ) };
        }
    };

    template< typename query, typename expr >
    struct where_clause : extend< query >
    {
        expr _expr;
        const char *_clause;
        where_clause( query q, const expr &e, const char *c = "where" )
            : extend< query >( q ), _expr( e ), _clause( c )
        {}

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " " << _clause << " ";
            sql::print( s, _expr, id );
        }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            this->_query.bind( s );
            sql::bind( s, _expr );
        }

        template< typename... group_cols >
        group_by< where_clause, group_cols... > group_by() { return { *this }; }

        template< typename... ct, typename... et >
        order_clause< where_clause, ct..., et... > order_by( et... ex ) { return { *this, ex... }; }

        template< typename we_t >
        auto where( we_t we ) { return sql::where_clause( this->_query, _expr && we ); }

        auto exec() { return this->_exec( this ); }
    };

    template< typename select, typename... cols >
    struct group_by : extend< select >
    {
        using extend< select >::extend;
        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " group by ";
            print_columns( s, cons_list( cols()... ) );
        }

        template< typename we_t >
        where_clause< group_by, we_t > having( const we_t &we ) { return { *this, we, "having" }; }

        template< typename... ct, typename... et >
        order_clause< group_by, ct..., et... > order_by( et... ex ) { return { *this, ex... }; }
    };

    enum class join_type { inner, left, right };

    template< typename T >
    using underlying = std::conditional_t< T::is_view && T::columns::car_t::is_qualified &&
                                           T::columns::car_t::is_primary,
                                           typename T::columns::car_t::qualifier, T >;

    template< typename select, typename tab, typename on_t = brq::nil >
    struct select_join : extend< select >
    {
        join_type _type;
        on_t _join_on;

        using tables = brq::cons< tab, typename select::tables >;
        select_join( const select &s, join_type t = join_type::inner, on_t on = on_t() )
            : extend< select >( s ), _type( t ), _join_on( on )
        {}

        auto exec() { return this->_exec( this ); }

        template< typename stream, typename tabs_left = typename select::tables >
        void print( stream &s, int &id ) const
        {
            using tab_left = typename tabs_left::car_t;
            using tab_right = tab;

            using tab_left_u  = underlying< tab_left >;
            using tab_right_u = underlying< tab_right >;

            std::string foreign_column;
            std::string primary_column;

            auto find_foreign_left = [&]( auto t )
            {
                using col = unqualify< decltype( t ) >;
                if constexpr ( t.is_foreign )
                    if constexpr ( std::is_same_v< typename col::table, tab_left_u > )
                        foreign_column = col().column_name( col() );
            };

            auto find_foreign_right = [&]( auto t )
            {
                using col = unqualify< decltype( t ) >;
                if constexpr ( t.is_foreign )
                    if constexpr ( std::is_same_v< typename col::table, tab_right_u > )
                        foreign_column = col().column_name( col() );
            };

            auto find_primary = [&]( auto t )
            {
                if ( t.is_primary )
                {
                    if constexpr ( t.is_qualified )
                    {
                        using bare = typename decltype( t )::bare;
                        primary_column = bare().column_name( bare() );
                    }
                    else
                        primary_column = t.column_name( t );
                }
            };

            brq::string_builder cond;

            typename tab_right::columns().each( find_foreign_left );
            typename tab_left::columns().each( find_primary );

            if constexpr ( std::is_same_v< on_t, brq::nil > )
            {
                if ( !foreign_column.empty() && !primary_column.empty() )
                {
                    cond << "\"" << get_name( tab_right() ) << "\"." << foreign_column
                         << " = \"" << get_name( tab_left() ) << "\"." << primary_column;
                }
                else
                {
                    primary_column = foreign_column = "";
                    typename tab_right::columns().each( find_primary );
                    typename tab_left::columns().each( find_foreign_right );

                    if ( !foreign_column.empty() && !primary_column.empty() )
                        cond << "\"" << get_name( tab_left() ) << "\"." << foreign_column
                             << " = \"" << get_name( tab_right() ) << "\"." << primary_column;
                    else if constexpr ( !tabs_left::cdr_t::empty )
                        return print< stream, typename tabs_left::cdr_t >( s, id );
                    else
                        brq::raise< error >() << "could not find join key on "
                                              << get_name( tab_left() ) << " x "
                                              << get_name( tab_right() );
                }
            }

            this->_query.print( s, id );

            switch ( _type )
            {
                case join_type::inner: s << " inner"; break;
                case join_type::left: s << " left"; break;
                case join_type::right: s << " right"; break;
            }

            s << " join \"" << get_name( tab_right() ) << "\" on ";
            if constexpr ( std::is_same_v< on_t, brq::nil > )
                s << cond.buffer();
            else
                sql::print( s, _join_on, id );
        }

        template< typename expr_t >
        select_join< select, tab, expr_t > on( expr_t e ) { return { this->_query, _type, e }; }

        template< typename we_t >
        where_clause< select_join, we_t > where( const we_t &we ) { return { *this, we }; }

        template< typename table >
        select_join< select_join, table > join() const { return { *this }; }

        template< typename table >
        select_join< select_join, table > left_join() const { return { *this, join_type::left }; }

        template< typename table >
        select_join< select_join, table > right_join() const { return { *this, join_type::right }; }

        template< typename... group_cols >
        group_by< select_join, group_cols... > group_by() { return { *this }; }

        template< typename... ct, typename... et >
        order_clause< select_join, ct..., et... > order_by( et... ex ) { return { *this, ex... }; }

        sql::raw_sql< select_join > raw_sql( std::string_view sv ) { return { *this, sv }; }
    };

    template< typename query >
    struct raw_sql : extend< query >
    {
        raw_sql( const query &q, std::string_view sv ) : extend< query >( q ), _sql( sv ) {}
        std::string _sql;
        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " " << _sql;
        }

        template< typename table >
        select_join< raw_sql, table > join() const { return { *this }; }

        template< typename table >
        select_join< raw_sql, table > left_join() const { return { *this, join_type::left }; }

        template< typename table >
        select_join< raw_sql, table > right_join() const { return { *this, join_type::right }; }

        template< typename... group_cols >
        group_by< raw_sql, group_cols... > group_by() { return { *this }; }

        template< typename we_t >
        where_clause< raw_sql, we_t > where( const we_t &we ) { return { *this, we }; }

        template< typename... ct, typename... et >
        order_clause< raw_sql, ct..., et... > order_by( et... ex ) { return { *this, ex... }; }
    };

    template< typename head > auto sql_join( const head &q ) { return q; }

    template< typename join, typename... joins, typename head >
    auto sql_join( const head &q )
    {
        return sql_join< joins... >( q.template join< join >() );
    }

    template< typename select, typename tab >
    struct select_tab : extend< select >
    {
        using tables = brq::cons_list_t< tab >;
        using extend< select >::extend;
        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " from \"" << get_name( tab() ) << "\"";
        }

        template< typename table, typename... joins >
        auto join() const { return sql_join< joins... >( select_join< select_tab, table >( *this ) ); }

        template< typename table >
        select_join< select_tab, table > left_join() const { return { *this, join_type::left }; }

        template< typename table >
        select_join< select_tab, table > right_join() const { return { *this, join_type::right }; }

        template< typename... group_cols >
        sql::group_by< select_tab, group_cols... > group_by() { return { *this }; }

        template< typename we_t >
        where_clause< select_tab, we_t > where( const we_t &we ) { return { *this, we }; }

        template< typename... ct, typename... et >
        order_clause< select_tab, ct..., et... > order_by( et... ex ) { return { *this, ex... }; }

        sql::raw_sql< select_tab > raw_sql( std::string_view sv ) { return { *this, sv }; }
    };

    template< typename... > struct select;

    template< typename select, typename... views >
    struct select_with : extend< select >
    {
        brq::cons_list_t< views... > _views;
        using extend< select >::extend;
        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            int i = 0;
            auto fmt = [&]( auto v )
            {
                using view = decltype( v );
                s << ( i++ ? ", \"" : "with recursive \"" );
                s << get_name( v ) << "\" ";
                print_columns( s, typename view::columns::template map_t< unqualify >(), "( ", " )" );
                s << " as ( ";
                v.construct().print( s, id );
                s << " )";
            };
            _views.each( fmt );
            this->_query.print( s, id );
        }

        template< typename table, typename... joins >
        auto from() { return sql_join< joins... >( select_tab< select_with, table >( *this ) ); }
    };

    template< typename... views, typename query > auto with( query q )
    {
        return select_with< query, views... >( q );
    };

    template< typename select, typename... cols >
    struct select_distinct : extend< select >
    {
        brq::cons_list_t< cols... > _cols;
        auto order_columns() const { return _cols; }
        using extend< select >::extend;
        auto exec() { return this->_exec( this ); }

        template< typename... et >
        select_distinct( const select &q, et... e ) : extend< select >( q ), _cols( e... ) {}

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            s << "select distinct ";
            if constexpr ( sizeof...( cols ) > 0 )
                s << " on ( ", sql::print( s, _cols, id ), s << " ) ";
            this->_query.print( s, id );
        }

        template< typename table, typename... joins >
        auto from() { return sql_join< joins... >( select_tab< select_distinct, table >( *this ) ); }

        template< typename... ct, typename... et >
        select_with< select_distinct, ct..., et... > with( et... e ) { return { *this, e... }; }
    };

    template< typename... cols >
    struct query_head : query_base
    {
        using stmt = sql::stmt< cols... >;
        sql::txn *_txn;
        sql::txn &txn() { return *_txn; }
        conn &conn();

        query_head( sql::txn &t ) : _txn( &t ) {}
        query_head() : _txn( nullptr ) {}

        brq::nil order_columns() const { return {}; }

        template< typename stmt >
        void bind( stmt & ) const {}
    };

    template< typename... cols >
    struct select : query_head< cols... >
    {
        brq::cons_list_t< cols... > _cols;
        bool _skip_select = false;

        using query_head< cols... >::query_head;
        select( sql::txn &t, cols... e ) : query_head< cols... >( t ), _cols( e... ) {}
        select( cols... e ) : _cols( e... ) {}
        select( brq::cons_list_t< cols... > cs ) : _cols( cs ) {}

        template< typename... ct, typename... et >
        select< cols..., ct..., et... > columns( et... e )
        {
            return { this->_txn, _cols.cat( brq::cons_list( e... ) ) };
        }

        template< typename table, typename... joins >
        auto from() { return sql_join< joins... >( select_tab< select, table >( *this ) ); }

        template< typename we_t >
        where_clause< select, we_t > where( const we_t &we ) { return { *this, we }; }

        template< typename... ct, typename... et >
        select_distinct< select, ct..., et... > distinct( et... e )
        {
            auto s = *this;
            s._skip_select = true;
            return { s, e... };
        }

        template< typename... ct, typename... et >
        select_with< select, ct..., et... > with( et... e )
        {
            return { *this, e... };
        }

        void set_skip_select() { _skip_select = true; }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            if ( !_skip_select )
                s << "select ";
            sql::print( s, _cols, id );
        }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            _cols.each( [&]( const auto &c ) { sql::bind( s, c ); } );
        }

        using typename query_head< cols... >::stmt;
        stmt exec() { return query_base::_exec< stmt >( this ); }
        sql::raw_sql< select > raw_sql( std::string_view sv ) { return { *this, sv }; }
    };

    template< typename T > constexpr bool is_str_v = std::is_same_v< T, const std::string & >;
    template< typename T > constexpr bool is_u32s_v = std::is_same_v< T, const std::u32string & >;
    template< bool C, typename A, typename B > using cond_t = std::conditional_t< C, A, B >;
    template< typename T > using to_u32v = cond_t< is_u32s_v< T >, std::u32string_view, T >;
    template< typename T > using to_view = cond_t< is_str_v< T >, std::string_view, to_u32v< T > >;

    template< typename insert, bool first, typename col, typename et >
    struct insert_update_set : extend< insert >
    {
        et _expr;

        insert_update_set( insert i, et e ) : extend< insert >( i ), _expr( e ) {}

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            if constexpr ( !first )
                s << ", ";
            s << col().column_name( col() );
            s << " = ";
            sql::print( s, _expr, id );
        }

        auto exec() { return this->_exec( this ); }
        template< typename stmt >
        void bind( stmt &s ) const
        {
            this->_query.bind( s );
            sql::bind( s, _expr );
        }

        template< typename col2, typename et2 >
        auto set( et2 e )
        {
            return insert_update_set< insert_update_set, false, col2, et2 >( *this, e );
        }
    };

    template< typename insert >
    struct insert_update : extend< insert >
    {
        using extend< insert >::extend;

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << "update set ";
        }

        template< typename cols, typename et >
        auto set( et e )
        {
            return insert_update_set< insert_update, true, cols, et >( *this, e );
        }
    };

    template< typename insert, typename... cols >
    struct conflict_clause : extend< insert >
    {
        using extend< insert >::extend;

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query._query._returning = false;
            this->_query.print( s, id );
            s << " on conflict ( ";
            print_columns( s, cons_list( cols()... ) );
            s << " ) do ";
        }
        insert_update< conflict_clause > update() { return { *this }; }
    };

    template< typename insert, typename... cols >
    struct insert_values : extend< insert >
    {
        using vals = brq::cons_list_t< typename cols::type... >;
        vals _vals;

        insert_values( insert i, typename cols::type... v )
            : extend< insert >( i ), _vals( std::move( v )... )
        {}

        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            s << "insert into \"" << get_name( typename insert::table() ) << "\"";
            cons_list_t< cols... > l;
            print_columns( s, l, "( ", " )" );
            s << " values";
            bool first = true;
            l.each( [&]( auto ) { s << ( first ? " ( " : ", " ) << "$" << id; id ++; first = false; } );
            s << " )";

            if ( this->_query._quiet )
                s << " on conflict do nothing";
            if constexpr ( !std::is_same_v< typename insert::primary_l, brq::nil > )
            {
                using primary = unqualify< typename insert::primary_l::car_t >;
                if ( this->_query._returning )
                    s << " returning " << primary().column_name( primary() );
            }
        }

        template< typename... ccols >
        conflict_clause< insert_values, ccols... > on_conflict() { return { *this }; }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            s.bind_list( _vals );
        }
    };

    template< typename tbl >
    struct insert
    {
        sql::conn *_conn = nullptr;
        mutable bool _quiet = false, _returning = true;

        using table = tbl;
        using primary_l = decltype( typename table::columns().template filter< is_primary >() );
        using stmt = std::conditional_t< std::is_same_v< primary_l, brq::nil >, sql::stmt<>,
                                         sql::stmt< typename get_key< primary_l >::type > >;
        using order_columns = brq::nil;

        insert() = default;
        explicit insert( sql::conn &c ) : _conn( &c ) {}

        insert on_conflict_do_nothing() const
        {
            auto i = *this;
            i._quiet = true;
            return i;
        }

        sql::conn &conn() { return *_conn; }

        template< typename... cols >
        auto values( to_view< const typename cols::type & >... v ) const
        {
            return insert_values< insert, cols... >( *this, typename cols::type( v )... );
        }
    };

    template< typename update, typename... cols >
    struct update_set : extend< update >
    {
        auto exec() { return this->_exec( this ); }

        template< typename stmt >
        void bind( stmt &s ) const { this->_query.bind( s ); s.bind_list( _values ); }

        cons_list_t< typename cols::type... > _values;
        update_set( update u, const typename cols::type &... v )
            : extend< update >( u ), _values( v... )
        {}

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " set ";
            cons_list_t< cols... > list;
            auto fmt_update = [&]( auto col ) -> std::string
            {
                string_builder b;
                b << col.column_name( col ) << " = $" << id ++
                  << "::" << sql_type< typename decltype( col )::type >();
                return b.buffer();
            };
            print_list( s, list.map( fmt_update ) );
        }

        template< typename we_t >
        where_clause< update_set, we_t > where( const we_t &we ) { return { *this, we }; }
    };

    template< typename table >
    struct update : query_head<>
    {
        using query_head<>::query_head;

        template< typename stream >
        void print( stream &s, int & ) const
        {
            s << "update \"" << get_name( table() ) << "\"";
        }

        template< typename... cols >
        update_set< update, cols... > set( const typename cols::type &... v )
        {
            return { *this, v... };
        }
    };

    template< typename table >
    struct delete_from : query_head<>
    {
        using query_head<>::query_head;
        stmt exec() { return std::move( stmt( this->conn(), *this ).exec() ); }

        template< typename stream >
        void print( stream &s, int & ) const
        {
            s << "delete from \"" << get_name( table() ) << "\"";
        }

        template< typename we_t >
        where_clause< delete_from, we_t > where( const we_t &we ) { return { *this, we }; }
    };

    template< typename q_t, typename... qs_t >
    struct select_union : query_head<>
    {
        cons_list_t< q_t, qs_t... > qs;
        bool all = false;

        select_union( q_t q, qs_t... qs ) : query_head( q.txn() ), qs( q, qs... ) {}
        select_union( bool a, q_t q, qs_t... qs ) : select_union( q, qs... ) { all = a; }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            bool first = true;
            auto one = [&]( const auto &q )
            {
                if ( !first ) s << " union " << ( all ? "all " : "" );
                q.print( s, id );
                first = false;
            };
            qs.each( one );
        }
    };

    template< typename stream, typename query >
    inline auto operator<<( stream &s, const query &st )
        -> std::enable_if_t< query::is_query, decltype( s << std::string() ) >
    {
        int id = 1;
        st.print( s, id );
        return s;
    }

    struct txn : txn_base
    {
        using txn_base::txn_base;

        template< typename... ct, typename... et >
        sql::select< ct..., et... > select( et... e ) { open(); return { *this, ct()..., e... }; }

        template< typename... args >
        sql::select< args... > select( cons_list_t< args... > ) { open(); return { *this }; }

        template< typename table >
        insert< table > insert_into() { open(); return insert< table >{ _conn }; }

        template< typename table >
        update< table > update() { open(); return { *this }; }

        template< typename table >
        delete_from< table > delete_from() { open(); return { *this }; }
    };

    template< typename... Ts >
    inline conn &query_head< Ts... >::conn() { return _txn->conn(); }
}
