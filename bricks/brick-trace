// -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4 -*-

/*
 * Macros for run-time-configurable debug tracing.
 */

/*
 * (c) 2019 Petr Roƒçkai <code@fixp.eu>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef BRICK_TRACE_H
#define BRICK_TRACE_H

#include <string_view>
#include <sstream>
#include <string>

#ifdef __divine__
#include <sys/cdefs.h>
#include <sys/trace.h>
#else
#include <iostream>
#include <unordered_set>
#include <cstring>
#define __debugfn
#define __boring
#endif

#ifdef NDEBUG

#define TRACE(...) static_cast< decltype(__VA_ARGS__, void(0)) >(0)

#else

#define TRACE(...) ::brick::trace::trace_fn( BRICK_LOCATION( "" ), __VA_ARGS__ )

#endif

namespace brick::trace
{
    struct Location
    {
        int line;
        const char *_file, *_statement;

        std::string short_info() const
        {
            std::stringstream str;
            str << filename() << ':' << line;
            return str.str();
        }

        std::string_view filename() const
        {
            std::string_view r( _file );
            r = r.substr( r.find( '/' ) == r.npos ? 0 : r.rfind( '/' ) + 1 );
            return r;
        }

        std::string file() const
        {
            std::string r( _file );
            int slashes = 0;
            for ( int i = 0; i < int( r.size() ); ++i )
                if ( r[i] == '/' )
                    ++ slashes;

            while ( slashes >= 3 )
            {
                r = r.substr( r.find( "/" ) + 1 );
                -- slashes;
            }

            if ( _file != r )
                r = ".../" + r;
            return r;
        }

        const char *statement() const
        {
            return _statement;
        }

    };

    template< typename stream, typename T >
    static constexpr auto can_format( int ) noexcept
        -> decltype( std::declval< stream & >() << std::declval< T >(), true )
    {
        return true;
    }

    template< typename stream, typename T >
    static constexpr bool can_format( short ) noexcept
    {
        return false;
    }

    template< typename stream, typename T >
    static constexpr bool can_format() noexcept
    {
        return can_format< stream, T >( 0 );
    }

    struct fallback
    {
        template< typename T >
        fallback( const T & ) {}
    };

    template< typename stream, typename T >
    auto format( stream &acc, const T &t ) noexcept
        -> std::enable_if_t< can_format< stream, T >() >
    {
        acc << t;
    }

    template< typename stream, typename F >
    auto format( stream &acc, const F &f ) noexcept
        -> std::enable_if_t< std::is_invocable_v< F, stream & > && !can_format< stream, F >() >
    {
        f( acc );
    }

    template< typename stream >
    void format( stream &acc, fallback ) noexcept
    {
        acc << "<unknown>";
    }

    template< typename stream >
    void format_args( stream & ) noexcept {}

    template< typename stream, typename A, typename... Args >
    void format_args( stream &acc, const A &a, const Args & ... as ) noexcept
    {
        format( acc, a );
        acc << " ";
        format_args( acc, as... );
    }

#ifdef __divine__
    static bool enabled( const Location & ) { return true; }
#else
    using Set = std::unordered_set< std::string_view >;

    static inline Set init( const char *str_ )
    {
        if ( !str_ )
            return Set();

        std::string_view str( str_ );
        Set i;
        while ( !str.empty() )
        {
            auto s = str.find( ',' );
            i.insert( str.substr( 0, s ) );
            if ( s == str.npos )
                return i;
            str = str.substr( s + 1 );
        }
        return i;
    }

    static bool enabled( const Location &l )
    {
        static Set yes = init( getenv( "BRICK_TRACE" ) ), no = init( getenv( "BRICK_NOTRACE" ) );
        static bool all = getenv( "BRICK_TRACE" ) && !strcmp( getenv( "BRICK_TRACE" ), "all" );
        return ( all || yes.count( l.filename() ) || yes.count( l.short_info() ) ) &&
               !no.count( l.filename() ) && !no.count( l.short_info() );
    }
#endif

    template< typename... Args >
    __debugfn void trace_fn( brick::trace::Location l, const Args &... args ) noexcept
    {
        if ( !enabled( l ) )
            return;
        std::stringstream acc;
        acc << l.short_info() << ": ";
#ifndef __divine__
        acc << "[" << pthread_self() << "] ";
#endif
        format_args( acc, args... );

#ifdef __divine__
        std::string x = acc.str();
        __dios_trace_internal( 0, "%s", x.c_str() );
#else
        acc << "\n";
        std::cerr << acc.str() << std::flush;
#endif
    }
}

#endif

// vim: syntax=cpp tabstop=4 shiftwidth=4 expandtab
