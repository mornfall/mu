// -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4 -*-

/*
 * Utilities for printing SMT-LIBv2 formulas
 */

/*
 * (c) 2017 Vladimír Štill <xstill@fi.muni.cz>
 * (c) 2018 Petr Ročkai <code@fixp.eu>
 */

/* Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE. */

#include <brick-assert>
#include <brick-string>
#include <brick-data>

#include <memory>
#include <iostream>
#include <sstream>
#include <functional>
#include <unordered_map>
#include <unordered_set>

#if _LIBCPP_VERSION >= 4000 || __GLIBCXX__ >= 20170630
#include <string_view>
#else
#include <experimental/string_view>
namespace std { using experimental::string_view; }
#endif

namespace brick {
namespace smt {

using Format = std::function< void ( std::ostream & ) >;
struct Context;

enum class Op
{
    FirstUnary,
    Not = FirstUnary,
    BvNot,
    BvNegate,
    LastUnary = BvNegate,

    FirstBinary,
    Eq = FirstBinary,
    And,
    Or,
    Xor,
    Implies,

    Concat,

    BvAnd,
    BvOr,
    BvXor,
    BvAdd,
    BvSub,
    BvMul,
    BvUDiv,
    BvSDiv,
    BvURem,
    BvSRem,
    BvShl,
    BvLShr,
    BvAShr,

    BvULE,
    BvULT,
    BvUGE,
    BvUGT,
    BvSLE,
    BvSLT,
    BvSGE,
    BvSGT,
    LastBinary = BvSGT,

    Extract,
};

inline std::string_view name( Op op )
{
    switch ( op )
    {
        case Op::Not: return "not";
        case Op::BvNot: return "bvnot";
        case Op::BvNegate: return "bvneg";

        case Op::Eq: return "=";
        case Op::And: return "and";
        case Op::Or: return "or";
        case Op::Xor: return "xor";
        case Op::Implies: return "=>";

        case Op::Concat: return "concat";

        case Op::BvAnd: return "bvand";
        case Op::BvOr: return "bvor";
        case Op::BvXor: return "bvxor";
        case Op::BvAdd: return "bvadd";
        case Op::BvSub: return "bvsub";
        case Op::BvMul: return "bvmul";
        case Op::BvUDiv: return "bvudiv";
        case Op::BvSDiv: return "bvsdiv";
        case Op::BvURem: return "bvurem";
        case Op::BvSRem: return "bvsrem";
        case Op::BvShl: return "bvshl";
        case Op::BvAShr: return "bvashr";
        case Op::BvLShr: return "bvlshr";

        case Op::BvULE: return "bvule";
        case Op::BvULT: return "bvult";
        case Op::BvUGE: return "bvuge";
        case Op::BvUGT: return "bvugt";
        case Op::BvSLE: return "bvsle";
        case Op::BvSLT: return "bvslt";
        case Op::BvSGE: return "bvsge";
        case Op::BvSGT: return "bvsgt";

        case Op::Extract: return "extract";
//        default: UNREACHABLE_F( "unknown operation %d", int( op ) );
    }
}

struct Node
{
    Format _fmt;
    int bw = 0;

    Node( int bw, Format &&fmt ) : _fmt( std::move( fmt ) ), bw( bw ) {}
    Node( int bw, std::string str ) : _fmt( [=]( std::ostream &o ) { o << str; } ), bw( bw ) {}
};

static inline std::ostream &operator<<( std::ostream &o, const Node &n )
{
    n._fmt( o );
    return o;
}

inline std::string to_string( const Node &p )
{
    std::stringstream ss;
    ss << p;
    return ss.str();
}

struct Context
{
    std::unordered_set< std::string > def_set;
    std::vector< std::pair< std::string, Node > > defs;
    std::unordered_map< std::string, Node > vars;

    void clear() { def_set.clear(); defs.clear(); vars.clear(); }

    Node define( std::string name, Node def )
    {
        ASSERT( !name.empty() );
        ASSERT( !def_set.count( name ) );
        def_set.insert( name );
        defs.emplace_back( name, def );
        return Node( def.bw, name );
    }

    Node variable( int bw, std::string name )
    {
        return variable( bitvecT( bw ), name );
    }

    Node variable( Node type, std::string name )
    {
        if ( vars.count( name ) )
            ASSERT_EQ( to_string( type ), to_string( vars.find( name )->second ) );
        else
            vars.emplace( name, type );
        return Node( type.bw, name );
    }

    Node symbol( int bw, std::string name ) { return Node( bw, name ); }
    Node bitvec( int, data::SmallVector< uint64_t > data );
    Node boolT() { return Node( 1, "Bool" ); }
    Node bitvecT( int bitwidth )
    {
        ASSERT_LEQ( 0, bitwidth );
        return Node( bitwidth, "(_ BitVec " + std::to_string( bitwidth ) + ")" );
    }

    Node bitvec( int bw, uint64_t val )
    {
        return bitvec( bw, brick::data::SmallVector< uint64_t >{ val } );
    }

    template< typename Int, typename =
            std::enable_if_t< std::is_integral< Int >::value && (sizeof( Int ) <= sizeof( uint64_t )) > >
    Node bitvec( Int i )
    {
        return bitvec( sizeof( Int ) * 8, data::SmallVector< uint64_t >{ uint64_t( i ) } );
    }

    void print( std::ostream &o, Node n, bool exq = true )
    {
        auto bind = [&]( std::string type, auto &vec, auto next )
        {
            for ( auto s : vec )
                o << std::endl << "    (" << type << " ((" << s.first << " " << s.second << ")) ";
            next();
            for ( unsigned i = 0; i < vec.size(); ++i )
                o << ")";
        };

        auto let = [&]{ bind( "let", defs, [&]{ o << n; } ); };
        if ( exq )
            bind( "exists", vars, let );
        else
            let();
    }

    void query( std::ostream &o, Node n )
    {
        for ( auto v : vars )
            o << "(declare-fun " << v.first << " () " << v.second << ")" << std::endl;
        o << "(assert ";
        print( o, n, false );
        o << ")" << std::endl << "(check-sat)";
    }

    std::string print( Node n, bool exq = true )
    {
        std::stringstream s;
        print( s, n, exq );
        return s.str();
    }

    std::string query( Node n )
    {
        std::stringstream s;
        query( s, n );
        return s.str();
    }

    using Vector = brick::data::SmallVector< Node, 2 >;

    Node expr( int bw, Op op, const Vector &args )
    {
        auto fmt = [=]( std::ostream &o )
        {
            o << "(" << name( op );
            for ( auto &a : args )
                o << " " << a;
            o << ")";
        };
        return Node( bw, fmt );
    }

    template< Op op >
    Node unop( int bw, Node arg )
    {
        static_assert( op >= Op::FirstUnary && op <= Op::LastUnary, "op is not an unary operation" );
        return expr( bw, op, { arg } );
    }

    template< Op op >
    Node binop( int bw, Node a, Node b )
    {
        static_assert( op >= Op::FirstBinary && op <= Op::LastBinary, "op is not a binary operation" );
        return expr( bw, op, { a, b } );
    }

    Node extract( int highest, int lowest, Node arg )
    {
        ASSERT_LEQ( lowest, highest );
        auto f = [=]( std::ostream &o )
        {
            o << "((_ extract " << std::dec << highest << " " << lowest << ") " << arg << ")";
        };
        return Node( 1 + highest - lowest, f );
    };

    Node ite( Node cond, Node t, Node f )
    {
        ASSERT_EQ( t.bw, f.bw );
        auto fmt = [=]( std::ostream &o ) { o << "(ite " << cond << " " << t << " " << f << ")"; };
        return Node( t.bw, fmt );
    }
};

inline static uint64_t u64mask( int bitwidth )
{
    if ( bitwidth >= 64 )
        return ~uint64_t( 0 );
    return (uint64_t( 1 ) << bitwidth) - 1;
}

inline Node Context::bitvec( int bitwidth, brick::data::SmallVector< uint64_t > data )
{
    int bw = bitwidth;
    int i = 0;

    while ( bw > 0 && i < int( data.size() ) )
    {
        data[ i ] &= u64mask( bw );
        bw -= 64;
        ++i;
    }

    while ( i < int( data.size() ) )
        data.pop_back();
    while ( int( data.size() ) < (bitwidth + 63) / 64 )
        data.push_back( 0 );

    std::stringstream o;

    if ( bitwidth % 4 == 0 )
    {
        o << "#x" << std::hex;
        // data are little endian
        for ( int i = data.size() - 1; i >= 0; --i )
            o << std::setfill( '0' ) << std::setw( std::min( bitwidth - i * 64, 64 ) / 4 ) << data[i];
    }
    else
    {
        o << "#b";
        for ( int i = data.size() - 1; i >= 0; --i ) {
            for ( int j = std::min( bitwidth - 1 - i * 64, 63 ); j >= 0; --j )
                if ( data[i] & (uint64_t( 1 ) << j) )
                    o << '1';
                else
                    o << '0';
        }
    }

    return Node( bitwidth, o.str() );
}

} // namespace smt

namespace t_smt {
using namespace brick::smt;

/*
struct StringTest
{
    TEST(basic)
    {
        ASSERT_EQ( R"("a")", to_string( smt::string( "a" ) ) );
        std::string b( "b" );
        ASSERT_EQ( R"("b")", to_string( smt::string( b ) ) );
    }

    TEST(escape)
    {
        ASSERT_EQ( R"("a\\b\"c")", to_string( smt::string( R"(a\b"c)" ) ) );
        ASSERT_EQ( R"("a\\\"c")", to_string( smt::string( R"(a\"c)" ) ) );
    }
};
*/

struct BVecTest
{
    TEST(string)
    {
        Context ctx;

        auto a = ctx.bitvec( 42 );
        ASSERT_EQ( "#x0000002a", to_string( a ) );

        auto b = ctx.bitvec( uint64_t( 42 ) );
        ASSERT_EQ( "#x000000000000002a", to_string( b ) );

        auto c = ctx.bitvec( 4, 0xff );
        ASSERT_EQ( "#xf", to_string( c ) );

        brick::data::SmallVector< uint64_t > data = { ~uint64_t( 0 ), ~uint64_t( 0 ) };
        auto d = ctx.bitvec( 96, data );
        ASSERT_EQ( "#x" + std::string( 24, 'f' ), to_string( d ) );

        auto e = ctx.bitvec( 256, data );
        ASSERT_EQ( "#x" + std::string( 32, '0' ) + std::string( 32, 'f' ), to_string( e ) );

        auto f = ctx.bitvec( 96, 42 );
        ASSERT_EQ( "#x" + std::string( 22, '0' ) + "2a", to_string( f ) );

        auto g = ctx.bitvec( 16, data );
        ASSERT_EQ( "#xffff", to_string( g ) );

        auto h = ctx.bitvec( 7, data );
        ASSERT_EQ( "#b1111111", to_string( h ) );

        auto i = ctx.bitvec( 7, 0x29 );
        ASSERT_EQ( "#b0101001", to_string( i ) );

        auto j = ctx.bitvec( 67, { (uint64_t( 1 ) << 63) | 1, 0x5 } );
        ASSERT_EQ( "#b1011" + std::string( 62, '0' ) + "1", to_string( j ) );

        auto k = ctx.bitvec( 67, { (uint64_t( 1 ) << 33) | 1, 0x5 } );
        ASSERT_EQ( "#b101" + std::string( 30, '0' ) + "1" + std::string( 32, '0' ) + "1",
                   to_string( k ) );
    }
};

struct ExtractTest
{
    TEST(print)
    {
        Context ctx;

        ASSERT_EQ( "((_ extract 32 0) #x000000000000002a)",
                   to_string( ctx.extract( 32, 0, ctx.bitvec( 42ull ) ) ) );
        ASSERT_EQ( "((_ extract 15 15) (concat #xff #xff))",
                   to_string( ctx.extract( 15, 15,
                                           ctx.binop< Op::Concat >( 16,
                                                                    ctx.bitvec( 8, 0xff ),
                                                                    ctx.bitvec( 8, 0xff ) ) ) ) );
    }
};

struct CombinationTest
{
    TEST(simple)
    {
        Context ctx;

        ASSERT_EQ( to_string( ctx.binop< Op::BvAdd >( 32, ctx.bitvec( 42 ), ctx.bitvec( 32 ) ) ),
                   "(bvadd #x0000002a #x00000020)" );
        ASSERT_EQ( to_string( ctx.binop< Op::BvAnd >( 32, ctx.symbol( 32, "a" ), ctx.bitvec( 3, 5 ) ) ),
                   "(bvand a #b101)" );
        ASSERT_EQ( to_string(
                       ctx.binop< Op::BvSLE >(
                           16, ctx.extract( 32, 16, ctx.symbol( 32, "a" ) ),
                           ctx.unop< Op::BvNegate >( 16, ctx.bitvec( short( 42 ) ) ) ) ),
                   "(bvsle ((_ extract 32 16) a) (bvneg #x002a))" );
    }
/*
    TEST(constants)
    {
        ASSERT_EQ( to_string( defineFun( "a", bitvecT( 32 ), bitvec( 42 ) ) ),
                   "(define-fun a () (_ BitVec 32) #x0000002a)" );
        ASSERT_EQ( to_string( declareConst( "a", bitvecT( 32 ) ) ),
                   "(declare-const a (_ BitVec 32))" );
        ASSERT_EQ( to_string( defineFun( "b", bitvecT( 32 ),
                                  binop< Op::BvAnd >( 16, bitvec( short( 1 ) ),
                                                      bitvec( short( 2 ) ) ) ) ),
                   "(define-fun b () (_ BitVec 32) (bvand #x0001 #x0002))" );
    }
*/
};

} // namespace t_smt
} // namespace brick

// vim: syntax=cpp tabstop=4 shiftwidth=4 expandtab ft=cpp
