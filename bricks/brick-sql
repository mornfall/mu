// -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4 -*-

/*
 * Copyright (C) 2019 Petr Rockai <code@fixp.eu>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#pragma once
#include "brick-assert"
#include "brick-cons"

#include <unordered_map>
#include <vector>
#include <typeindex>
#include <cxxabi.h>

#include <sql.h>
#include <sqlext.h>

namespace brq::sql
{
    struct error : std::runtime_error
    {
        using std::runtime_error::runtime_error;
    };

    struct date { std::int16_t year, month, day; };
    struct time { std::int16_t hour, min, sec; };
    struct timestamp { std::int64_t year, month, day, hour, min, sec, fract; };

    static std::unordered_map< std::type_index, std::string_view > type_map
    {
        { typeid( int ),            "integer" },
        { typeid( long ),           "bigint" },
        { typeid( std::u32string ), "text" },
        { typeid( std::string ),    "bytea" },
        { typeid( date ),           "date" },
        { typeid( time ),           "time" },
        { typeid( timestamp ),      "timestamp" },
    };

    template< typename T >
    std::string_view get_name( T t )
    {
        static std::string name;
        if ( name.empty() )
        {
            int stat;
            char *dem = abi::__cxa_demangle( typeid( T ).name(), nullptr, nullptr, &stat );
            name = strchr( dem, ':' ) ? strrchr( dem, ':' ) + 1 : dem;
            TRACE( dem, "â†’", name );
            std::free( dem );
        }
        return name;
    }

    template< typename T, bool _nullable = false >
    struct column
    {
        template< typename CT >
        static std::string_view column_name( const CT &ct ) { return get_name( ct ); }

        using type = T;
        static constexpr bool nullable = _nullable;
        static constexpr bool primary = false;
        static constexpr bool foreign = false;
    };

    template< typename tab, typename col, bool _nullable = false >
    struct foreign_key : col
    {
        using column = col;
        using table = tab;
        static constexpr bool nullable = _nullable;
        static constexpr bool foreign = true;
    };

    template< typename col >
    struct primary_key
    {
        template< typename CT >
        static std::string_view column_name( const CT & ) { return get_name( col() ); }

        using type = typename col::type;
        static constexpr bool nullable = col::nullable;
        static constexpr bool primary = true;
        static constexpr bool foreign = false;
    };

    template< typename... cols >
    struct table
    {
        using columns = brq::cons_list_t< cols... >;
    };

    template< typename stream, typename table >
    auto operator<<( stream &s, table ) -> decltype( typename table::columns(), s << "" )
    {
        s << "create table " << get_name( table() );
        bool first = true;
        auto print_col = [&]( auto col )
        {
            using col_t = decltype( col );
            s << ( first ? "\n  ( " : "\n  , " ) << col.column_name( col );
            if ( col.primary )
                s << " serial primary key";
            else
                s << " " << brq::sql::type_map[ typeid( typename col_t::type ) ];
            if constexpr ( col.foreign )
                s << " references " << get_name( typename col_t::table() )
                  << "( " << typename col_t::column().column_name( typename col_t::column() ) << " )";
            if ( !col.nullable )
                s << " not null";
            first = false;
        };
        typename table::columns().each( print_col );
        return s << " )";
    }

    template< typename... tables >
    struct schema
    {
        template< typename stream >
        friend auto operator<<( stream &s, schema ) -> decltype( s << "" )
        {
            auto l = brq::cons_list( tables()... );
            l.each( [&]( auto t ) { s << t << "\n"; } );
            return s;
        }
    };

    struct conn
    {
        SQLHENV _henv;
        SQLHDBC _hconn;

        void throw_error( std::string err, SQLSMALLINT h_type, SQLHENV h )
        {
            SQLINTEGER errcode;
            SQLSMALLINT bytes;
            SQLCHAR sql_state[6];
            std::vector< SQLCHAR > message;
            SQLGetDiagRec( h_type, h, 1, sql_state, &errcode, 0, 0, &bytes );
            message.resize( bytes );
            SQLGetDiagRec( h_type, h, 1, sql_state, &errcode, message.data(), message.size(), &bytes );
            throw error( err + ": " +
                         std::string( reinterpret_cast< char * >( sql_state ) ) +
                         std::string( message.begin(), message.end() ) );
        }

        template< typename... Args >
        void odbc( std::string what, SQLSMALLINT h_type, SQLHANDLE &h,
                   RETCODE (*fn)( Args... ), std::decay_t< Args >... args )
        {
            RETCODE rc = fn( std::forward< Args >( args )... );
            if ( rc != SQL_SUCCESS && rc != SQL_SUCCESS_WITH_INFO )
                throw_error( what, h_type, h );
        }

        template< typename... Args >
        void odbc( std::string what,
                   RETCODE (*fn)( SQLSMALLINT, SQLHANDLE, Args... ), std::decay_t< Args >... args )
        {
            odbc( what, SQL_HANDLE_DBC, _hconn, fn, SQL_HANDLE_DBC, _hconn,
                  std::forward< Args >( args )... );
        }

        conn( std::string dsn )
        {
            odbc( "allocating environment handle", SQL_HANDLE_ENV, _henv,
                  SQLAllocHandle, SQL_HANDLE_ENV, SQL_NULL_HANDLE, &_henv );
            odbc( "setting ODBC version", SQL_HANDLE_ENV, _henv,
                  SQLSetEnvAttr, _henv, SQL_ATTR_ODBC_VERSION,
                  reinterpret_cast< SQLPOINTER >( SQL_OV_ODBC3 ), SQL_IS_UINTEGER );
            odbc( "allocating connection handle", SQL_HANDLE_ENV, _henv,
                  SQLAllocHandle, SQL_HANDLE_DBC, _henv, &_hconn );
            std::vector< SQLCHAR > dsn_( dsn.begin(), dsn.end() );
            odbc( "connecting to " + dsn, SQL_HANDLE_DBC, _hconn,
                  SQLConnect, _hconn, dsn_.data(), SQL_NTS, 0, SQL_NTS, 0, SQL_NTS );
        }

        ~conn()
        {
            SQLFreeHandle( SQL_HANDLE_DBC, _hconn );
            SQLFreeHandle( SQL_HANDLE_DBC, _henv );
        }
    };

}

namespace brq
{
    using sql_connection = sql::conn;
    using sql_error      = sql::error;
}
