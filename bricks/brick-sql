// -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4 -*-

/*
 * Copyright (C) 2019 Petr Rockai <code@fixp.eu>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#pragma once
#include "brick-assert"
#include "brick-string"
#include "brick-cons"
#include "brick-except"

#include <memory>
#include <vector>
#include <set>
#include <cxxabi.h>
#include <codecvt>
#include <endian.h> /* beNNtoh / htobeNN */
#include <sys/select.h>

#include <libpq-fe.h>

namespace brq::sql
{
    struct error : std::runtime_error
    {
        using std::runtime_error::runtime_error;
    };

    template< typename T >
    std::string_view get_name( char quote = '"' )
    {
        static std::string name;
        if ( name.empty() )
        {
            int stat;
            char *dem = abi::__cxa_demangle( typeid( T ).name(), nullptr, nullptr, &stat );
            if ( strchr( dem, '<' ) )
                *strchr( dem, '<' ) = 0;
            name = strchr( dem, ':' ) ? strrchr( dem, ':' ) + 1 : dem;
            NOISE( dem, "â†’", name );
            std::free( dem );
            if ( quote )
                name = quote + name + quote;
        }
        return name;
    }

    template< typename T >
    std::string_view get_name( T, char quote = '"' ) { return get_name< T >( quote ); }

    struct date
    {
        unsigned julian;

        explicit date( int y = 1970, int m = 1, int d = 1 )
        {
            if ( m > 2 )
                m += 1, y += 4800;
            else
                m += 13, y += 4799;

            julian = y * 365 - 32167;
            julian += y / 4 - y / 100 + y / 400;
            julian += 7834 * m / 256 + d;
        }

        std::tuple< int, int, int > decompose()
        {
            unsigned j = julian + 32044;
            unsigned quad = j / 146097;
            unsigned extra = (j - quad * 146097) * 4 + 3;

            j += 60 + quad * 3 + extra / 146097;
            quad = j / 1461;
            j -= quad * 1461;
            int y = j * 4 / 1461;
            j = ((y != 0) ? ((j + 305) % 365) : ((j + 306) % 366)) + 123;
            y += quad * 4;
            quad = j * 2141 / 65536;

            return { y - 4800, (quad + 10) % 12 + 1, j - 7834 * quad / 256 };
        }

        friend string_builder &operator<<( string_builder &s, date v )
        {
            auto [ y, m, d ] = v.decompose();
            return s << y << "-" << pad( 2, '0' ) << m << mark << "-" << pad( 2, '0' ) << d << mark;
        }
    };
    struct time { std::int16_t hour, min, sec; };
    struct timestamp
    {
        std::int64_t fract = 0;

        static timestamp from_unix( time_t t ) { return { ( int64_t( t ) - 946684800 ) * 1000000 }; }
        time_t to_unix() const { return fract / 1000000 + 946684800; }
        bool operator<( timestamp o ) const { return fract < o.fract; }
        bool operator==( timestamp o ) const { return fract == o.fract; }

        struct tm to_localtime() const
        {
            struct tm tm;
            auto t = to_unix();
            localtime_r( &t, &tm );
            return tm;
        }

        std::string to_string( const char *fmt = "%Y-%m-%d %H:%M %Z" ) const
        {
            char buf[200];
            auto tm = to_localtime();
            strftime( buf, 200, fmt, &tm );
            return buf;
        }

        friend auto &operator<<( brq::string_builder &s, timestamp ts )
        {
            return s << ts.to_string();
        }
    };

    struct interval
    {
        std::int64_t seconds; std::int32_t days, months;

        static interval from_seconds( time_t s )
        {
            return { s * 1000000, 0, 0 };
        }

        time_t as_seconds() const
        {
            ASSERT_EQ( months, 0 );
            return time_t( days ) * 3600 * 24 + seconds / 1000000;
        }

        friend auto &operator<<( brq::string_builder &s, interval i )
        {
            return s << i.as_seconds();
        }
    };

    template< int scale, typename base_t = int64_t >
    struct fixnum
    {
        base_t value;
        fixnum( base_t v = 0 ) : value( v * scale ) {}
        explicit fixnum( double v ) : value( v * scale ) {}
        fixnum( base_t v, int s ) : value( v ) { ASSERT_EQ( s, scale ); }
        bool operator==( fixnum o ) const { return value == o.value; }
        bool operator<( fixnum o ) const { return value < o.value; }
        bool operator>( fixnum o ) const { return value > o.value; }
        bool operator>=( fixnum o ) const { return value >= o.value; }
        explicit operator bool() const { return value; }

        static parse_result from_string( std::string_view s, fixnum &n )
        {
            base_t sign = 1, value = 0, f_scale = scale;
            bool seen_dot = false;

            if ( !s.empty() && s[ 0 ] == '-' )
                s.remove_prefix( 1 ), sign = -1;

            for ( size_t off = 0; off < s.size() && f_scale > 1; ++ off )
                if ( std::isdigit( s[ off ] ) )
                    value *= 10, value += s[ off ] - '0', f_scale /= seen_dot ? 10 : 1;
                else if ( s[ off ] == '.' && !seen_dot )
                    seen_dot = true;
                else
                    return no_parse( "unexpected character" );

            for ( ; f_scale > 1 ; f_scale /= 10 ) value *= 10;
            n.value = sign * value;
            return {};
        }

        friend string_builder &operator<<( string_builder &s, fixnum n )
        {
            auto fract = n.value % scale;
            int  whole = n.value / scale;
            int f_scale = scale;
            s << ( !whole && fract < 0 ? "-" : "" ) << whole;
            while ( fract && fract % 10 == 0 )
                f_scale /= 10, fract /= 10;
            int pad_count = 0;
            while ( f_scale > 1 )
                pad_count += 1, f_scale /= 10;
            if ( fract )
                s << "." << pad( pad_count, '0' ) << std::abs( fract ) << mark;
            return s;
        }

        friend fixnum abs( fixnum n ) { return fixnum( abs( n.value ), scale ); }
        fixnum operator+( fixnum n ) const { return fixnum( value + n.value, scale ); }
        fixnum operator*( int n ) const { return fixnum( value * n, scale ); }
        fixnum operator/( int n ) const { return fixnum( value / n, scale ); }
    };

    struct category_flags
    {
        static constexpr bool is_column   = false;
        static constexpr bool is_enum     = false;
        static constexpr bool is_expr     = false;
        static constexpr bool is_query    = false;
        static constexpr bool is_table    = false;
        static constexpr bool is_view     = false;
        static constexpr bool is_function = false;
    };

    template< typename T >
    struct enum_value : category_flags
    {
        using type = T;
        static constexpr bool is_enum = true;
    };

    template< typename... vals >
    struct enum_type : category_flags
    {
        using values = cons_list_t< vals... >;
        static constexpr bool is_enum  = true;
        static constexpr bool is_expr  = true;

        typename values::co _value;
        template< typename X >
        enum_type( const X &x ) : _value( x ) {}
        enum_type() : _value( typename values::car_t() ) {}

        friend string_builder &operator<<( string_builder &s, const enum_type &v )
        {
            return s << *v._value.match( []( const auto &d ) { return get_name( d, 0 ); } );
        }
    };

    struct decimal {};

    template< typename T, typename = void > struct type_map {};
    template<> struct type_map< bool >           { static auto name() { return "bool"; } };
    template<> struct type_map< short >          { static auto name() { return "smallint"; } };
    template<> struct type_map< int >            { static auto name() { return "integer"; } };
    template<> struct type_map< int64_t >        { static auto name() { return "bigint"; } };
    template<> struct type_map< std::u32string > { static auto name() { return "text"; } };
    template<> struct type_map< std::u32string_view > { static auto name() { return "text"; } };
    template<> struct type_map< std::string >    { static auto name() { return "bytea"; } };
    template<> struct type_map< std::string_view > { static auto name() { return "bytea"; } };
    template<> struct type_map< const char * >   { static auto name() { return "bytea"; } };
    template<> struct type_map< date >           { static auto name() { return "date"; } };
    template<> struct type_map< time >           { static auto name() { return "time"; } };
    template<> struct type_map< timestamp >      { static auto name() { return "timestamp"; }; };
    template<> struct type_map< interval >       { static auto name() { return "interval"; }; };
    template<> struct type_map< decimal >        { static auto name() { return "decimal"; }; };

    template< typename T > struct type_map< std::optional< T > > : type_map< T > {};

    template< typename T, int v > struct type_map< fixnum< v, T > >
    {
        static auto name() { return type_map< T >::name(); }
    };

    template< size_t v > struct type_map< std::array< uint8_t, v > >
    {
        static auto name() { return "bytea"; }
    };

    template< typename T > struct type_map< T, std::enable_if_t< T::is_enum > >
    {
        static auto name() { return get_name( T(), 0 ); }
    };

    template< typename T > struct type_map< T, std::enable_if_t< T::type::is_enum > >
    {
        static auto name() { return get_name( typename T::type(), 0 ); }
    };

    template< typename T > auto sql_type()
    {
        return brq::sql::type_map< T >::name();
    }

    template< typename T > struct is_array : std::false_type {};
    template< typename T, size_t s > struct is_array< std::array< T, s > > : std::true_type {};

    template< typename T > struct is_set : std::false_type {};
    template< typename T > struct is_set< std::set< T > > : std::true_type {};

    template< typename T > struct is_optional : std::false_type {};
    template< typename T > struct is_optional< std::optional< T > > : std::true_type {};

    template< typename T, typename = void > struct is_expr : std::false_type {};
    template< typename T > struct is_expr< T, std::enable_if_t< T::is_expr > > : std::true_type {};
    template< typename T > struct is_expr< T, std::enable_if_t< T::is_enum > > : std::true_type {};
    template< typename T > constexpr bool is_expr_v = is_expr< T >::value;
    struct where_operator { const char *sql; where_operator( const char *s = "" ) : sql( s ) {} };

    template< typename T >
    static constexpr bool is_value = ( std::is_convertible_v< T, std::string_view > ||
                                       std::is_convertible_v< T, std::u32string_view > ||
                                       std::is_convertible_v< T, timestamp > ||
                                       std::is_convertible_v< T, interval > ||
                                       is_array< T >::value ||
                                       std::is_convertible_v< T, int > ) && !is_list_v< T >;

    template< bool bind = true, typename stream, typename V >
    static void print( stream &s, const V &v, int &id )
    {
        if constexpr ( is_set< V >::value )
        {
            int i = 0;
            if ( v.empty() )
                s << "( select null::" << sql_type< typename V::value_type >() << " where false";
            for ( const auto &e : v )
                s << ( i ++ ? ", " : "( " ), print( s, e, id );
            s << " )";
        }
        else if constexpr ( is_value< V > )
        {
            if ( id >= 0 )
                s << "$" << id++ << "::" << sql_type< V >();
            else
                s << "'" << v << "'::" << sql_type< V >();
        }
        else if constexpr ( std::is_same_v< V, std::nullopt_t > )
            s << "null";
        else if constexpr ( is_optional< V >::value )
        {
            if ( v.has_value() )
                return print( s, *v, id );
            else
                s << "null::" << sql_type< V >();
        }
        else if constexpr ( std::is_same_v< V, where_operator > )
            s << v.sql;
        else if constexpr ( brq::is_list_v< V > )
        {
            bool first = true;
            auto item = [&]( const auto &i )
            {
                s << ( first ? "" : ", " );
                print( s, i, id );
                first = false;
            };
            v.each( item );
            s << " ";
        }
        else if constexpr ( V::is_function )
            s << get_name( v, 0 ), v.print( s, id );
        else if constexpr ( V::is_column )
            s << v.column_name( v ) << "::" << sql_type< typename V::type >();
        else if constexpr ( V::is_query )
            s << "( ", v.print( s, id ), s << " )";
        else if constexpr ( V::is_enum )
            s << "'" << get_name( v, 0 ) << "'";
        else
            v.print( s, id );
    }

    template< typename stmt, typename V >
    static auto bind( stmt &s, const V &v )
    {
        if constexpr ( is_set< V >::value )
            for ( const auto &e : v )
                bind( s, e );
        else if constexpr ( is_value< V > ) s.bind( v ) ;
        else if constexpr ( is_optional< V >::value )
        {
            if ( v.has_value() )
                bind( s, *v );
        }
        else if constexpr ( std::is_same_v< V, where_operator > ) /* nothing */ ;
        else if constexpr ( is_list_v< V > ) /* nothing */ ;
        else if constexpr ( V::is_function ) v.bind( s ) ;
        else if constexpr ( V::is_column || V::is_enum ) /* nothing */ ;
        else
            v.bind( s );
    }

    template< typename T, bool _nullable = false >
    struct column
    {
        template< typename CT >
        static std::string_view column_name( const CT &ct ) { return get_name( ct ); }

        using type = std::conditional_t< _nullable, std::optional< T >, T >;
        using base_type = T;
        using bare = void;
        using table = void;
        using qualifier = void;

        static constexpr bool is_nullable = _nullable;
        static constexpr bool is_primary = false;
        static constexpr bool is_foreign = false;
        static constexpr bool is_constraint = false;
        static constexpr bool is_qualified = false;

        static constexpr bool is_expr = true;
        static constexpr bool is_column = true;
        static constexpr bool is_function = false;
        static constexpr bool is_asc = false;
        static constexpr bool is_query = false;
        static constexpr bool is_enum = false;
    };

    template< typename T, bool call = false >
    struct constant : column< T, false >
    {
        static constexpr const bool is_function = true;

        template< typename stream >
        void print( stream &s, int & ) const
        {
            if ( call )
                s << "()";
            if constexpr ( !std::is_same_v< T, void > )
                s << "::" << sql_type< T >();
        }

        template< typename stmt > void bind( stmt &s ) const {}
    };

    struct row_number : constant< void, true > {};

    template< typename tab, typename col >
    struct in_table : col
    {
        using bare = col;
        using qualifier = tab;
        static constexpr bool is_qualified = true;

        template< typename CT >
        static std::string_view column_name( const CT & )
        {
            static auto name = std::string( get_name( tab() ) ) +
                               "." + std::string( col().column_name( col() ) );
            return name;
        }
    };

    template< typename col >
    struct excluded : col
    {
        template< typename CT >
        static std::string_view column_name( const CT & )
        {
            static auto name = "excluded." + std::string( col().column_name( col() ) );
            return name;
        }
    };

    template< typename col >
    struct nullable : col
    {
        using type = std::optional< typename col::type >;
        static constexpr bool is_nullable = true;
    };

    template< typename T >
    using unqualify = std::conditional_t< T::is_qualified, typename T::bare, T >;

    template< typename type, typename... args >
    struct function : column< type >
    {
        static constexpr bool is_qualified = true;
        static constexpr bool is_function  = true;

        using args_t = brq::cons_list_t< args... >;
        using bare = typename args_t::car_t;
        args_t _args;

        function( args... ts ) : _args( ts... ) {}
        function() = default;

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            s << "( ";
            sql::print( s, _args, id );
            s << " )";
            if constexpr ( !std::is_same_v< type, void > )
                s << "::" << sql_type< type >();
        }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            _args.each( [&]( auto &v ) { sql::bind( s, v ); } );
        }
    };

    template< typename... cols >
    using endomorphism = function< typename cons_list_t< cols... >::car_t::type, cols... >;

    template< typename col > struct count : function< int32_t, col >
    {
        explicit count( const col &c = col() ) : function< int32_t, col >( c ) {}
    };

#define BRICK_SQL_ENDO(n) \
    template< typename... cols > struct n : endomorphism< cols... > \
    { explicit n( cols... cs ) : endomorphism< cols... >( cs... ) {} n() = default; }

    BRICK_SQL_ENDO( min );
    BRICK_SQL_ENDO( max );
    BRICK_SQL_ENDO( sum );
    BRICK_SQL_ENDO( greatest );
    BRICK_SQL_ENDO( least );
    BRICK_SQL_ENDO( distinct );
    BRICK_SQL_ENDO( every );

#undef BRICK_SQL_ENDO

    template< typename col, typename type > struct cast_to : function< type, col >
    {
        static constexpr const bool is_query = true;
        static constexpr const bool is_column = false;
        static constexpr const bool is_function = false;
        using function< type, col >::function;

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            s << "(";
            sql::print( s, this->_args, id );
            s << ")::" << sql_type< type >();
        }
    };

    template< typename col > struct cast
    {
        col _col;
        cast( const col &c ) : _col( c ) {}

        template< typename T >
        cast_to< col, T > to() { return { _col }; }
    };

    template< typename... cols >
    struct coalesce : endomorphism< cols... >
    {
        coalesce( const cols & ... v ) : endomorphism< cols... >( v... ) {}
    };

    template< typename col >
    struct substring : endomorphism< col >
    {
        std::string _pat;

        substring( const col &c, std::string_view p ) : endomorphism< col >( c ), _pat( p ) {}

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            s << "( ";
            sql::print( s, this->_args, id );
            s << " from '" << _pat << "' )::" << sql_type< typename col::type >();
        }
    };

    template< typename tab, typename col, bool _nullable = false >
    struct foreign_key : col
    {
        using column = col;
        using table = tab;
        using base_type = typename col::type;
        static constexpr bool adds_null = _nullable && !col::is_nullable;
        using type = std::conditional_t< adds_null, std::optional< base_type >, base_type >;
        static constexpr bool is_nullable = _nullable;
        static constexpr bool is_foreign = true;
    };

    template< typename col >
    struct primary_key : col
    {
        template< typename CT >
        static std::string_view column_name( const CT & ) { return col().column_name( col() ); }

        using base = col;
        static constexpr bool is_primary = true;
    };

    template< typename... cols >
    struct unique
    {
        using columns = cons_list_t< cols... >;
        static constexpr bool is_constraint = true;
        static constexpr bool is_table = false;
    };

    template< typename T >
    struct not_constraint { static constexpr bool value = !T::is_constraint; };
    template< typename T >
    struct is_primary { static constexpr bool value = T::is_primary; };

    template< typename... cols >
    struct table
    {
        using all = cons_list_t< cols... >;
        using columns = decltype( all().template filter< not_constraint >() );
        static constexpr bool is_table = true;
        static constexpr bool is_view  = false;
    };

    template< typename... cols >
    struct view
    {
        using columns = cons_list_t< cols... >;
        static constexpr bool is_table = false;
        static constexpr bool is_view  = true;
        static constexpr bool is_updatable = false;
    };

    template< typename... cols >
    struct updatable_view : view< cols... >
    {
        static constexpr bool is_updatable = true;
    };

    template< typename... tables_ >
    struct schema : cons_list_t< tables_... > {};

    struct txn;

    struct notification
    {
        std::string channel, payload;
        bool valid;
        explicit operator bool() { return valid; }

        notification( std::string ch, std::string p )
            : channel( ch ), payload( p ), valid( true )
        {}

        notification() : valid( false ) {}

        bool operator<( const notification &o ) const
        {
            ASSERT( valid && o.valid );
            if ( channel == o.channel )
                return payload < o.payload;
            else
                return channel < o.channel;
        }
    };

    struct conn
    {
        std::set< notification > _pending;
        std::string _notices;
        PGconn *_handle = nullptr;
        PGconn *handle() { return _handle; }

        const char *errmsg() { return PQerrorMessage( _handle ); }

        conn( std::string s )
        {
            if ( !( _handle = PQconnectdb( s.c_str() ) ) )
                throw std::bad_alloc();
            if ( PQstatus( _handle ) != CONNECTION_OK )
                raise< error >() << "connecting to " << s << " " << errmsg();

            auto msg = []( void *_this, const char *msg )
            {
                static_cast< conn * >( _this )->_notices += msg;
            };

            PQsetNoticeProcessor( _handle, msg, this );
        }

        void exec( std::string_view sql )
        {
            _notices.clear();
            auto result = PQexec( handle(), c_str( sql ) );
            if ( PQresultStatus( result ) != PGRES_COMMAND_OK )
                raise< error >() << "executing " << sql << ": " << errmsg();
        }

        notification check_notify()
        {
            PQconsumeInput( handle() );

            while ( auto notify = PQnotifies( handle() ) )
            {
                _pending.emplace( notify->relname, notify->extra );
                PQfreemem( notify );
            }

            if ( _pending.empty() )
                return {};

            auto rv = *_pending.begin();
            _pending.erase( _pending.begin() );
            return rv;
        }

        notification wait( std::optional< time_t > deadline = std::nullopt )
        {
            if ( auto n = check_notify() )
                return n;

            int sock = PQsocket( handle() );
            fd_set fds;
            FD_ZERO( &fds );
            FD_SET( sock, &fds );

            auto now = ::time( nullptr );
            struct timeval tv = { !deadline || now >= *deadline ? 0 : *deadline - now, 0 };
            DEBUG( "awaiting notifications, timeout =", tv.tv_sec );

            if ( ::select( sock + 1, &fds, nullptr, nullptr, deadline ? &tv : nullptr ) < 0 )
                brq::raise< system_error >() << "select on postgres socket";

            auto n = check_notify();

            if ( !n )
                DEBUG( "check_notify: timeout" );

            return n;
        }

        ~conn()
        {
            PQfinish( _handle );
        }

        txn begin();
    };

    template< typename... cols >
    struct row
    {
        using columns_t = brq::cons_list_t< cols... >;
        using values_t  = brq::cons_list_t< typename cols::type... >;
        values_t _values;

        row() = default;
        row( typename cols::type... v ): _values( v... ) {}

        template< typename col, typename cs_t, typename vs_t >
        auto &get( vs_t &vs )
        {
            if constexpr ( std::is_same_v< col, typename cs_t::car_t > )
                return vs.car();
            else
                return get< col, typename cs_t::cdr_t >( vs.cdr() );
        }

        template< int i > auto &get() { return get< i >( _values ); }
        template< int i, typename vs_t > auto &get( vs_t &vs )
        {
            if constexpr ( i == 0 )
                return vs.car();
            else
                return get< i - 1, typename vs_t::cdr_t >( vs.cdr() );
        }

        template< typename col >
        auto &get() { return get< col, columns_t >( _values ); }
    };

    template< typename... cols >
    struct iterator
    {
        PGresult *_result;
        int _row = 0, _col = 0;

        bool operator==( const iterator &o ) const { return o._result == _result && o._row == _row; }
        bool operator!=( const iterator &o ) const { return !( *this == o ); }

        iterator( PGresult *res, int row ) : _result( res ), _row( row ) {}
        iterator &operator++() { ++_row; _col = 0; return *this; }
        iterator operator++( int ) { auto r = *this; ++ (*this); return r; }

        template< typename T >
        void fetch_raw( T &t )
        {
            ASSERT( !PQgetisnull( _result, _row, _col ), "row =", _row, "col =", _col );
            ASSERT_EQ( PQgetlength( _result, _row, _col ), sizeof( T ) );
            std::memcpy( &t, PQgetvalue( _result, _row, _col ), sizeof( T ) );
        }

        void fetch_one( bool &t ) { fetch_raw( t ); }
        void fetch_one( int16_t &t ) { fetch_raw( t ); t = be16toh( t ); }
        void fetch_one( int32_t &t ) { fetch_raw( t ); t = be32toh( t ); }
        void fetch_one( int64_t &t ) { fetch_raw( t ); t = be64toh( t ); }
        void fetch_one( timestamp &t ) { fetch_raw( t.fract ); t.fract = be64toh( t.fract ); }
        template< typename T, int s > void fetch_one( fixnum< s, T > &n ) { fetch_one( n.value ); }

        template< typename T, size_t s > void fetch_one( std::array< T, s > &n )
        {
            ASSERT_EQ( PQgetlength( _result, _row, _col ), n.size() * sizeof( T ) );
            std::memcpy( n.begin(), PQgetvalue( _result, _row, _col ), n.size() * sizeof( T ) );
        }

        void fetch_one( interval &i )
        {
            fetch_raw( i );
            i.seconds = be64toh( i.seconds );
            i.days    = be32toh( i.days );
            i.months  = be32toh( i.months );
        }

        void fetch_one( std::u32string &us )
        {
            const char *data = PQgetvalue( _result, _row, _col );
            std::wstring_convert< std::codecvt_utf8< char32_t >, char32_t > conv;
            us = conv.from_bytes( data, data + PQgetlength( _result, _row, _col ) );
        }

        void fetch_one( std::string &s )
        {
            const char *data = PQgetvalue( _result, _row, _col );
            s = std::string( data, data + PQgetlength( _result, _row, _col ) );
        }

        template< typename T > void fetch_one( std::optional< T > &opt )
        {
            if ( PQgetisnull( _result, _row, _col ) )
                opt = std::nullopt;
            else
                opt = T(), fetch_one( *opt );
        }

        row< cols... > operator*()
        {
            row< cols... > r;
            r._values.each( [&]( auto &v ) { fetch_one( v ); ++ _col; } );
            return r;
        }
    };

    template< typename... cols >
    struct stmt
    {
        using columns = brq::cons_list_t< cols... >;
        using result_t = row< cols... >;

        conn &_conn;
        brq::string_builder _query, _debug;

        std::vector< std::unique_ptr< char[] > > _memory;
        std::vector< const char * > _params;
        std::vector< int > _lengths;
        PGresult *_result = nullptr;

        using iterator = sql::iterator< cols... >;
        iterator begin() { return iterator( _result, 0 ); }
        iterator end()   { return iterator( _result, size() ); }
        int size() const { return PQntuples( _result ); }

        row< cols... > result()
        {
            ASSERT_EQ( PQntuples( _result ), 1 );
            return *begin();
        }

        void bind_mem( const char *data, int size )
        {
            _lengths.push_back( size );
            _memory.emplace_back( new char[ size ] );
            std::memcpy( _memory.back().get(), data, size );
            _params.push_back( _memory.back().get() );
        }

        void bind_mem( const uint8_t *data, int size )
        {
            bind_mem( reinterpret_cast< const char * >( data ), size );
        }

        template< typename T >
        stmt( conn &c, const T &t ) : _conn( c )
        {
            _query << t;
            _debug << "where";
        }

        stmt( const stmt & ) = delete;
        stmt( stmt &&o )
            : _conn( o._conn ), _query( std::move( o._query ) ), _debug( std::move( o._debug ) ),
              _memory( std::move( o._memory ) ), _params( o._params ),
              _lengths( o._lengths ), _result( o._result )
        {
            o._result = nullptr;
        }

        ~stmt()
        {
            if ( _result )
                PQclear( _result );
        }

        template< typename T >
        void bind_raw( const T &t ) { bind_mem( reinterpret_cast< const char * >( &t ), sizeof( T ) ); }

        void bind_one( interval &i )
        {
            i.seconds = htobe64( i.seconds );
            i.days = htobe64( i.days );
            i.months = htobe64( i.months );
            bind_raw( i );
        }

        void bind_one( timestamp &t ) { t.fract = htobe64( t.fract ); bind_raw( t ); }
        void bind_one( date &d ) { d.julian -= 2451545; d.julian = htobe32( d.julian ); bind_raw( d ); }
        void bind_one( int64_t &t ) { t = htobe64( t ); bind_raw( t ); }
        void bind_one( int32_t &t ) { t = htobe32( t ); bind_raw( t ); }
        void bind_one( int16_t &t ) { t = htobe16( t ); bind_raw( t ); }
        void bind_one( bool &t )    { bind_raw( t ); }
        void bind_one( std::string_view s ) { bind_mem( s.data(), s.size() ); }
        void bind_one( std::u32string_view us )
        {
            std::wstring_convert< std::codecvt_utf8< char32_t >, char32_t > conv;
            auto str = conv.to_bytes( &*us.begin(), &*us.end() );
            bind_mem( str.data(), str.size() );
        }

        template< typename T, int s > void bind_one( fixnum< s, T > &f ) { bind_one( f.value ); }

        template< size_t n >
        void bind_one( const std::array< uint8_t, n > &s ) { bind_mem( s.begin(), s.size() ); }

        template< typename T >
        std::enable_if_t< T::is_enum > bind_one( T v )
        {
            v._value.match( [&]( auto x ) { bind_one( std::string( get_name( x, 0 ) ) ); } );
        }

        template< typename T > void bind_one( std::optional< T > v )
        {
            if ( v.has_value() )
                bind_one( *v );
            else
            {
                _lengths.push_back( 0 );
                _params.push_back( nullptr );
            }
        }

        stmt &exec()
        {
            std::vector< int > formats( _params.size(), 1 );

            DEBUG( _query.buffer(), _params.size() ? _debug.buffer() : "" );
            _conn._notices.clear();
            _result = PQexecParams( _conn.handle(), _query.buffer(), _params.size(), nullptr,
                                    _params.data(), _lengths.data(), formats.data(), 1 );

            auto r = PQresultStatus( _result );
            if ( r != PGRES_COMMAND_OK && r != PGRES_TUPLES_OK )
                raise< error >() << "executing " << _query.buffer() << ": " << _conn.errmsg();

            return *this;
        }

        template< typename list_t >
        stmt &bind_list( list_t list )
        {
            int count = 0;
            list.each( [&]( auto ) { ++count; } );
            _params.reserve( _params.size() + count );
            _memory.reserve( _memory.size() + count );

            int i = _params.size();
            list.each( [&]( auto &v ) { _debug << " $" << ++i << " = '" << v << "'"; } );
            list.each( [&]( auto &v ) { bind_one( v ); } );
            return *this;
        }

        template< typename... args >
        stmt &bind( const args &... vs )
        {
            return bind_list( cons_list( vs... ) );
        }
    };

    template< typename... args >
    struct where_expr
    {
        static constexpr bool is_expr = true;
        static constexpr bool is_column = false;
        static constexpr bool is_query = false;
        static constexpr bool is_enum = false;
        static constexpr bool is_function = false;
        static constexpr bool is_asc = true;

        using type = void; /* we don't know :( */

        cons_list_t< args... > _args;
        bool _parens = false;

        where_expr( args... as ) : _args( as... ) {}
        where_expr() = default;

        template< typename stream >
        stream &print( stream &s, int &id ) const
        {
            s << ( _parens ? "( " : "" );
            _args.each( [&]( auto v ) { sql::print( s, v, id ); s << " "; } );
            return s << ( _parens ? ")" : "" );
        }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            _args.each( [&]( auto &v ) { sql::bind( s, v ); } );
        }
    };

    template< typename T >
    using unarray_t = std::conditional_t< std::is_array_v< T >, std::remove_extent_t< T > *, T >;

    template< typename T >
    auto set_nested( T &t, brq::primary_t ) -> decltype( t._parens )
    {
        return t._parens = true;
    }

    template< typename T >
    void set_nested( T &, brq::fallback ) {}

#define BRICK_SQL_OP_(op, sql)                                                                    \
    template< typename A, typename B >                                                            \
    auto op( A &&a, B &&b )                                                                       \
        -> std::enable_if_t< is_expr_v< std::decay_t< A > > || is_expr_v< std::decay_t< B > >,    \
                             where_expr< std::decay_t< A >, where_operator, std::decay_t< B > > > \
    {                                                                                             \
        set_nested( a, primary ); set_nested( b, primary );                                       \
        return { a, where_operator{ sql }, b };                                                   \
    }

    template< typename... cols >
    struct tuple
    {
        static constexpr bool is_column = false;
        static constexpr bool is_enum = false;
        static constexpr bool is_query = false;
        static constexpr bool is_function = false;
        static constexpr bool is_expr = true;
        static constexpr bool is_asc = true;

        brq::cons_list_t< cols... > _cols;
        tuple( cols... c ) : _cols( c... ) {}

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            s << "( "; sql::print( s, _cols, id ); s << " )";
        }

        template< typename stmt > void bind( stmt &s ) const
        {
            _cols.each( [&]( const auto &c ) { sql::bind( s, c ); } );
        }
    };

#define BRICK_SQL_OP(op) BRICK_SQL_OP_(operator op, #op)

BRICK_SQL_OP_( operator ==, "=" )
BRICK_SQL_OP_( operator %=, "like" )
BRICK_SQL_OP_( operator &&, "and" )
BRICK_SQL_OP_( operator ||, "or" )
BRICK_SQL_OP_( operator ^, "#" )
BRICK_SQL_OP_( pow, "^" )
BRICK_SQL_OP_( in, "in" )

BRICK_SQL_OP( < )
BRICK_SQL_OP( > )
BRICK_SQL_OP( <= )
BRICK_SQL_OP( >= )
BRICK_SQL_OP( != )
BRICK_SQL_OP( + )
BRICK_SQL_OP( - )
BRICK_SQL_OP( * )
BRICK_SQL_OP( / )
BRICK_SQL_OP( % )
BRICK_SQL_OP( & )
BRICK_SQL_OP( | )

    template< typename F, typename P, typename O >
    auto over( F function, P partition, O order )
    {
        where_expr window{ where_operator( "partition by" ), partition,
                           where_operator( "order by" ), order };
        set_nested( window, primary );
        return where_expr{ function, where_operator( "over" ), window };
    }

#undef BRICK_SQL_OP

    template< typename A >
    auto is_null( A &&a ) -> std::enable_if_t< is_expr_v< std::decay_t< A > >,
                                               where_expr< std::decay_t< A >, where_operator > >
    {
        return { a, where_operator{ "is null" } };
    }

    template< typename A >
    auto desc( A &&a ) -> std::enable_if_t< is_expr_v< std::decay_t< A > >,
                                            where_expr< std::decay_t< A >, where_operator > >
    {
        return { a, where_operator{ "desc" } };
    }

    template< typename A >
    auto operator!( A &&a ) -> std::enable_if_t< is_expr_v< std::decay_t< A > >,
                                                 where_expr< where_operator, std::decay_t< A > > >
    {
        return { where_operator{ "not" }, a };
    }

    template< typename C, typename T, typename E >
    where_expr< where_operator, C, where_operator, T, where_operator, E, where_operator >
    when( C c, T t, E e )
    {
        return { "case", c, "when true then", t, "else", e, "end" };
    }

    struct query_base
    {
        static constexpr bool is_column = false;
        static constexpr bool is_query = true;
        static constexpr bool is_expr = true;
        static constexpr bool is_enum = false;
        static constexpr bool is_function = false;
        using type = void; /* we don't know :( */
    };

    template< typename q, typename col >
    constexpr bool has_column = q::stmt::columns::template has< col >;

    template< typename > struct raw_sql;

    template< typename query >
    struct extend : query_base
    {
        using stmt = typename query::stmt;
        query _query;
        sql::conn &conn() { return _query.conn(); }
        sql::txn &txn() { return _query.txn(); }
        extend( query q ) : _query( q ) {}

        auto order_columns() const { return _query.order_columns(); }

        template< typename stmt >
        void bind( stmt &s ) const { _query.bind( s ); }

        template< typename T >
        stmt _exec( T *t )
        {
            stmt s( t->conn(), *t );
            t->bind( s );
            s.exec();
            return s;
        }
    };

    template< typename stream, typename list >
    void print_list( stream &s, list l,
                     const char *delim = ", ", const char *start = "", const char *end = "" )
    {
        bool first = true;
        s << start;
        l.each( [&]( const auto &c ) { s << ( first ? " " : delim ) << c; first = false; } );
        s << end;
    }

    template< typename stream, typename list >
    void print_columns( stream &s, list l, const char *start = "", const char *end = "" )
    {
        print_list( s, l.map( [&]( auto c ) { return c.column_name( c ); } ), ", ", start, end );
    }

    template< typename select, typename... cols >
    struct group_by;

    template< typename query, typename... cols >
    struct order_clause : extend< query >
    {
        brq::cons_list_t< cols... > _cols;
        using extend< query >::extend;
        order_clause( query &q, cols... cs ) : extend< query >( q ), _cols( cs... ) {}

        template< typename cols_t >
        order_clause( query &q, cols_t cs ) : extend< query >( q ), _cols( cs ) {}

        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " order by ";
            auto l = this->order_columns().cat( _cols );
            int count = 0;
            auto print_one = [&]( auto &c )
            {
                s << ( count++ ? ", " : "" );
                sql::print( s, c, id );
                if ( !c.is_asc )
                    s << " desc ";
            };
            l.each( print_one );
        }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            this->_query.bind( s );
            _cols.each( [&]( const auto &c ) { sql::bind( s, c ); } );
        }

        sql::raw_sql< order_clause > raw_sql( std::string_view sv ) { return { *this, sv }; }

        template< typename... ct, typename... et >
        order_clause< query, cols..., ct..., et... > order_by( et... ex )
        {
            return { this->_query, _cols.cat( brq::cons_list( ex... ) ) };
        }
    };

    template< typename query, typename expr >
    struct where_clause : extend< query >
    {
        expr _expr;
        const char *_clause;
        where_clause( query q, const expr &e, const char *c = "where" )
            : extend< query >( q ), _expr( e ), _clause( c )
        {}

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " " << _clause << " ";
            sql::print( s, _expr, id );
        }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            this->_query.bind( s );
            sql::bind( s, _expr );
        }

        template< typename... group_cols >
        group_by< where_clause, group_cols... > group_by() { return { *this }; }

        template< typename... ct, typename... et >
        order_clause< where_clause, ct..., et... > order_by( et... ex ) { return { *this, ex... }; }

        template< typename we_t >
        auto where( we_t we ) { return sql::where_clause( this->_query, _expr && we ); }

        auto exec() { return this->_exec( this ); }
    };

    template< typename select, typename... cols >
    struct group_by : extend< select >
    {
        using extend< select >::extend;
        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " group by ";
            print_columns( s, cons_list( cols()... ) );
        }

        template< typename we_t >
        where_clause< group_by, we_t > having( const we_t &we ) { return { *this, we, "having" }; }

        template< typename... ct, typename... et >
        order_clause< group_by, ct..., et... > order_by( et... ex ) { return { *this, ex... }; }
    };

    enum class join_type { inner, left, right };

    template< typename T >
    using underlying = std::conditional_t< T::is_view && T::columns::car_t::is_qualified &&
                                           T::columns::car_t::is_primary,
                                           typename T::columns::car_t::qualifier, T >;

    template< typename select, typename tab, typename on_t = brq::nil >
    struct select_join : extend< select >
    {
        join_type _type;
        on_t _join_on;

        using tables = brq::cons< tab, typename select::tables >;
        select_join( const select &s, join_type t = join_type::inner, on_t on = on_t() )
            : extend< select >( s ), _type( t ), _join_on( on )
        {}

        auto exec() { return this->_exec( this ); }

        template< typename stream, typename tabs_left = typename select::tables >
        void print( stream &s, int &id ) const
        {
            using tab_left = typename tabs_left::car_t;
            using tab_right = tab;

            using tab_left_u  = underlying< tab_left >;
            using tab_right_u = underlying< tab_right >;

            std::string foreign_column;
            std::string primary_column;

            auto find_foreign_left = [&]( auto t )
            {
                using col = unqualify< decltype( t ) >;
                if constexpr ( t.is_foreign )
                    if constexpr ( std::is_same_v< typename col::table, tab_left_u > )
                        foreign_column = col().column_name( col() );
            };

            auto find_foreign_right = [&]( auto t )
            {
                using col = unqualify< decltype( t ) >;
                if constexpr ( t.is_foreign )
                    if constexpr ( std::is_same_v< typename col::table, tab_right_u > )
                        foreign_column = col().column_name( col() );
            };

            auto find_primary = [&]( auto t )
            {
                if ( t.is_primary )
                {
                    if constexpr ( t.is_qualified )
                    {
                        using bare = typename decltype( t )::bare;
                        primary_column = bare().column_name( bare() );
                    }
                    else
                        primary_column = t.column_name( t );
                }
            };

            brq::string_builder cond;

            typename tab_right::columns().each( find_foreign_left );
            typename tab_left::columns().each( find_primary );

            if constexpr ( std::is_same_v< on_t, brq::nil > )
            {
                if ( !foreign_column.empty() && !primary_column.empty() )
                {
                    cond << get_name( tab_right() ) << "." << foreign_column
                         << " = " << get_name( tab_left() ) << "." << primary_column;
                }
                else
                {
                    primary_column = foreign_column = "";
                    typename tab_right::columns().each( find_primary );
                    typename tab_left::columns().each( find_foreign_right );

                    if ( !foreign_column.empty() && !primary_column.empty() )
                        cond << get_name( tab_left() ) << "." << foreign_column
                             << " = " << get_name( tab_right() ) << "." << primary_column;
                    else if constexpr ( !tabs_left::cdr_t::empty )
                        return print< stream, typename tabs_left::cdr_t >( s, id );
                    else
                        brq::raise< error >() << "could not find join key on "
                                              << get_name( tab_left() ) << " x "
                                              << get_name( tab_right() );
                }
            }

            this->_query.print( s, id );

            switch ( _type )
            {
                case join_type::inner: s << " inner"; break;
                case join_type::left: s << " left"; break;
                case join_type::right: s << " right"; break;
            }

            s << " join " << get_name( tab_right() ) << " on ";
            if constexpr ( std::is_same_v< on_t, brq::nil > )
                s << cond.buffer();
            else
                sql::print( s, _join_on, id );
        }

        template< typename expr_t >
        select_join< select, tab, expr_t > on( expr_t e ) { return { this->_query, _type, e }; }

        template< typename we_t >
        where_clause< select_join, we_t > where( const we_t &we ) { return { *this, we }; }

        template< typename table >
        select_join< select_join, table > join() const { return { *this }; }

        template< typename table >
        select_join< select_join, table > left_join() const { return { *this, join_type::left }; }

        template< typename table >
        select_join< select_join, table > right_join() const { return { *this, join_type::right }; }

        template< typename... group_cols >
        group_by< select_join, group_cols... > group_by() { return { *this }; }

        template< typename... ct, typename... et >
        order_clause< select_join, ct..., et... > order_by( et... ex ) { return { *this, ex... }; }

        sql::raw_sql< select_join > raw_sql( std::string_view sv ) { return { *this, sv }; }
    };

    template< typename query >
    struct raw_sql : extend< query >
    {
        raw_sql( const query &q, std::string_view sv ) : extend< query >( q ), _sql( sv ) {}
        std::string _sql;
        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " " << _sql;
        }

        template< typename table >
        select_join< raw_sql, table > join() const { return { *this }; }

        template< typename table >
        select_join< raw_sql, table > left_join() const { return { *this, join_type::left }; }

        template< typename table >
        select_join< raw_sql, table > right_join() const { return { *this, join_type::right }; }

        template< typename... group_cols >
        group_by< raw_sql, group_cols... > group_by() { return { *this }; }

        template< typename we_t >
        where_clause< raw_sql, we_t > where( const we_t &we ) { return { *this, we }; }

        template< typename... ct, typename... et >
        order_clause< raw_sql, ct..., et... > order_by( et... ex ) { return { *this, ex... }; }
    };

    template< typename head > auto sql_join( const head &q ) { return q; }

    template< typename join, typename... joins, typename head >
    auto sql_join( const head &q )
    {
        return sql_join< joins... >( q.template join< join >() );
    }

    template< typename select, typename tab >
    struct select_tab : extend< select >
    {
        using tables = brq::cons_list_t< tab >;
        using extend< select >::extend;
        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " from " << get_name( tab() );
        }

        template< typename table, typename... joins >
        auto join() const { return sql_join< joins... >( select_join< select_tab, table >( *this ) ); }

        template< typename table >
        select_join< select_tab, table > left_join() const { return { *this, join_type::left }; }

        template< typename table >
        select_join< select_tab, table > right_join() const { return { *this, join_type::right }; }

        template< typename... group_cols >
        sql::group_by< select_tab, group_cols... > group_by() { return { *this }; }

        template< typename we_t >
        where_clause< select_tab, we_t > where( const we_t &we ) { return { *this, we }; }

        template< typename... ct, typename... et >
        order_clause< select_tab, ct..., et... > order_by( et... ex ) { return { *this, ex... }; }

        sql::raw_sql< select_tab > raw_sql( std::string_view sv ) { return { *this, sv }; }
    };

    template< typename select, typename... views >
    struct select_with : extend< select >
    {
        brq::cons_list_t< views... > _views;
        using extend< select >::extend;
        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            int i = 0;
            auto fmt = [&]( auto v )
            {
                using view = decltype( v );
                s << ( i++ ? ", " : "with recursive " );
                s << get_name( v ) << " ";
                print_columns( s, typename view::columns::template map_t< unqualify >(), "( ", " )" );
                s << " as ( ";
                auto &txn = const_cast< select_with * >( this )->txn();
                view::construct( txn.select( typename view::columns() ) ).print( s, id );
                s << " )";
            };
            _views.each( fmt );
            this->_query.print( s, id );
        }

        template< typename table, typename... joins >
        auto from() { return sql_join< joins... >( select_tab< select_with, table >( *this ) ); }
    };

    template< typename... views, typename query > auto with( query q )
    {
        return select_with< query, views... >( q );
    };

    template< typename select, typename... cols >
    struct select_distinct : extend< select >
    {
        brq::cons_list_t< cols... > _cols;
        auto order_columns() const { return _cols; }
        using extend< select >::extend;
        auto exec() { return this->_exec( this ); }

        template< typename... et >
        select_distinct( const select &q, et... e ) : extend< select >( q ), _cols( e... ) {}

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            s << "select distinct ";
            if constexpr ( sizeof...( cols ) > 0 )
                s << " on ( ", sql::print( s, _cols, id ), s << " ) ";
            this->_query.print( s, id );
        }

        template< typename table, typename... joins >
        auto from() { return sql_join< joins... >( select_tab< select_distinct, table >( *this ) ); }

        template< typename... ct, typename... et >
        select_with< select_distinct, ct..., et... > with( et... e ) { return { *this, e... }; }
    };

    template< typename... cols >
    struct query_head : query_base
    {
        using stmt = sql::stmt< cols... >;
        sql::txn &_txn;
        sql::txn &txn() { return _txn; }
        sql::conn &conn();
        query_head( sql::txn &t ) : _txn( t ) {}
        brq::nil order_columns() const { return {}; }

        template< typename stmt >
        void bind( stmt & ) const {}
    };

    template< typename... cols >
    struct select_cols : query_head< cols... >
    {
        brq::cons_list_t< cols... > _cols;
        bool _distinct = false;

        template< typename... et >
        select_cols( sql::txn &t, et... e ) : query_head< cols... >( t ), _cols( e... ) {}

        template< typename... ct, typename... et >
        select_cols< cols..., ct..., et... > select( et... e )
        {
            return { this->_txn, _cols.cat( brq::cons_list( e... ) ) };
        }

        template< typename table, typename... joins >
        auto from() { return sql_join< joins... >( select_tab< select_cols, table >( *this ) ); }

        template< typename we_t >
        where_clause< select_cols, we_t > where( const we_t &we ) { return { *this, we }; }

        template< typename... ct, typename... et >
        select_distinct< select_cols, ct..., et... > distinct( et... e )
        {
            auto s = *this;
            s._distinct = true;
            return { s, e... };
        }

        template< typename... ct, typename... et >
        select_with< select_cols, ct..., et... > with( et... e )
        {
            return { *this, e... };
        }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            if ( !_distinct )
                s << "select ";
            sql::print( s, _cols, id );
        }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            _cols.each( [&]( const auto &c ) { sql::bind( s, c ); } );
        }

        sql::raw_sql< select_cols > raw_sql( std::string_view sv ) { return { *this, sv }; }
    };

    template< typename T, typename X = void >
    struct get_key { using type = X; };

    template< typename T >
    struct get_key< T, decltype( typename T::car_t(), void(0) ) >
    {
        using type = typename T::car_t::base;
    };

    template< typename T > constexpr bool is_str_v = std::is_same_v< T, const std::string & >;
    template< typename T > constexpr bool is_u32s_v = std::is_same_v< T, const std::u32string & >;
    template< bool C, typename A, typename B > using cond_t = std::conditional_t< C, A, B >;
    template< typename T > using to_u32v = cond_t< is_u32s_v< T >, std::u32string_view, T >;
    template< typename T > using to_view = cond_t< is_str_v< T >, std::string_view, to_u32v< T > >;

    template< typename insert, bool first, typename col, typename et >
    struct insert_update_set : extend< insert >
    {
        et _expr;

        insert_update_set( insert i, et e ) : extend< insert >( i ), _expr( e ) {}

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            if constexpr ( !first )
                s << ", ";
            s << col().column_name( col() );
            s << " = ";
            sql::print( s, _expr, id );
        }

        auto exec() { return this->_exec( this ); }
        template< typename stmt >
        void bind( stmt &s ) const
        {
            this->_query.bind( s );
            sql::bind( s, _expr );
        }

        template< typename col2, typename et2 >
        auto set( et2 e )
        {
            return insert_update_set< insert_update_set, false, col2, et2 >( *this, e );
        }
    };

    template< typename insert >
    struct insert_update : extend< insert >
    {
        using extend< insert >::extend;

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << "update set ";
        }

        template< typename cols, typename et >
        auto set( et e )
        {
            return insert_update_set< insert_update, true, cols, et >( *this, e );
        }
    };

    template< typename insert, typename... cols >
    struct conflict_clause : extend< insert >
    {
        using extend< insert >::extend;

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " on conflict ( ";
            print_columns( s, cons_list( cols()... ) );
            s << " ) do ";
        }
        insert_update< conflict_clause > update() { return { *this }; }
    };

    template< typename insert, typename... cols >
    struct insert_values : extend< insert >
    {
        using vals = brq::cons_list_t< typename cols::type... >;
        vals _vals;

        insert_values( insert i, typename cols::type... v )
            : extend< insert >( i ), _vals( std::move( v )... )
        {}

        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            s << "insert into " << get_name( typename insert::table() );
            cons_list_t< cols... > l;
            print_columns( s, l, "( ", " )" );
            s << " values";
            bool first = true;
            l.each( [&]( auto ) { s << ( first ? " ( " : ", " ) << "$" << id; id ++; first = false; } );
            s << " )";

            if ( this->_query._quiet )
                s << " on conflict do nothing";
            if constexpr ( !std::is_same_v< typename insert::primary_l, brq::nil > )
            {
                using primary = unqualify< typename insert::primary_l::car_t >;
                s << " returning " << primary().column_name( primary() );
            }
        }

        template< typename... ccols >
        conflict_clause< insert_values, ccols... > on_conflict() { return { *this }; }

        template< typename stmt >
        void bind( stmt &s ) const
        {
            s.bind_list( _vals );
        }
    };

    template< typename tbl >
    struct insert
    {
        sql::conn &_conn;
        bool _quiet = false;

        using table = tbl;
        using primary_l = decltype( typename table::columns().template filter< is_primary >() );
        using stmt = std::conditional_t< std::is_same_v< primary_l, brq::nil >, sql::stmt<>,
                                         sql::stmt< typename get_key< primary_l >::type > >;
        using order_columns = brq::nil;

        insert( sql::conn &c, bool q ) : _conn( c ), _quiet( q ) {}
        sql::conn &conn() { return _conn; }

        template< typename... cols >
        auto values( to_view< const typename cols::type & >... v )
        {
            return insert_values< insert, cols... >( *this, typename cols::type( v )... );
        }
    };

    template< typename update, typename... cols >
    struct update_set : extend< update >
    {
        auto exec() { return this->_exec( this ); }

        template< typename stmt >
        void bind( stmt &s ) const { this->_query.bind( s ); s.bind_list( _values ); }

        cons_list_t< typename cols::type... > _values;
        update_set( update u, const typename cols::type &... v )
            : extend< update >( u ), _values( v... )
        {}

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " set ";
            cons_list_t< cols... > list;
            auto fmt_update = [&]( auto col ) -> std::string
            {
                string_builder b;
                b << col.column_name( col ) << " = $" << id ++
                  << "::" << sql_type< typename decltype( col )::type >();
                return b.buffer();
            };
            print_list( s, list.map( fmt_update ) );
        }

        template< typename we_t >
        where_clause< update_set, we_t > where( const we_t &we ) { return { *this, we }; }
    };

    template< typename table >
    struct update : query_head<>
    {
        using query_head<>::query_head;

        template< typename stream >
        void print( stream &s, int & ) const
        {
            s << "update " << get_name( table() );
        }

        template< typename... cols >
        update_set< update, cols... > set( const typename cols::type &... v )
        {
            return { *this, v... };
        }
    };

    template< typename table >
    struct delete_from : query_head<>
    {
        using query_head<>::query_head;
        stmt exec() { return std::move( stmt( this->conn(), *this ).exec() ); }

        template< typename stream >
        void print( stream &s, int & ) const
        {
            s << "delete from " << get_name( table() );
        }

        template< typename we_t >
        where_clause< delete_from, we_t > where( const we_t &we ) { return { *this, we }; }
    };

    template< typename q_t, typename... qs_t >
    struct select_union : query_head<>
    {
        cons_list_t< q_t, qs_t... > qs;
        bool all = false;

        select_union( q_t q, qs_t... qs ) : query_head( q.txn() ), qs( q, qs... ) {}
        select_union( bool a, q_t q, qs_t... qs ) : select_union( q, qs... ) { all = a; }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            bool first = true;
            auto one = [&]( const auto &q )
            {
                if ( !first ) s << " union " << ( all ? "all " : "" );
                q.print( s, id );
                first = false;
            };
            qs.each( one );
        }
    };

    struct txn
    {
        sql::conn &_conn;
        bool _closed = true;

        explicit txn( sql::conn &conn ) : _conn( conn ) { open(); }

        void open()
        {
            if ( _closed )
            {
                _closed = false;
                exec( "begin transaction" );
            }
        }

        txn( txn&& rhs ) noexcept;

        txn() = delete;
        txn& operator=( const txn &rhs ) = delete;

        sql::conn &conn() { return _conn; }
        txn &commit()
        {
            if ( !_closed )
            {
                exec( "commit transaction" );
                _closed = true;
            }
            return *this;
        }

        txn &rollback() noexcept
        {
            if( !_closed )
            {
                exec( "rollback transaction" );
                _closed = true;
            }
            return *this;
        }

        struct savepoint
        {
            txn *_txn;
            std::string _name;

            savepoint( txn *t, std::string_view name ) : _txn( t ), _name( name )
            {
                _txn->exec( brq::format( "savepoint ", name ).buffer() );
            }

            ~savepoint()
            {
                DEBUG( "~savepoint", std::uncaught_exceptions() );
                if ( std::uncaught_exceptions() )
                    rollback();
            }

            void rollback()
            {
                _txn->exec( brq::format( "rollback to savepoint ", _name ).buffer() );
            }
        };

        savepoint save( std::string_view name = "save_except" )
        {
            return { this, name };
        }

        txn &exec( std::string_view q )
        {
            open();
            stmt<> s( _conn, q );
            s.exec();
            return *this;
        }

        template< typename... v >
        txn &exec( std::string q, v... vals )
        {
            open();
            stmt<> s( _conn, q );
            s.bind( vals... );
            s.exec();
            return *this;
        }

        struct autoexec : brq::string_builder
        {
            txn &_txn;
            autoexec( autoexec && ) = default;
            autoexec( txn &t ) : _txn( t ) {}
            ~autoexec() { if ( _buffer ) _txn.exec( _buffer ); }

            template< typename T >
            autoexec &operator<<( const T &x )
            {
                *static_cast< brq::string_builder * >( this ) << x;
                return *this;
            }
        };

        autoexec exec() { return { *this }; }

        template< typename t >
        std::enable_if_t< t::is_table > notify() { notify( get_name( t() ) ); }

        template< typename t >
        std::enable_if_t< t::is_table > listen() { exec() << "listen " << get_name( t() ); }

        txn &notify( std::string_view ch, std::string_view p = "" )
        {
            exec() << "notify " << ch << ", '" << p << "'";
            return *this;
        }

        void listen( std::string_view sv ) { exec() << "listen " << sv; }

        notification wait( std::optional< time_t > deadline = std::nullopt )
        {
            ASSERT( _closed ); /* waiting with an open transaction causes a deadlock */
            return _conn.wait( deadline );
        }

        template< typename schema >
        txn &initdb( schema s, bool clear = false );

        template< typename... ct, typename... et >
        select_cols< ct..., et... > select( et... e ) { open(); return { *this, ct()..., e... }; }

        template< typename... args >
        select_cols< args... > select( cons_list_t< args... > ) { open(); return { *this }; }

        template< typename table >
        insert< table > insert_into( bool quiet = false ) { open(); return { _conn, quiet }; }

        template< typename table >
        update< table > update() { open(); return { *this }; }

        template< typename table >
        delete_from< table > delete_from() { open(); return { *this }; }

        ~txn() noexcept { if ( !_closed ) rollback(); }
    };

    inline txn conn::begin() { return txn( *this ); }

    template< typename... Ts >
    inline conn &query_head< Ts... >::conn() { return _txn.conn(); }

    template< typename table >
    std::enable_if_t< table::is_table > drop( txn &t, table )
    {
        t.exec() << "drop table if exists " << get_name( table() ) << " cascade";
    };

    template< typename enum_t >
    std::enable_if_t< enum_t::is_enum > drop( txn &t, enum_t )
    {
        t.exec() << "drop type if exists \"" << get_name( enum_t(), 0 ) << "\" cascade";
    };

    template< typename view >
    std::enable_if_t< view::is_view > drop( txn &t, view, bool cascade = false )
    {
        t.exec() << "drop view if exists " << get_name( view() ) << ( cascade ? " cascade" : "" );
    };

    template< typename enum_t >
    std::enable_if_t< enum_t::is_enum > create( txn &txn, enum_t )
    {
        string_builder s;
        s << "create type " << get_name( enum_t() ) << " as enum";
        print_list( s, typename enum_t::values().map( [&]( auto c ) { return get_name( c, '\'' ); } ),
                    ", ", "(", ")" );
        txn.exec( s.buffer() );
    }

    template< typename table >
    std::enable_if_t< table::is_table > create( txn &txn, table, bool temp = false )
    {
        auto tabname = get_name( table() );
        auto tabunq = std::string( tabname.substr( 1, tabname.size() - 2 ) );
        txn.exec() << "create " << ( temp ? "temp " : "" ) << "table if not exists " << tabname << " ();";
        int c_num = 0;
        auto alter = [&] { return std::move( txn.exec() << "alter table " << tabname << " " ); };
        auto constraint = [&]
        {
            return std::move( alter() << "add constraint " << tabunq << "_c" << c_num++ << " " );
        };

        for ( int i = 0; i < 8; ++i )
            alter() << "drop constraint if exists " << tabunq << "_c" << i << " cascade";

        auto print_col = [&]( auto col )
        {
            using col_t = decltype( col );

            if constexpr ( col.is_constraint )
            {
                auto ex = std::move( constraint() << "unique " );
                print_columns( ex, typename col_t::columns(), "( ", " )" );
            }
            else
            {
                using type = typename col_t::base_type;
                bool use_serial = col.is_primary && std::is_same_v< type, int >;
                auto typestr = sql_type< type >();
                auto seqname = std::string( tabname.substr( 1, tabname.size() - 2 ) ) + "_pkey_seq";
                auto colname = col.column_name( col );

                alter() << "add column if not exists " << colname << " " << typestr
                        << " default '" << type() << "'"; /* TODO make configurable! */
                alter() << "alter column " << colname << " drop default";
                alter() << "alter column " << colname << " type " << typestr;

                if ( col.is_primary )
                    constraint() << "primary key ( " << colname << " )";

                if ( use_serial )
                {
                    txn.exec() << "create sequence if not exists " << seqname << " owned by "
                               << tabname << "." << colname;
                    alter() << "alter column " << colname << " set default nextval('" << seqname << "')";
                }

                if constexpr ( col.is_foreign )
                    if ( !temp )
                        constraint()
                            << "foreign key ( " << colname << " )"
                            << " references " << get_name( typename col_t::table() )
                            << " ( " << typename col_t::column().column_name( typename col_t::column() ) << " )";

                alter() << "alter column " << colname << " "
                        << ( col.is_nullable ? "drop" : "set" ) << " not null";
            }
        };
        typename table::all().each( print_col );
    };

    template< typename view, typename query >
    std::enable_if_t< view::is_view && query::is_query >
    create( txn &txn, view v, query q, bool as_temp = false )
    {
        string_builder s;
        int id = -1;
        s << ( as_temp ? "create temp table " : "create view " )
          << get_name( v ) << " ";
        using cols = typename view::columns::template map_t< unqualify >;
        if ( !cols::empty )
            print_columns( s, cols(), "( ", " )" );
        s << ( as_temp ? " on commit drop as " : " with ( security_barrier ) as " );

        q.print( s, id );

        if ( view::is_updatable )
            s << " with check option";
        txn.exec( s.buffer() );
    }

    template< typename view >
    std::enable_if_t< view::is_view && !view::columns::empty >
    create( txn &txn, view v, bool as_temp = false )
    {
        create( txn, v, view::construct( txn.select( typename view::columns() ) ), as_temp );
    }

    template< typename view >
    std::enable_if_t< view::is_view && view::columns::empty > create( txn &txn, view v )
    {
        create( txn, v, txn.select().where( false ) );
    }

    template< typename view >
    std::enable_if_t< view::is_view > materialize( txn &txn, view v )
    {
        std::string name( get_name( v ) );
        txn.exec( "create temp table " + name + " on commit drop as select * from " + name );
    }

    template< typename schema >
    txn &txn::initdb( schema s, bool clear )
    {
        if ( clear )
            s.reverse().each( [&]( auto t ) { drop( *this, t ); } );
        s.each( [&]( auto t ) { create( *this, t ); } );
        return *this;
    }

    template< typename stream, typename query >
    inline auto operator<<( stream &s, const query &st )
        -> std::enable_if_t< query::is_query, decltype( s << std::string() ) >
    {
        int id = 1;
        st.print( s, id );
        return s;
    }
}

namespace brq
{
    using sql_connection  = sql::conn;
    using sql_transaction = sql::txn;
    using sql_error       = sql::error;
    template< typename... args >
    using sql_schema      = sql::schema< args... >;
    template< typename... args >
    using sql_statement   = sql::stmt< args... >;
}


namespace std
{
    template< typename... cols >
    struct tuple_size< brq::sql::row< cols... > >
        : std::integral_constant< std::size_t, sizeof...( cols ) >
    {};

    template< typename col, typename... cols >
    struct tuple_element< 0, brq::sql::row< col, cols... > >
    {
        using type = typename col::type;
    };

    template< size_t I, typename col, typename... cols >
    struct tuple_element< I, brq::sql::row< col, cols... > >
        : tuple_element< I - 1, brq::sql::row< cols... > >
    {};
}
