// -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4 -*-

/*
 * (c) 2014-2018 Vladimír Štill
 * (c) 2014, 2015 Petr Ročkai
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef BRICKS_HAVE_LLVM

#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS
#endif
#ifndef __STDC_CONSTANT_MACROS
#define __STDC_CONSTANT_MACROS
#endif

#ifdef DIVINE_RELAX_WARNINGS
DIVINE_RELAX_WARNINGS
#endif

#include <llvm/IR/Module.h>
#include <llvm/IR/Verifier.h>
#include <llvm/IR/Constants.h>
#include <llvm/Bitcode/BitcodeWriter.h>
#include <llvm/Support/raw_ostream.h>
#include <llvm/Support/raw_os_ostream.h>
#include <llvm/Support/Error.h>
#include <llvm/Support/FileSystem.h>

#ifdef DIVINE_RELAX_WARNINGS
DIVINE_UNRELAX_WARNINGS
#endif

#include <brick-assert>
#include <brick-string>
#include <brick-types>
#include <brick-fs>

#ifndef BRICK_LLVM_H
#define BRICK_LLVM_H

namespace brick::llvm {

struct Annotation : brick::types::Eq {
    Annotation() = default;
    explicit Annotation( std::string anno ) {
        size_t oldoff = 0, off = 0;
        do {
            off = anno.find( '.', oldoff );
            _parts.emplace_back( anno.substr( oldoff, off - oldoff) );
            oldoff = off + 1;
        } while ( off != std::string::npos );
    }
    template< typename It >
    Annotation( It begin, It end ) : _parts( begin, end ) { }

    std::string name() { return _parts.back(); }
    Annotation ns() { return Annotation( _parts.begin(), _parts.end() - 1); }
    std::string toString() {
        std::stringstream ss;
        for ( auto &n : _parts )
            ss << n << ".";
        auto str = ss.str();
        return str.substr( 0, str.size() - 1 );
    }

    bool inNamespace( Annotation ns ) {
        return ns._parts.size() < _parts.size()
            && std::equal( ns._parts.begin(), ns._parts.end(), _parts.begin() );
    }

    Annotation dropNamespace( Annotation ns ) {
        return inNamespace( ns )
             ? Annotation( _parts.begin() + ns.size(), _parts.end() )
             : *this;
    }

    size_t size() const { return _parts.size(); }

    bool operator==( const Annotation &o ) const {
        return o.size() == size() && std::equal( _parts.begin(), _parts.end(), o._parts.begin() );
    }

  private:
    std::vector< std::string > _parts;
};

template< typename Yield >
void enumerateFunctionAnnos( ::llvm::Module &m, Yield yield ) {
    auto annos = m.getNamedGlobal( "llvm.global.annotations" );
    if ( !annos )
        return;
    auto a = ::llvm::cast< ::llvm::ConstantArray >( annos->getOperand(0) );
    for ( int i = 0; i < int( a->getNumOperands() ); i++ ) {
        auto e = ::llvm::cast< ::llvm::ConstantStruct >( a->getOperand(i) );
        if ( auto fn = ::llvm::dyn_cast< ::llvm::Function >( e->getOperand(0)->getOperand(0) ) ) {
            std::string anno = ::llvm::cast< ::llvm::ConstantDataArray >(
                        ::llvm::cast< ::llvm::GlobalVariable >(
                            e->getOperand(1)->getOperand(0) )->getOperand(0)
                    )->getAsCString();
            yield( fn, Annotation( anno ) );
        }
    }
}

template< typename Yield >
void enumerateFunctionAnnosInNs( Annotation ns, ::llvm::Module &m, Yield yield ) {
    enumerateFunctionAnnos( m, [&]( ::llvm::Function *fn, Annotation anno ) {
            if ( anno.inNamespace( ns ) )
                yield( fn, anno.dropNamespace( ns ) );
        } );
}

template< typename Yield >
void enumerateFunctionsForAnno( Annotation anno, ::llvm::Module &m, Yield yield ) {
    enumerateFunctionAnnos( m, [&]( ::llvm::Function *fn, Annotation a ) {
            if ( a == anno )
                yield( fn );
        } );
}

template< typename Yield >
void enumerateFunctionsForAnno( std::string anno, ::llvm::Module &m, Yield yield ) {
    enumerateFunctionsForAnno( Annotation( anno ), m, yield );
}

inline void verifyModule( ::llvm::Module *module ) {
    std::string err;
    ::llvm::raw_string_ostream serr( err );
    if ( ::llvm::verifyModule( *module, &serr ) ) {
        throw std::runtime_error( "Invalid bitcode: " + serr.str() );
    }
}

static void _throwLLVMError( std::error_code ec )
{
    throw std::runtime_error( "LLVM Error: " + ec.message() );
}

static void _throwLLVMError( ::llvm::Error &e )
{
    throw std::runtime_error( "LLVM Error: " + toString( std::move( e ) ) );
}

inline void writeModule( ::llvm::Module *m, std::string out ) {
    verifyModule( *m );
    std::error_code serr;
    brick::fs::mkFilePath( out );
    ::llvm::raw_fd_ostream fs( out.c_str(), serr, ::llvm::sys::fs::F_None );
    if ( serr )
        _throwLLVMError( serr );
    WriteBitcodeToFile( m, fs );
}

inline std::string getModuleBytes( ::llvm::Module *m ) {
    std::string s;
    verifyModule( *m );
    {
        ::llvm::raw_string_ostream fs( s );
        WriteBitcodeToFile( m, fs );
    }
    return s;
}

} // namespace brick::llvm

#endif // BRICK_LLVM_H

#endif // BRICKS_HAVE_LLVM

// vim: syntax=cpp tabstop=4 shiftwidth=4 expandtab ft=cpp
