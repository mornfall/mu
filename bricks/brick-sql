// -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4 -*-

/*
 * Copyright (C) 2019 Petr Rockai <code@fixp.eu>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#pragma once
#include "brick-assert"
#include "brick-cons"
#include "brick-except"

#include <memory>
#include <vector>
#include <cxxabi.h>
#include <codecvt>
#include <endian.h> /* beNNtoh / htobeNN */

#include <libpq-fe.h>

namespace brq::sql
{
    struct error : std::runtime_error
    {
        using std::runtime_error::runtime_error;
    };

    template< typename T >
    std::string_view get_name( T t, char quote = '"' )
    {
        static std::string name;
        if ( name.empty() )
        {
            int stat;
            char *dem = abi::__cxa_demangle( typeid( T ).name(), nullptr, nullptr, &stat );
            name = strchr( dem, ':' ) ? strrchr( dem, ':' ) + 1 : dem;
            TRACE( dem, "â†’", name );
            std::free( dem );
            if ( quote )
                name = quote + name + quote;
        }
        return name;
    }

    struct date { std::int16_t year, month, day; };
    struct time { std::int16_t hour, min, sec; };
    struct timestamp
    {
        std::int64_t fract;

        static timestamp from_unix( time_t t )
        {
            return { ( int64_t( t ) - 946684800 ) * 1000000 };
        }

        time_t to_unix() const
        {
            return fract / 1000000 + 946684800;
        }

        struct tm to_localtime() const
        {
            struct tm tm;
            auto t = to_unix();
            localtime_r( &t, &tm );
            return tm;
        }
    };

    struct interval
    {
        std::int64_t seconds; std::int32_t days, months;
        time_t as_seconds()
        {
            ASSERT_EQ( months, 0 );
            return time_t( days ) * 3600 * 24 + seconds / 1000000;
        }
    };

    template< typename T >
    struct enum_value
    {
        using type = T;
        static constexpr bool is_enum = true;
        static constexpr bool is_column = false;
        static constexpr bool is_query = false;
    };

    template< typename... vals >
    struct enum_type
    {
        using values = cons_list_t< vals... >;
        static constexpr bool is_enum  = true;
        static constexpr bool is_table = false;
        static constexpr bool is_view  = false;

        typename values::co _value;
        template< typename X >
        enum_type( const X &x ) : _value( x ) {}
        enum_type() = default;
    };

    template< typename T, typename = void > struct type_map {};
    template<> struct type_map< bool >           { static auto name() { return "bool"; } };
    template<> struct type_map< short >          { static auto name() { return "smallint"; } };
    template<> struct type_map< int >            { static auto name() { return "integer"; } };
    template<> struct type_map< long >           { static auto name() { return "bigint"; } };
    template<> struct type_map< std::u32string > { static auto name() { return "text"; } };
    template<> struct type_map< std::string >    { static auto name() { return "bytea"; } };
    template<> struct type_map< const char * >   { static auto name() { return "bytea"; } };
    template<> struct type_map< date >           { static auto name() { return "date"; } };
    template<> struct type_map< time >           { static auto name() { return "time"; } };
    template<> struct type_map< timestamp >      { static auto name() { return "timestamp"; }; };
    template<> struct type_map< interval >       { static auto name() { return "interval"; }; };

    template< int v > struct type_map< std::array< uint8_t, v > >
    {
        static auto name() { return "bytea"; }
    };

    template< typename T > struct type_map< T, std::enable_if_t< T::is_enum > >
    {
        static auto name() { return get_name( T(), 0 ); }
    };

    template< typename T > struct type_map< T, std::enable_if_t< T::type::is_enum > >
    {
        static auto name() { return get_name( typename T::type(), 0 ); }
    };

    template< typename T > auto sql_type()
    {
        return brq::sql::type_map< T >::name();
    }

    template< typename T, bool _nullable = false >
    struct column
    {
        template< typename CT >
        static std::string_view column_name( const CT &ct ) { return get_name( ct ); }

        using type = T;
        static constexpr bool is_nullable = _nullable;
        static constexpr bool is_primary = false;
        static constexpr bool is_foreign = false;
        static constexpr bool is_constraint = false;

        static constexpr bool is_expr = true;
        static constexpr bool is_column = true;
        static constexpr bool is_query = false;
        static constexpr bool is_enum = false;
    };

    template< typename T >
    struct constant : column< T, false >
    {
        template< typename CT >
        static std::string_view column_name( const CT &ct )
        {
            static std::string n = std::string( get_name( ct, false ) ) + "::" + sql_type< T >();
            return n;
        }
    };

    template< typename tab, typename col >
    struct in_table : col
    {
        using table = tab;

        template< typename CT >
        static std::string_view column_name( const CT &ct )
        {
            static auto name = std::string( get_name( table() ) ) +
                               "." + std::string( col().column_name( col() ) );
            return name;
        }
    };

    template< typename col >
    struct max : col
    {
        template< typename CT >
        static std::string_view column_name( const CT &ct )
        {
            static auto name = std::string( "max( " ) +
                               std::string( col().column_name( col() ) ) + " )";
            return name;
        }
    };

    template< typename col >
    struct count : col
    {
        template< typename CT >
        static std::string_view column_name( const CT &ct )
        {
            static auto name = std::string( "count( " ) +
                std::string( col().column_name( col() ) ) + " )::integer";
            return name;
        }

        using type = int32_t;
    };


    template< typename tab, typename col, bool _nullable = false >
    struct foreign_key : col
    {
        using column = col;
        using table = tab;
        static constexpr bool is_nullable = _nullable;
        static constexpr bool is_foreign = true;
    };

    template< typename col >
    struct primary_key : col
    {
        template< typename CT >
        static std::string_view column_name( const CT & ) { return get_name( col() ); }

        using base = col;
        static constexpr bool is_primary = true;
    };

    template< typename... cols >
    struct unique
    {
        using columns = cons_list_t< cols... >;
        static constexpr bool is_constraint = true;
        static constexpr bool is_table = false;
    };

    template< typename T >
    struct not_constraint { static constexpr bool value = !T::is_constraint; };
    template< typename T >
    struct is_primary { static constexpr bool value = T::is_primary; };

    template< typename... cols >
    struct table
    {
        using all = cons_list_t< cols... >;
        using columns = decltype( all().template filter< not_constraint >() );
        static constexpr bool is_table = true;
        static constexpr bool is_view  = false;
    };

    template< typename... cols >
    struct view
    {
        using columns = cons_list_t< cols... >;
        static constexpr bool is_table = false;
        static constexpr bool is_view  = true;
    };

    template< typename... tables_ >
    struct schema : cons_list_t< tables_... > {};

    struct txn;

    struct conn
    {
        PGconn *_handle = nullptr;
        PGconn *handle() { return _handle; }

        const char *errmsg() { return PQerrorMessage( _handle ); }

        conn( std::string s )
        {
            if ( !( _handle = PQconnectdb( s.c_str() ) ) )
                throw std::bad_alloc();
            if ( PQstatus( _handle ) != CONNECTION_OK )
                raise< error >() << "connecting to " << s << " " << errmsg();
        }

        ~conn()
        {
            PQfinish( _handle );
        }

        txn begin();
    };

    template< typename... cols >
    struct row
    {
        using columns_t = brq::cons_list_t< cols... >;
        using values_t  = brq::cons_list_t< typename cols::type... >;
        values_t _values;

        row() = default;
        row( typename cols::type... v ): _values( v... ) {}

        template< typename col, typename cs_t, typename vs_t >
        auto &get( vs_t &vs )
        {
            if constexpr ( std::is_same_v< col, typename cs_t::car_t > )
                return vs.car;
            else
                return get< col, typename cs_t::cdr_t >( vs.cdr );
        }

        template< typename col >
        auto &get() { return get< col, columns_t >( _values ); }
    };

    template< typename... cols >
    struct iterator
    {
        PGresult *_result;
        int _row = 0, _col = 0;

        bool operator==( const iterator &o ) const { return o._result == _result && o._row == _row; }
        bool operator!=( const iterator &o ) const { return !( *this == o ); }

        iterator( PGresult *res, int row ) : _result( res ), _row( row ) {}
        iterator &operator++() { ++_row; _col = 0; return *this; }
        iterator operator++( int ) { auto r = *this; ++ (*this); return r; }

        template< typename T >
        void fetch_raw( T &t )
        {
            ASSERT( !PQgetisnull( _result, _row, _col ) );
            std::memcpy( &t, PQgetvalue( _result, _row, _col ), sizeof( T ) );
        }

        void fetch_one( int16_t &t ) { fetch_raw( t ); t = be16toh( t ); }
        void fetch_one( int32_t &t ) { fetch_raw( t ); t = be32toh( t ); }
        void fetch_one( timestamp &t ) { fetch_raw( t.fract ); t.fract = be64toh( t.fract ); }

        void fetch_one( interval &i )
        {
            fetch_raw( i );
            i.seconds = be64toh( i.seconds );
            i.days    = be32toh( i.days );
            i.months  = be32toh( i.months );
        }

        void fetch_one( std::u32string &us )
        {
            const char *data = PQgetvalue( _result, _row, _col );
            std::wstring_convert< std::codecvt_utf8< char32_t >, char32_t > conv;
            us = conv.from_bytes( data, data + PQgetlength( _result, _row, _col ) );
        }

        void fetch_one( std::string &s )
        {
            const char *data = PQgetvalue( _result, _row, _col );
            s = std::string( data, data + PQgetlength( _result, _row, _col ) );
        }

        row< cols... > operator*()
        {
            row< cols... > r;
            r._values.each( [&]( auto &v ) { fetch_one( v ); ++ _col; } );
            return r;
        }
    };

    template< typename... cols >
    struct stmt
    {
        using result_t = row< cols... >;

        conn &_conn;
        std::string _txt;

        std::vector< std::unique_ptr< char[] > > _memory;
        std::vector< const char * > _params;
        std::vector< int > _lengths;
        PGresult *_result = nullptr;

        using iterator = sql::iterator< cols... >;
        iterator begin() { return iterator( _result, 0 ); }
        iterator end()   { return iterator( _result, PQntuples( _result ) ); }

        void bind_mem( const char *data, int size )
        {
            _lengths.push_back( size );
            _memory.emplace_back( new char[ size ] );
            std::memcpy( _memory.back().get(), data, size );
            _params.push_back( _memory.back().get() );
        }

        void bind_mem( const uint8_t *data, int size )
        {
            bind_mem( reinterpret_cast< const char * >( data ), size );
        }

        template< typename T >
        stmt( conn &c, const T &t ) : _conn( c )
        {
            string_builder bld;
            bld << t;
            _txt = bld.buffer();
        }

        stmt( const stmt & ) = delete;
        stmt( stmt && ) = default;

        template< typename T >
        void bind_raw( const T &t ) { bind_mem( reinterpret_cast< const char * >( &t ), sizeof( T ) ); }

        void bind_one( interval &i )
        {
            i.seconds = htobe64( i.seconds );
            i.days = htobe64( i.days );
            i.months = htobe64( i.months );
            bind_raw( i );
        }
        void bind_one( timestamp &t ) { t.fract = htobe64( t.fract ); bind_raw( t ); }
        void bind_one( int64_t &t ) { t = htobe64( t ); bind_raw( t ); }
        void bind_one( int32_t &t ) { t = htobe32( t ); bind_raw( t ); }
        void bind_one( int16_t &t ) { t = htobe16( t ); bind_raw( t ); }
        void bind_one( const std::string &s ) { bind_mem( s.data(), s.size() ); }
        void bind_one( std::u32string &us )
        {
            std::wstring_convert< std::codecvt_utf8< char32_t >, char32_t > conv;
            auto str = conv.to_bytes( &*us.begin(), &*us.end() );
            bind_mem( str.data(), str.size() );
        }

        template< size_t n >
        void bind_one( const std::array< uint8_t, n > &s ) { bind_mem( s.begin(), s.size() ); }

        template< typename T >
        std::enable_if_t< T::is_enum > bind_one( T v )
        {
            v._value.match( [&]( auto x ) { bind_one( std::string( get_name( x, 0 ) ) ); } );
        }

        stmt &exec()
        {
            std::vector< int > formats( _params.size(), 1 );

            TRACE( "exec:", _txt );
            _result = PQexecParams( _conn.handle(), _txt.c_str(), _params.size(), nullptr,
                                    _params.data(), _lengths.data(), formats.data(), 1 );

            auto r = PQresultStatus( _result );
            if ( r != PGRES_COMMAND_OK && r != PGRES_TUPLES_OK )
                raise< error >() << "executing " << _txt << ": " << _conn.errmsg();

            return *this;
        }

        template< typename list_t >
        stmt &bind_list( list_t list )
        {
            int count = 0;
            list.each( [&]( auto ) { ++count; } );
            _params.reserve( count );
            _memory.reserve( count );

            list.each( [&]( auto &v ) { bind_one( v ); } );
            return *this;
        }

        template< typename... args >
        stmt &bind( const args &... vs )
        {
            return bind_list( cons_list( vs... ) );
        }

        stmt( conn &c, const std::string &s ) : _conn( c ), _txt( s ) {}
    };

    template< typename T, typename = void > struct is_expr : std::false_type {};
    template< typename T > struct is_expr< T, std::enable_if_t< T::is_expr > > : std::true_type {};
    template< typename T > struct is_expr< T, std::enable_if_t< T::is_enum > > : std::true_type {};
    template< typename T > constexpr bool is_expr_v = is_expr< T >::value;

    template< typename... args >
    struct where_expr
    {
        static constexpr bool is_expr = true;
        static constexpr bool is_column = false;
        static constexpr bool is_query = false;
        static constexpr bool is_enum = false;

        const char *_op;
        cons_list_t< args... > _args;

        template< typename... Ts >
        where_expr( const char *op, Ts && ... ts )
            : _op( op ), _args( ts... )
        {}

        where_expr() = default;

        auto values( nil ) const { return nil(); }

        template< typename T >
        static constexpr bool is_value = std::is_convertible_v< T, std::string_view > ||
                                         std::is_convertible_v< T, std::u32string_view > ||
                                         std::is_convertible_v< T, timestamp > ||
                                         std::is_convertible_v< T, int >;

        template< typename L >
        auto values( const L &l ) const
        {
            if constexpr ( is_value< typename L::car_t > )
                return make_cons( l.car, values( l.cdr ) );
            else if constexpr ( L::car_t::is_column || L::car_t::is_query || L::car_t::is_enum ||
                                is_list_v< typename L::car_t > )
                return values( l.cdr );
            else
                return l.car.values().cat( values( l.cdr ) );
        }

        auto values() const { return values( _args ); }

        template< typename stream, typename V >
        void print( stream &s, const V &v, int &id ) const
        {
            if constexpr ( is_value< V > )
                s << "$" << id++ << "::" << sql_type< V >();
            else if constexpr ( is_list_v< V > )
                print_columns( s, v, "(", ")" );
            else if constexpr ( V::is_column )
                s << v.column_name( v );
            else if constexpr ( V::is_query )
                s << "( " << v << " )";
            else if constexpr ( V::is_enum )
                s << get_name( v, '\'' );
            else
                v.print( s, id );
        }

        template< typename stream >
        stream &print( stream &s, int &id ) const
        {
            switch ( sizeof...( args ) )
            {
                case 1:
                    s << _op << "( ";
                    print( s, _args.car, id );
                    return s << " )";
                case 2:
                    s << "( ";
                    print( s, _args.car, id );
                    s << " " << _op << " ";
                    print( s, _args.cdr.car, id );
                    return s << " )";
            }
        }
    };

    template< typename T >
    using unarray_t = std::conditional_t< std::is_array_v< T >, std::remove_extent_t< T > *, T >;

#define BRICK_SQL_OP_(op, sql)                                                      \
    template< typename A, typename B >                                              \
    auto op( A &&a, B &&b )                                             \
        -> std::enable_if_t< is_expr_v< std::decay_t< A > > || is_expr_v< std::decay_t< B > >, \
                             where_expr< std::decay_t< A >, std::decay_t< B > > > \
    {                                                                               \
        return { sql, a, b };                                                       \
    }

#define BRICK_SQL_OP(op) BRICK_SQL_OP_(operator op, #op)

BRICK_SQL_OP_( operator ==, "=" )
BRICK_SQL_OP_( operator %=, "like" )
BRICK_SQL_OP_( operator &&, "and" )
BRICK_SQL_OP_( operator ||, "or" )
BRICK_SQL_OP_( operator ^, "#" )
BRICK_SQL_OP_( pow, "^" )
BRICK_SQL_OP_( in, "in" )

BRICK_SQL_OP( < )
BRICK_SQL_OP( > )
BRICK_SQL_OP( <= )
BRICK_SQL_OP( >= )
BRICK_SQL_OP( != )
BRICK_SQL_OP( + )
BRICK_SQL_OP( - )
BRICK_SQL_OP( * )
BRICK_SQL_OP( / )
BRICK_SQL_OP( % )
BRICK_SQL_OP( & )
BRICK_SQL_OP( | )

#undef BRICK_SQL_OP

    struct query_base
    {
        static constexpr bool is_column = false;
        static constexpr bool is_query = true;
        static constexpr bool is_expr = true;
        static constexpr bool is_enum = false;
    };

    template< typename query >
    struct extend : query_base
    {
        using stmt = typename query::stmt;
        query _query;
        conn &conn() { return _query.conn(); }
        extend( query q ) : _query( q ) {}

        void bind( stmt &s ) { _query.bind( s ); }

        template< typename T >
        stmt _exec( T *t )
        {
            stmt s( t->conn(), *t );
            t->bind( s );
            s.exec();
            return s;
        }
    };

    template< typename stream, typename list >
    void print_list( stream &s, list l,
                     const char *delim = ", ", const char *start = "", const char *end = "" )
    {
        bool first = true;
        l.each( [&]( const auto &c ) { s << ( first ? start : delim ) << c; first = false; } );
        s << end;
    }

    template< typename stream, typename list >
    void print_columns( stream &s, list l, const char *start = "", const char *end = "" )
    {
        print_list( s, l.map( [&]( auto c ) { return c.column_name( c ); } ), ", ", start, end );
    }

    template< typename select, typename... cols >
    struct group_by : extend< select >
    {
        using extend< select >::extend;
        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " group by ";
            print_columns( s, cons_list( cols()... ) );
        }
    };

    template< typename query, typename expr >
    struct where_clause : extend< query >
    {
        expr _expr;
        where_clause( query q, const expr &e ) : extend< query >( q ), _expr( e ) {}

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " where ";
            _expr.print( s, id );
        }

        template< typename... group_cols >
        group_by< where_clause, group_cols... > group_by() { return { *this }; }

        auto exec() { return this->_exec( this ); }
        void bind( typename query::stmt &s )
        {
            this->_query.bind( s );
            s.bind_list( _expr.values() );
        }
    };

    template< typename select, typename tab >
    struct select_join : extend< select >
    {
        using table = tab;
        using extend< select >::extend;
        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            using tab_left = typename select::table;
            using tab_right = tab;

            std::string foreign_column;
            std::string primary_column;

            auto find_foreign_left = [&]( auto t )
            {
                if constexpr ( t.is_foreign )
                    if constexpr ( std::is_same_v< typename decltype( t )::table, tab_left > )
                        foreign_column = t.column_name( t );
            };

            auto find_foreign_right = [&]( auto t )
            {
                if constexpr ( t.is_foreign )
                    if constexpr ( std::is_same_v< typename decltype( t )::table, tab_right > )
                        foreign_column = t.column_name( t );
            };

            auto find_primary = [&]( auto t )
            {
                if ( t.is_primary )
                    primary_column = t.column_name( t );
            };

            this->_query.print( s, id );
            s << " join " << get_name( tab_right() ) << " on ";

            typename tab_right::columns().each( find_foreign_left );
            typename tab_left::columns().each( find_primary );

            if ( !foreign_column.empty() && !primary_column.empty() )
            {
                s << get_name( tab_right() ) << "." << foreign_column
                  << " = " << get_name( tab_left() ) << "." << primary_column;
            }
            else
            {
                typename tab_right::columns().each( find_primary );
                typename tab_left::columns().each( find_foreign_right );

                s << get_name( tab_left() ) << "." << foreign_column
                  << " = " << get_name( tab_right() ) << "." << primary_column;
            }
        }

        template< typename we_t >
        where_clause< select_join, we_t > where( const we_t &we ) { return { *this, we }; }

        template< typename table >
        select_join< select_join, table > join() { return { *this }; }

        template< typename... group_cols >
        group_by< select_join, group_cols... > group_by() { return { *this }; }
    };

    template< typename select, typename tab >
    struct select_tab : extend< select >
    {
        using table = tab;
        using extend< select >::extend;
        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " from " << get_name( tab() );
        }

        template< typename table >
        select_join< select_tab, table > join() { return { *this }; }

        template< typename... group_cols >
        group_by< select_tab, group_cols... > group_by() { return { *this }; }

        template< typename we_t >
        where_clause< select_tab, we_t > where( const we_t &we ) { return { *this, we }; }
    };

    template< typename select, typename... cols >
    struct select_distinct : extend< select >
    {
        using extend< select >::extend;
        auto exec() { return this->_exec( this ); }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " distinct ";
            if ( sizeof...( cols ) > 0 )
                s << " on ", print_columns( s, cons_list( cols()... ) );
        }

        template< typename table >
        select_tab< select_distinct, table > from() { return { *this }; }
    };

    template< typename... cols >
    struct query_head : query_base
    {
        using stmt = stmt< cols... >;
        txn &_txn;
        txn &txn() { return _txn; }
        conn &conn();
        query_head( sql::txn &t ) : _txn( t ) {}
        void bind( stmt & ) {}
    };

    template< typename... cols >
    struct select_cols : query_head< cols... >
    {
        using query_head< cols... >::query_head;

        template< typename table >
        select_tab< select_cols, table > from() { return { *this }; }

        template< typename... distinct_cols >
        select_distinct< select_cols, distinct_cols... > distinct() { return { *this }; }

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            s << "select ";
            print_columns( s, cons_list( cols()... ) );
        }
    };

    template< typename T, typename X = void >
    struct get_key { using type = X; };

    template< typename T >
    struct get_key< T, decltype( typename T::car_t(), void(0) ) >
    {
        using type = typename T::car_t::base;
    };

    template< typename table >
    struct insert
    {
        conn &_conn;
        bool _quiet = false;

        using primary_l = decltype( typename table::columns().template filter< is_primary >() );
        using stmt = std::conditional_t< std::is_same_v< primary_l, brq::nil >, sql::stmt<>,
                                         sql::stmt< typename get_key< primary_l >::type > >;
        insert( conn &c, bool q ) : _conn( c ), _quiet( q ) {}

        template< typename... cols >
        stmt values( const typename cols::type &... v )
        {
            string_builder bld;
            bld << "insert into " << get_name( table() );
            cons_list_t< cols... > l;
            bool first = true;
            l.each( [&]( auto &col )
            {
                bld << ( first ? " ( " : ", " ) << col.column_name( col ); first = false;
            } );
            bld << " ) values";
            int i = 1;
            l.each( [&]( auto ) { bld << ( i == 1 ? " ( " : ", " ) << "$" << i; i ++; } );
            bld << " )";
            if ( _quiet )
                bld << " on conflict do nothing";
            if constexpr ( !std::is_same_v< primary_l, brq::nil > )
            {
                using primary = typename primary_l::car_t;
                bld << " returning " << primary().column_name( primary() );
            }
            stmt s( _conn, bld.buffer() );
            s.bind( v... );
            return s;
        }
    };

    template< typename update, typename... cols >
    struct update_set : extend< update >
    {
        auto exec() { return this->_exec( this ); }
        void bind( typename update::stmt &s ) { this->_query.bind( s ); s.bind_list( _values ); }

        cons_list_t< typename cols::type... > _values;
        update_set( update u, const typename cols::type &... v )
            : extend< update >( u ), _values( v... )
        {}

        template< typename stream >
        void print( stream &s, int &id ) const
        {
            this->_query.print( s, id );
            s << " set ";
            cons_list_t< cols... > list;
            auto fmt_update = [&]( auto col ) -> std::string
            {
                string_builder b;
                b << col.column_name( col ) << " = $" << id ++
                  << "::" << sql_type< typename decltype( col )::type >();
                return b.buffer();
            };
            print_list( s, list.map( fmt_update ) );
        }

        template< typename we_t >
        where_clause< update_set, we_t > where( const we_t &we ) { return { *this, we }; }
    };

    template< typename table >
    struct update : query_head<>
    {
        using query_head<>::query_head;

        template< typename stream >
        void print( stream &s, int & ) const
        {
            s << "update " << get_name( table() );
        }

        template< typename... cols >
        update_set< update, cols... > set( const typename cols::type &... v )
        {
            return { *this, v... };
        }
    };

    template< typename table >
    struct delete_from : query_head<>
    {
        using query_head<>::query_head;

        template< typename stream >
        void print( stream &s, int & ) const
        {
            s << "delete from " << get_name( table() );
        }

        template< typename we_t >
        where_clause< delete_from, we_t > where( const we_t &we ) { return { *this, we }; }
    };

    struct txn
    {
        conn &_conn;
        bool _closed = true;

        explicit txn( conn &conn ) : _conn( conn ) { open(); }

        void open()
        {
            if ( _closed )
            {
                _closed = false;
                exec( "begin transaction" );
            }
        }

        txn( txn&& rhs ) noexcept;

        txn() = delete;
        txn& operator=( const txn &rhs ) = delete;

        conn &conn() { return _conn; }
        txn &commit()
        {
            ASSERT( !_closed );
            exec( "commit transaction" );
            _closed = true;
            return *this;
        }

        txn &rollback() noexcept
        {
            ASSERT( !_closed );
            exec( "rollback transaction" );
            _closed = true;
            return *this;
        }

        txn &exec( std::string q )
        {
            open();
            stmt<> s( _conn, q );
            s.exec();
            return *this;
        }

        struct autoexec : brq::string_builder
        {
            txn &_txn;
            autoexec( txn &t ) : _txn( t ) {}
            ~autoexec() { _txn.exec( buffer() ); }
        };

        autoexec exec() { return { *this }; }

        template< typename schema >
        txn &initdb( schema s, bool clear = false );

        template< typename... args >
        select_cols< args... > select() { open(); return { *this }; }

        template< typename... args >
        select_cols< args... > select( cons_list_t< args... > ) { open(); return { *this }; }

        template< typename table >
        insert< table > insert_into( bool quiet = false ) { open(); return { _conn, quiet }; }

        template< typename table >
        update< table > update() { open(); return { *this }; }

        template< typename table >
        delete_from< table > delete_from() { open(); return { *this }; }

        ~txn() noexcept { if ( !_closed ) rollback(); }
    };

    inline txn conn::begin() { return txn( *this ); }

    template< typename... Ts >
    inline conn &query_head< Ts... >::conn() { return _txn.conn(); }

    template< typename table >
    std::enable_if_t< table::is_table > drop( txn &t, table )
    {
        t.exec() << "drop table if exists " << get_name( table() ) << " cascade";
    };

    template< typename enum_t >
    std::enable_if_t< enum_t::is_enum > drop( txn &t, enum_t )
    {
        t.exec() << "drop type if exists " << get_name( enum_t() ) << " cascade";
    };

    template< typename view >
    std::enable_if_t< view::is_view > drop( txn &t, view )
    {
        t.exec() << "drop view if exists " << get_name( view() ) << " cascade";
    };

    template< typename enum_t >
    std::enable_if_t< enum_t::is_enum > create( txn &txn, enum_t )
    {
        string_builder s;
        s << "create type " << get_name( enum_t() ) << " as enum";
        print_list( s, typename enum_t::values().map( [&]( auto c ) { return get_name( c, '\'' ); } ),
                    ", ", "(", ")" );
        txn.exec( s.buffer() );
    }

    template< typename table >
    std::enable_if_t< table::is_table > create( txn &txn, table )
    {
        string_builder s;
        s << "create table " << get_name( table() );
        bool first = true;
        auto print_col = [&]( auto col )
        {
            using col_t = decltype( col );
            s << ( first ? "\n  ( " : "\n  , " );
            if constexpr ( col.is_constraint )
            {
                s << "unique ";
                bool first = true;
                auto print = [&]( auto ucol )
                {
                    s << ( first ? "( " : ", " ) << ucol.column_name( ucol );
                    first = false;
                };
                typename col_t::columns().each( print );
                s << " )";
            }
            else
            {
                s << col.column_name( col );
                using type = typename col_t::type;
                if constexpr ( col.is_primary )
                {
                    if ( std::is_same_v< type, int > )
                        s << " serial primary key";
                    else
                        s << " " << sql_type< type >() << " primary key";
                }
                else
                    s << " " << sql_type< type >();
                if constexpr ( col.is_foreign )
                    s << " references " << get_name( typename col_t::table() )
                    << "( " << typename col_t::column().column_name( typename col_t::column() ) << " )";
                if constexpr ( !col.is_nullable )
                    s << " not null";
            }
            first = false;
        };
        typename table::all().each( print_col );
        s << " )";

        txn.exec( s.buffer() );
    };

    template< typename view >
    std::enable_if_t< view::is_view > create( txn &txn, view )
    {
        string_builder s;
        int id = 1;
        s << "create view " << get_name( view() ) << " with ( security_barrier ) as ";
        auto q = view::construct( txn.select( typename view::columns() ) );
        q.print( s, id );
        txn.exec( s.buffer() );
    }

    template< typename schema >
    txn &txn::initdb( schema s, bool clear )
    {
        if ( clear )
            s.reverse().each( [&]( auto t ) { drop( *this, t ); } );
        s.each( [&]( auto t ) { create( *this, t ); } );
        return *this;
    }

    template< typename stream, typename query >
    inline auto operator<<( stream &s, const query &st )
        -> std::enable_if_t< query::is_query, decltype( s << std::string() ) >
    {
        int id = 1;
        st.print( s, id );
        return s;
    }
}

namespace brq
{
    using sql_connection  = sql::conn;
    using sql_transaction = sql::txn;
    using sql_error       = sql::error;
    template< typename... args >
    using sql_schema      = sql::schema< args... >;
    template< typename... args >
    using sql_statement   = sql::stmt< args... >;
}
