// -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4 -*-

/*
 * Copyright (C) 2019 Petr Rockai <code@fixp.eu>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#pragma once
#include "brick-assert"
#include "brick-cons"
#include "brick-except"

#include <unordered_map>
#include <vector>
#include <typeindex>
#include <cxxabi.h>
#include <codecvt>
#include <endian.h> /* beNNtoh / htobeNN */

#include <libpq-fe.h>

namespace brq::sql
{
    struct error : std::runtime_error
    {
        using std::runtime_error::runtime_error;
    };

    struct date { std::int16_t year, month, day; };
    struct time { std::int16_t hour, min, sec; };
    struct timestamp { std::int64_t fract; };

    static std::unordered_map< std::type_index, std::string_view > type_map
    {
        { typeid( short ),          "smallint" },
        { typeid( int ),            "integer" },
        { typeid( long ),           "bigint" },
        { typeid( std::u32string ), "text" },
        { typeid( std::string ),    "bytea" },
        { typeid( const char * ),   "text" },
        { typeid( date ),           "date" },
        { typeid( time ),           "time" },
        { typeid( timestamp ),      "timestamp" },
    };

    template< typename T >
    std::string_view sql_type()
    {
        return brq::sql::type_map[ typeid( T ) ];
    }

    template< typename T >
    std::string_view get_name( T t )
    {
        static std::string name;
        if ( name.empty() )
        {
            int stat;
            char *dem = abi::__cxa_demangle( typeid( T ).name(), nullptr, nullptr, &stat );
            name = strchr( dem, ':' ) ? strrchr( dem, ':' ) + 1 : dem;
            TRACE( dem, "â†’", name );
            std::free( dem );
        }
        return name;
    }

    template< typename T, bool _nullable = false >
    struct column
    {
        template< typename CT >
        static std::string_view column_name( const CT &ct ) { return get_name( ct ); }

        using type = T;
        static constexpr bool is_nullable = _nullable;
        static constexpr bool is_primary = false;
        static constexpr bool is_foreign = false;
        static constexpr bool is_constraint = false;

        static constexpr bool is_expr = true;
        static constexpr bool is_column = true;
        static constexpr bool is_select = false;
    };

    template< typename tab, typename col >
    struct in_table : col
    {
        using table = tab;

        template< typename CT >
        static std::string_view column_name( const CT &ct )
        {
            static auto name = std::string( get_name( table() ) ) +
                               "." + std::string( col().column_name( col() ) );
            return name;
        }
    };

    template< typename col >
    struct max : col
    {
        template< typename CT >
        static std::string_view column_name( const CT &ct )
        {
            static auto name = std::string( "max( " ) +
                               std::string( col().column_name( col() ) ) + " )";
            return name;
        }
    };

    template< typename tab, typename col, bool _nullable = false >
    struct foreign_key : col
    {
        using column = col;
        using table = tab;
        static constexpr bool is_nullable = _nullable;
        static constexpr bool is_foreign = true;
    };

    template< typename col >
    struct primary_key : col
    {
        template< typename CT >
        static std::string_view column_name( const CT & ) { return get_name( col() ); }

        using base = col;
        static constexpr bool is_primary = true;
    };

    template< typename... cols >
    struct unique
    {
        using columns = cons_list_t< cols... >;
        static constexpr bool is_constraint = true;
        static constexpr bool is_table = false;
    };

    template< typename T >
    struct not_constraint { static constexpr bool value = !T::is_constraint; };
    template< typename T >
    struct is_primary { static constexpr bool value = T::is_primary; };

    template< typename... cols >
    struct table
    {
        using all = cons_list_t< cols... >;
        using columns = decltype( all().template filter< not_constraint >() );
        static constexpr bool is_table = true;
    };

    template< typename stream, typename table >
    auto operator<<( stream &s, table ) -> std::enable_if_t< table::is_table, decltype( s << std::string() ) >
    {
        s << "create table " << get_name( table() );
        bool first = true;
        auto print_col = [&]( auto col )
        {
            using col_t = decltype( col );
            s << ( first ? "\n  ( " : "\n  , " );
            if constexpr ( col.is_constraint )
            {
                s << "unique ";
                bool first = true;
                auto print = [&]( auto ucol )
                {
                    s << ( first ? "( " : ", " ) << ucol.column_name( ucol );
                    first = false;
                };
                typename col_t::columns().each( print );
                s << " )";
            }
            else
            {
                s << col.column_name( col );
                if constexpr ( col.is_primary )
                    s << " serial primary key";
                else
                    s << " " << sql_type< typename col_t::type >();
                if constexpr ( col.is_foreign )
                    s << " references " << get_name( typename col_t::table() )
                    << "( " << typename col_t::column().column_name( typename col_t::column() ) << " )";
                if constexpr ( !col.is_nullable )
                    s << " not null";
            }
            first = false;
        };
        typename table::all().each( print_col );
        return s << " )";
    }

    template< typename... tables_ >
    struct schema : cons_list_t< tables_... > {};

    struct txn;

    struct conn
    {
        PGconn *_handle = nullptr;
        PGconn *handle() { return _handle; }

        const char *errmsg() { return PQerrorMessage( _handle ); }

        conn( std::string s )
        {
            if ( !( _handle = PQconnectdb( s.c_str() ) ) )
                throw std::bad_alloc();
            if ( PQstatus( _handle ) != CONNECTION_OK )
                raise< error >() << "connecting to " << s << " " << errmsg();
        }

        ~conn()
        {
            PQfinish( _handle );
        }

        txn begin();
    };

    template< typename... cols >
    struct row
    {
        using columns_t = brq::cons_list_t< cols... >;
        using values_t  = brq::cons_list_t< typename cols::type... >;
        values_t _values;

        row() = default;
        row( typename cols::type... v ): _values( v... ) {}

        template< typename col, typename cs_t, typename vs_t >
        auto &get( vs_t &vs )
        {
            if constexpr ( std::is_same_v< col, typename cs_t::car_t > )
                return vs.car;
            else
                return get< col, typename cs_t::cdr_t >( vs.cdr );
        }

        template< typename col >
        auto &get() { return get< col, columns_t >( _values ); }
    };

    template< typename... cols >
    struct iterator
    {
        PGresult *_result;
        int _row = 0, _col = 0;

        bool operator==( const iterator &o ) const { return o._result == _result && o._row == _row; }
        bool operator!=( const iterator &o ) const { return !( *this == o ); }

        iterator( PGresult *res, int row ) : _result( res ), _row( row ) {}
        iterator &operator++() { ++_row; _col = 0; return *this; }
        iterator operator++( int ) { auto r = *this; ++ (*this); return r; }

        template< typename T >
        void fetch_raw( T &t )
        {
            ASSERT( !PQgetisnull( _result, _row, _col ) );
            std::memcpy( &t, PQgetvalue( _result, _row, _col ), sizeof( T ) );
        }

        void fetch_one( int16_t &t ) { fetch_raw( t ); t = be16toh( t ); }
        void fetch_one( int32_t &t ) { fetch_raw( t ); t = be32toh( t ); }
        void fetch_one( timestamp &t ) { fetch_raw( t.fract ); t.fract = be64toh( t.fract ); }

        void fetch_one( std::u32string &us )
        {
            const char *data = PQgetvalue( _result, _row, _col );
            std::wstring_convert< std::codecvt_utf8< char32_t >, char32_t > conv;
            us = conv.from_bytes( data, data + PQgetlength( _result, _row, _col ) );
        }

        void fetch_one( std::string &s )
        {
            const char *data = PQgetvalue( _result, _row, _col );
            s = std::string( data, data + PQgetlength( _result, _row, _col ) );
        }

        row< cols... > operator*()
        {
            row< cols... > r;
            r._values.each( [&]( auto &v ) { fetch_one( v ); ++ _col; } );
            return r;
        }
    };

    template< typename... cols >
    struct stmt
    {
        using result_t = row< cols... >;

        conn &_conn;
        std::string _txt;

        std::vector< std::unique_ptr< char[] > > _memory;
        std::vector< const char * > _params;
        std::vector< int > _lengths;
        PGresult *_result = nullptr;

        using iterator = sql::iterator< cols... >;
        iterator begin() { return iterator( _result, 0 ); }
        iterator end()   { return iterator( _result, PQntuples( _result ) ); }

        void bind_mem( const char *data, int size )
        {
            _lengths.push_back( size );
            _memory.emplace_back( new char[ size ] );
            std::memcpy( _memory.back().get(), data, size );
            _params.push_back( _memory.back().get() );
        }

        template< typename T >
        stmt( conn &c, const T &t ) : _conn( c )
        {
            string_builder bld;
            bld << t;
            _txt = bld.buffer();
        }

        stmt( const stmt & ) = delete;
        stmt( stmt && ) = default;

        template< typename T >
        void bind_raw( const T &t ) { bind_mem( reinterpret_cast< const char * >( &t ), sizeof( T ) ); }

        void bind_one( int64_t &t ) { t = htobe64( t ); bind_raw( t ); }
        void bind_one( int32_t &t ) { t = htobe32( t ); bind_raw( t ); }
        void bind_one( int16_t &t ) { t = htobe16( t ); bind_raw( t ); }
        void bind_one( const std::string &s ) { bind_mem( s.data(), s.size() ); }
        void bind_one( std::u32string &us )
        {
            std::wstring_convert< std::codecvt_utf8< char32_t >, char32_t > conv;
            auto str = conv.to_bytes( &*us.begin(), &*us.end() );
            bind_mem( str.data(), str.size() );
        }

        stmt &exec()
        {
            std::vector< int > formats( _params.size(), 1 );

            TRACE( "exec:", _txt );
            _result = PQexecParams( _conn.handle(), _txt.c_str(), _params.size(), nullptr,
                                    _params.data(), _lengths.data(), formats.data(), 1 );

            auto r = PQresultStatus( _result );
            if ( r != PGRES_COMMAND_OK && r != PGRES_TUPLES_OK )
                raise< error >() << "executing " << _txt << ": " << _conn.errmsg();

            return *this;
        }

        template< typename list_t >
        stmt &bind_list( list_t list )
        {
            int count = 0;
            list.each( [&]( auto ) { ++count; } );
            _params.reserve( count );
            _memory.reserve( count );

            list.each( [&]( auto &v ) { bind_one( v ); } );
            return *this;
        }

        template< typename... args >
        stmt &bind( const args &... vs )
        {
            return bind_list( cons_list( vs... ) );
        }

        stmt( conn &c, const std::string &s ) : _conn( c ), _txt( s ) {}
    };

    template< typename T >
    constexpr std::enable_if_t< T::is_expr, bool > is_expr( int ) { return true; }
    template< typename T >
    constexpr bool is_expr( fallback ) { return false; }
    template< typename T >
    constexpr bool is_expr() { return is_expr< T >( 0 ); }

    template< typename... args >
    struct where_expr
    {
        static constexpr bool is_expr = true;
        static constexpr bool is_column = false;
        static constexpr bool is_select = false;

        const char *_op;
        cons_list_t< args... > _args;

        template< typename... Ts >
        where_expr( const char *op, Ts && ... ts )
            : _op( op ), _args( ts... )
        {}

        where_expr() = default;

        auto values( nil ) const { return nil(); }

        template< typename T >
        static constexpr bool is_value = std::is_convertible_v< T, std::string_view > ||
                                         std::is_convertible_v< T, std::u32string_view > ||
                                         std::is_convertible_v< T, int >;

        template< typename L >
        auto values( const L &l ) const
        {
            if constexpr ( is_value< typename L::car_t > )
                return make_cons( l.car, values( l.cdr ) );
            if constexpr ( sql::is_expr< typename L::car_t >() )
            {
                if constexpr ( L::car_t::is_column || L::car_t::is_select )
                    return values( l.cdr );
                else
                    return l.car.values().cat( values( l.cdr ) );
            }
        }

        auto values() const { return values( _args ); }

        template< typename stream, typename V >
        void print( stream &s, const V &v, int &id ) const
        {
            if constexpr ( is_value< V > )
                s << "$" << id++ << "::" << sql_type< V >();
            if constexpr ( sql::is_expr< V >() )
            {
                if constexpr ( V::is_column )
                    s << v.column_name( v );
                else if constexpr ( V::is_select )
                    s << "( " << v << " )";
                else
                    v.print( s, id );
            }
        }

        template< typename stream >
        stream &print( stream &s, int &id ) const
        {
            switch ( sizeof...( args ) )
            {
                case 1:
                    s << _op << "( ";
                    print( s, _args.car, id );
                    return s << " )";
                case 2:
                    s << "( ";
                    print( s, _args.car, id );
                    s << " " << _op << " ";
                    print( s, _args.cdr.car, id );
                    return s << " )";
            }
        }

        template< typename stream >
        friend auto operator<<( stream &s, const where_expr &we ) -> decltype( s << std::string() )
        {
            int id = 1;
            we.print( s, id );
            return s;
        }

    };

    template< typename T >
    using unarray_t = std::conditional_t< std::is_array_v< T >, std::remove_extent_t< T > *, T >;

#define BRICK_SQL_OP_(op, sql)                                                      \
    template< typename A, typename B >                                              \
    auto op( A &&a, B &&b )                                             \
        -> std::enable_if_t< is_expr< std::decay_t< A > >() || is_expr< std::decay_t< B > >(), \
                             where_expr< std::decay_t< A >, std::decay_t< B > > > \
    {                                                                               \
        return { sql, a, b };                                                       \
    }

#define BRICK_SQL_OP(op) BRICK_SQL_OP_(operator op, #op)

BRICK_SQL_OP_( operator ==, "=" )
BRICK_SQL_OP_( operator %=, "like" )
BRICK_SQL_OP_( operator &&, "and" )
BRICK_SQL_OP_( operator ||, "or" )
BRICK_SQL_OP_( operator ^, "#" )
BRICK_SQL_OP_( pow, "^" )
BRICK_SQL_OP_( in, "in" )

BRICK_SQL_OP( < )
BRICK_SQL_OP( > )
BRICK_SQL_OP( <= )
BRICK_SQL_OP( >= )
BRICK_SQL_OP( != )
BRICK_SQL_OP( + )
BRICK_SQL_OP( - )
BRICK_SQL_OP( * )
BRICK_SQL_OP( / )
BRICK_SQL_OP( % )
BRICK_SQL_OP( & )
BRICK_SQL_OP( | )

#undef BRICK_SQL_OP

    struct query_base
    {
        static constexpr bool is_column = false;
        static constexpr bool is_select = true;
        static constexpr bool is_expr = true;
    };

    template< typename query >
    struct extend : query_base
    {
        using stmt = typename query::stmt;
        query _query;
        conn &conn() { return _query.conn(); }
        extend( query q ) : _query( q ) {}

        void bind( stmt &s ) { _query.bind( s ); }

        template< typename T >
        stmt _exec( T *t )
        {
            stmt s( t->conn(), *t );
            t->bind( s );
            s.exec();
            return s;
        }
    };

    template< typename select, typename... cols >
    struct group_by : extend< select >
    {
        using extend< select >::extend;
        auto exec() { return this->_exec( this ); }

        template< typename stream >
        friend auto operator<<( stream &s, const group_by &gp ) -> decltype( s << std::string() )
        {
            s << gp._query << " group by ";
            bool first = true;
            cons_list( cols()... ).each( [&]( auto c )
            {
                s << ( first ? "" : ", " ) << c.column_name( c ); first = false;
            } );
            return s;
        }
    };

    template< typename query, typename expr >
    struct where_clause : extend< query >
    {
        expr _expr;
        where_clause( query q, const expr &e ) : extend< query >( q ), _expr( e ) {}

        template< typename stream >
        friend auto operator<<( stream &s, const where_clause &wc ) -> decltype( s << std::string() )
        {
            return s << wc._query << " where " << wc._expr;
        }

        template< typename... group_cols >
        group_by< where_clause, group_cols... > group_by() { return { *this }; }

        auto exec() { return this->_exec( this ); }
        void bind( typename query::stmt &s )
        {
            this->_query.bind( s );
            s.bind_list( _expr.values() );
        }
    };

    template< typename select, typename tab >
    struct select_join : extend< select >
    {
        using table = tab;
        using extend< select >::extend;
        auto exec() { return this->_exec( this ); }

        template< typename stream >
        friend auto operator<<( stream &s, const select_join &sj ) -> decltype( s << std::string() )
        {
            using tab_left = typename select::table;
            using tab_right = tab;

            std::string foreign_column;
            std::string primary_column;

            auto find_foreign_left = [&]( auto t )
            {
                if constexpr ( t.is_foreign )
                    if constexpr ( std::is_same_v< typename decltype( t )::table, tab_left > )
                        foreign_column = t.column_name( t );
            };

            auto find_foreign_right = [&]( auto t )
            {
                if constexpr ( t.is_foreign )
                    if constexpr ( std::is_same_v< typename decltype( t )::table, tab_right > )
                        foreign_column = t.column_name( t );
            };

            auto find_primary = [&]( auto t )
            {
                if ( t.is_primary )
                    primary_column = t.column_name( t );
            };

            s << sj._query << " join " << get_name( tab_right() ) << " on ";

            typename tab_right::columns().each( find_foreign_left );
            typename tab_left::columns().each( find_primary );

            if ( !foreign_column.empty() && !primary_column.empty() )
            {
                return s << get_name( tab_right() ) << "." << foreign_column
                         << " = " << get_name( tab_left() ) << "." << primary_column;
            }
            else
            {
                typename tab_right::columns().each( find_primary );
                typename tab_left::columns().each( find_foreign_right );

                return s << get_name( tab_left() ) << "." << foreign_column
                         << " = " << get_name( tab_right() ) << "." << primary_column;
            }
        }

        template< typename we_t >
        where_clause< select_join, we_t > where( const we_t &we ) { return { *this, we }; }

        template< typename table >
        select_join< select_join, table > join() { return { *this }; }

        template< typename... group_cols >
        group_by< select_join, group_cols... > group_by() { return { *this }; }
    };

    template< typename select, typename tab >
    struct select_tab : extend< select >
    {
        using table = tab;
        using extend< select >::extend;
        auto exec() { return this->_exec( this ); }

        template< typename stream >
        friend auto operator<<( stream &s, const select_tab &st ) -> decltype( s << std::string() )
        {
            return s << st._query << " from " << get_name( tab() );
        }

        template< typename table >
        select_join< select_tab, table > join() { return { *this }; }

        template< typename... group_cols >
        group_by< select_tab, group_cols... > group_by() { return { *this }; }

        template< typename we_t >
        where_clause< select_tab, we_t > where( const we_t &we ) { return { *this, we }; }
    };

    template< typename... cols >
    struct select_cols : query_base
    {
        using stmt = stmt< cols... >;
        conn &_conn;
        conn &conn() { return _conn; }
        select_cols( sql::conn &c ) : _conn( c ) {}
        void bind( stmt & ) {}

        template< typename table >
        select_tab< select_cols, table > from() { return { *this }; }

        template< typename stream >
        friend auto operator<<( stream &s, select_cols ) -> decltype( s << std::string() )
        {
            s << "select ";
            bool first = true;
            cons_list( cols()... ).each( [&]( auto c )
            {
                s << ( first ? "" : ", " ) << c.column_name( c ); first = false;
            } );
            return s;
        }
    };

    template< typename T, typename X = void >
    struct get_key { using type = X; };

    template< typename T >
    struct get_key< T, decltype( typename T::car_t(), void(0) ) >
    {
        using type = typename T::car_t::base;
    };

    template< typename table >
    struct insert
    {
        conn &_conn;
        bool _quiet = false;

        using primary_l = decltype( typename table::columns().template filter< is_primary >() );
        using stmt = std::conditional_t< std::is_same_v< primary_l, brq::nil >, sql::stmt<>,
                                         sql::stmt< typename get_key< primary_l >::type > >;
        insert( conn &c, bool q ) : _conn( c ), _quiet( q ) {}

        template< typename... cols >
        stmt values( const typename cols::type &... v )
        {
            string_builder bld;
            bld << "insert into " << get_name( table() );
            cons_list_t< cols... > l;
            bool first = true;
            l.each( [&]( auto &col )
            {
                bld << ( first ? " ( " : ", " ) << col.column_name( col ); first = false;
            } );
            bld << " ) values";
            int i = 1;
            l.each( [&]( auto ) { bld << ( i == 1 ? " ( " : ", " ) << "$" << i; i ++; } );
            bld << " )";
            if ( _quiet )
                bld << " on conflict do nothing";
            if constexpr ( !std::is_same_v< primary_l, brq::nil > )
            {
                using primary = typename primary_l::car_t;
                bld << " returning " << primary().column_name( primary() );
            }
            stmt s( _conn, bld.buffer() );
            s.bind( v... );
            return s;
        }
    };

    template< typename update, typename... cols >
    struct update_set : extend< update >
    {
        auto exec() { return this->_exec( this ); }
        void bind( typename update::stmt &s ) { this->_query.bind( s ); s.bind_list( _values ); }

        cons_list_t< typename cols::type... > _values;
        update_set( update u, const typename cols::type &... v )
            : extend< update >( u ), _values( v... )
        {}

        template< typename stream >
        friend auto operator<<( stream &s, const update_set &st ) -> decltype( s << std::string() )
        {
            s << st._query << " set ";
            cons_list_t< cols... > list;
            int i = 1;
            list.each( [&]( auto &col )
            {
                s << ( i == 1 ? "" : ", " ) << col.column_name( col ) << " = $" << i;
                ++ i;
            } );
            return s;
        }

        template< typename we_t >
        where_clause< update_set, we_t > where( const we_t &we ) { return { *this, we }; }
    };

    template< typename table >
    struct update
    {
        using stmt = sql::stmt<>;
        conn &_conn;
        conn &conn() { return _conn; }
        update( sql::conn &c ) : _conn( c ) {}
        void bind( stmt & ) {}

        template< typename stream >
        friend auto operator<<( stream &s, const update & ) -> decltype( s << std::string() )
        {
            return s << "update " << get_name( table() );
        }

        template< typename... cols >
        update_set< update, cols... > set( const typename cols::type &... v )
        {
            return { *this, v... };
        }
    };

    struct txn
    {
        conn &_conn;
        bool _closed = false;

        explicit txn( conn &conn ) : _conn( conn )
        {
            exec( "begin transaction" );
        }
        txn( txn&& rhs ) noexcept;

        txn() = delete;
        txn& operator=( const txn &rhs ) = delete;

        txn &commit()
        {
            ASSERT( !_closed );
            exec( "commit transaction" );
            _closed = true;
            return *this;
        }

        txn &rollback() noexcept
        {
            ASSERT( !_closed );
            exec( "rollback transaction" );
            _closed = true;
            return *this;
        }

        txn &exec( std::string q )
        {
            stmt<> s( _conn, q );
            s.exec();
            return *this;
        }

        template< typename schema >
        txn &initdb( schema s, bool clear = false )
        {
            auto drop = [&]( auto t )
            {
                string_builder q;
                q << "drop table if exists " << get_name( t ) << " cascade";
                exec( q.buffer() );
            };

            auto create = [&]( auto t )
            {
                string_builder q;
                q << t;
                exec( q.buffer() );
            };

            if ( clear )
                s.reverse().each( drop );
            s.each( create );
            return *this;
        }

        template< typename... args >
        select_cols< args... > select() { return { _conn }; }

        template< typename table >
        insert< table > insert_into( bool quiet = false ) { return { _conn, quiet }; }

        template< typename table >
        update< table > update() { return { _conn }; }

        ~txn() noexcept { if ( !_closed ) rollback(); }
    };

    inline txn conn::begin() { return txn( *this ); }

}

namespace brq
{
    using sql_connection  = sql::conn;
    using sql_transaction = sql::txn;
    using sql_error       = sql::error;
    template< typename... args >
    using sql_schema      = sql::schema< args... >;
    template< typename... args >
    using sql_statement   = sql::stmt< args... >;
}
