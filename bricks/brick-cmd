// -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4 -*-

/*
 * Copyright (C) 2019 Petr Rockai <code@fixp.eu>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#pragma once
#include "brick-string"
#include "brick-cons"
#include "brick-except"

#include <string>
#include <iostream>
#include <cxxabi.h>

namespace brq
{
    /* The `cmd_flag` class represents an 'implicit' boolean flag. The value is
     * set based on the presence of the flag alone. It is possible to set up a
     * negated version of the flag by using neg() on an instance (the presence
     * of the corresponding command line option will set the flag to false). In
     * contrast, `bool` values lead to flags of the form `--flag {bool}`, i.e.
     * the user will need to explicitly say `--flag yes` or `--flag no`. */

    struct cmd_flag
    {
        struct neg_t
        {
            cmd_flag &f;
            void operator=( bool b ) { f._value = !b; }
        };

        bool _value;

        cmd_flag( bool v = false ) : _value( v ) {}
        operator bool()   const { return  _value; }
        bool operator !() const { return !_value; }
        cmd_flag &operator=( bool b ) { _value = b; return *this; }
        neg_t neg() { return { *this }; }
    };

    static parse_result from_string( std::string_view s, cmd_flag &f )
    {
        return from_string( s, f._value );
    }

    /* The `cmd_option_matcher` class takes care of matching up fragments of a
     * single option or flag. A single option can span several tokens (where
     * each token corresponds to a single command-line argument as passed to the
     * program by the shell). Options are created by the `cmd_options` class
     * defined below. The option definition consists of a number of fragments,
     * where a fragment may or may not consume an entire token. Each fragment is
     * either a literal (which is compared to the input token for a match) or a
     * binding, which uses `from_string` to convert the token (or a token
     * fragment) into a value. */

    struct cmd_option_matcher
    {
        std::vector< std::string > _tokens;

        template< typename T > static constexpr bool is_binding =
            ( std::is_lvalue_reference_v< T > && !std::is_const_v< std::remove_reference_t< T > > ) ||
            std::is_same_v< T, cmd_flag::neg_t >;

        template< typename arg_t >
        std::pair< parse_result, int > bind( std::string token, arg_t &arg, int idx )
        {
            if constexpr ( std::is_same_v< arg_t, cmd_flag > ||
                           std::is_same_v< arg_t, cmd_flag::neg_t > )
            {
                arg = true;
                return { parse_result(), idx };
            }
            else
                return { from_string( token, arg ), idx + 1 };
        }

        std::tuple< bool, int, int > compare( std::string token, std::string pattern, int idx, int off )
        {
            if ( std::isalpha( pattern.back() ) || std::isblank( pattern.back() ) )
                return { brq::starts_with( pattern, token ), idx + 1, 0 };
            else
                return { brq::starts_with( token, pattern ), idx, off + pattern.size() };
        }

        /* Process all the fragments (recursively). If there is a full match,
         * return the index of the first unconsumed token, otherwise return 0.
         * FIXME Partial matches (which ultimately fail) currently overwrite
         * binding fragments in the matching prefix. This is undesirable. */

        using match_result = std::pair< parse_result, int >;

        match_result match( int idx, int off ) { return { parse_result(), off == 0 ? idx : 0 }; }

        template< typename arg_t, typename... args_t >
        match_result match( int idx, int off, arg_t &&a, args_t && ... args )
        {
            std::string token( _tokens[ idx ], off, std::string::npos );
            parse_result matched = no_parse();

            if constexpr ( is_binding< arg_t > ) /* binding-type fragments */
                std::tie( matched, idx ) = bind( token, a, idx );
            else /* literal-type fragment, match it against the input token */
                std::tie( matched, idx, off ) = compare( token, a, idx, off );

            if ( matched )
                return match( idx, off, std::forward< args_t >( args )... );
            else
                return { std::move( matched ), 0 };
        }
    };

    struct cmd_option_help : cmd_option_matcher /* format help for single options */
    {
        brq::string_builder _help;

        template< typename arg_t >
        static std::array< std::string, 1 > names( brq::fallback )
        {
            static std::string name;
            if ( name.empty() )
            {
                int stat;
                char *dem = abi::__cxa_demangle( typeid( arg_t ).name(), nullptr, nullptr, &stat );
                if ( strchr( dem, '<' ) )
                    *strchr( dem, '<' ) = 0;
                name = strchr( dem, ':' ) ? strrchr( dem, ':' ) + 1 : dem;
                if ( name == "basic_string" )
                    name = "string";
            }
            return { name };
        }

        template< typename arg_t >
        static auto names( brq::primary_t ) -> decltype( arg_t::names() ) { return arg_t::names(); }

        void opt_help() { _help << "\t"; }

        template< typename arg_t, typename... args_t >
        void opt_help( arg_t &&arg, args_t && ... args )
        {
            if constexpr ( std::is_same_v< arg_t, cmd_flag & > );
            else if constexpr ( is_binding< arg_t > )
                _help << "{" << names< arg_t >( brq::primary )[ 0 ] << "} ";
            else
            {
                _help << arg;
                if ( std::isalpha( std::string_view( arg ).back() ) )
                    _help << " ";
            }
            opt_help( std::forward< args_t >( args )... );
        }
    };

    /* This class implements the interface that the client uses to describe
     * their CLI. Each user class which represents a command should have an
     * `options` method that takes a reference to `cmd_options` as an argument,
     * and calls its various methods to describe command-line options and flags.
     * See `cmd_help` below for a rudimentary example, or the unit tests at the
     * end of the file for a more involved one. */

    struct cmd_options : protected cmd_option_help
    {
        enum { mode_help, mode_parse } _mode;
        bool _saw_section = false;
        bool _print_help = false;
        int _matches = 0;
        int _index = 0, _next = 0;
        std::vector< std::string > _errors;

        void _opt_matched( int n = 1 )
        {
            ++ _matches;
            _next = _index + n;
        }

        void help( std::string pattern )
        {
            if ( _mode == mode_parse && _tokens[ _index ] == pattern )
                _opt_matched(), _print_help = true;
        }

        void collect( std::string &s )
        {
            if ( _mode == mode_parse && !_matches )
                _opt_matched(), s = _tokens[ _index ];
        }

        template< typename... args_t >
        brq::string_builder &opt( args_t && ... args )
        {
            if ( _mode == mode_help )
            {
                if ( !_saw_section )
                    _help << "\n\nOPTIONS\n";

                _saw_section = true;
                _help << "\n  ";
                opt_help( std::forward< args_t >( args )... );
            }

            if ( _mode == mode_parse )
            {
                auto [ pr, m ] = match( _index, 0, std::forward< args_t >( args )... );
                if ( m )
                    _opt_matched( m - _index );
                else if ( !pr.error().empty() )
                    _errors.emplace_back( pr.error() );
            }

            return _help;
        }

        brq::string_builder &flag( const std::string &name, cmd_flag &f )
        {
            if ( _mode == mode_help )
                opt( "--[no-]" + name.substr( 2 ), f );
            else
            {
                opt( name, f );
                opt( "--no-" + name.substr( 2 ), f.neg() );
            }

            return _help;
        }

        void section( std::string n )
        {
            if ( _mode == mode_help )
                _help << "\n\n" << n << "\n";
            _saw_section = true;
        }
    };

    struct cmd_base
    {
        virtual void run() = 0;
        virtual void prepare() {}
        virtual void options( cmd_options &o ) { o.help( "--help" ); }
        virtual std::string_view help() { return ""; }
        virtual ~cmd_base() {}
    };

    struct cmd_help : cmd_base
    {
        std::string _cmd;
        std::string _help;
        void run() override { std::cerr << tabulate( _help ); }

        void options( cmd_options &o ) override
        {
            o.collect( _cmd );
        }

        static std::array< std::string, 1 > names() { return { "help" }; }
        cmd_help( std::string_view s = "" ) : _help( s ) {}
    };

    struct cmd_option_parser : protected cmd_options
    {
        std::string _argv_0;
        std::string_view _cmd_help;

        template< typename cmd_t >
        std::string cmd_name( cmd_t & ) { return names< cmd_t >( brq::primary )[ 0 ]; }

        template< typename cmd_t >
        string_builder &format_help( cmd_t &c, bool synopsis_only )
        {
            if ( synopsis_only )
                return _help << "  $ " << _argv_0 << " " << cmd_name( c ) << "\n";

            _help << "\nSYNOPSIS\n\n";
            _help << "  $ " << _argv_0 << " " << cmd_name( c ) << " [options]";

            if ( c.help().size() )
            {
                _help << "\n\nDESCRIPTION\n\n";
                brq::string_transform{ quote( "  " ), _help } << c.help();
            }

            _mode = mode_help;
            _saw_section = false;
            c.options( *this );
            _help << "\n\n";
            return _help;
        }

        template< typename cmd_t >
        std::conditional_t< std::is_same_v< cmd_t, cmd_help >, brq::ns< cmd_help, brq::nil >,
                            typename brq::cons_list_t< cmd_t, cmd_help >::co > opt_parse()
        {
            cmd_t cmd;
            _mode = mode_parse;
            _print_help = false;
            _help.kill(); /* turn << into noops */

            while ( _index < _tokens.size() )
            {
                _matches = 0;
                _errors.clear();
                cmd.options( *this );
                if ( _matches == 0 )
                    brq::raise() << "error parsing option '" << _tokens[ _index ] << "'" << _errors;
                if ( _matches > 1 )
                    brq::raise() << "ambiguous option: " << _tokens[ _index ];
                _index = _next;
            }

            _help.clear();

            if ( _print_help )
                return cmd_help{ format_help( cmd, false ).data() };

            return cmd;
        }

        cmd_option_parser( int argc, const char * const *argv, std::string_view help = "" )
            : _argv_0( argv[ 0 ] ), _cmd_help( help )
        {
            std::copy( argv + 1, argv + argc, std::back_inserter( _tokens ) );
        }

        cmd_option_parser( const std::vector< std::string > &v )
        {
            _tokens = v;
        }
    };

    struct cmd_parser : protected cmd_option_parser
    {
        template< typename rv_t, typename cmds_t >
        rv_t cmd_match()
        {
            if constexpr ( cmds_t::empty )
            {
                if ( _matches == 0 )
                    brq::raise() << "no match for command '" << _tokens.front() << "'";
                if ( _matches > 1 )
                    brq::raise() << "ambiguous command '" << _tokens.front() << "'";
                return brq::nil();
            }
            else
            {
                using cmd_t = typename cmds_t::car_t;

                bool match = false;
                for ( auto n : names< cmd_t >( brq::primary ) )
                    if ( brq::starts_with( n, _tokens.front() ) )
                        match = true;

                if ( match )
                    ++ _matches;

                TRACE( "tried", typeid( cmd_t ).name(), "matched", match );
                auto rv = cmd_match< rv_t, typename cmds_t::cdr_t >();

                if ( match )
                {
                    auto v = opt_parse< cmd_t >();
                    if ( auto c = v.template get< cmd_t >() )
                        return std::move( c->get() );
                    else
                        return v.template get< cmd_help >()->get();
                }
                else
                    return rv;
            }
        }

        template< typename... cmds_t >
        cmd_help help_commands( cmd_help h = cmd_help() )
        {
            if ( !h._help.empty() )
                return h;

            cons_list_t< cmds_t... > cmds;
            _help.clear();
            _mode = mode_help;

            if ( h._cmd.empty() )
                _help << "\nSYNOPSIS\n\n";

            auto print = [&]( auto &c )
            {
                if ( h._cmd.empty() || brq::starts_with( cmd_name( c ), h._cmd ) )
                    format_help( c, h._cmd.empty() );
            };

            cmds.each( print );

            if ( h._cmd.empty() && !_cmd_help.empty() )
            {
                _help << "\nDESCRIPTION\n\n";
                brq::string_transform{ quote( "  " ), _help } << _cmd_help;
                _help << "\n\n";
            }

            return cmd_help( _help.data() );
        }

        template< typename... cmds_t >
        typename brq::cons_list_t< cmds_t..., cmd_help >::co parse()
        {
            using list_t = typename brq::cons_list_t< cmds_t... , cmd_help >;
            using rv_t = typename list_t::co;
            rv_t rv = cmd_help();

            auto update_help = [&]( cmd_help c )
            {
                if ( c._help.empty() )
                    rv = help_commands< cmds_t... >( c );
            };

            if ( !_tokens.empty() )
            {
                _index = 1;
                rv = std::move( cmd_match< rv_t, list_t >() );
            }

            rv.match( update_help );
            return rv;
        }

        template< typename... cmds_t >
        std::unique_ptr< cmd_base > get()
        {
            std::unique_ptr< cmd_base > rv;
            auto move = [&]( auto &&c )
            {
                using type = std::remove_const_t< std::remove_reference_t< decltype( c ) > >;
                rv.reset( new type( std::move( c ) ) );
            };
            parse< cmds_t... >().match( move );
            return rv;
        }

        using cmd_option_parser::cmd_option_parser;
    };
}
